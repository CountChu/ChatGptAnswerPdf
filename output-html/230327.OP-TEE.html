
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    @font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
    color:#333;
    background:#fff;
}

body .markdown-body {
    padding: 45px;
    word-wrap: break-word;
}

.markdown-body .octicon-link:before {
  font: normal normal normal 16px/1 octicons-link;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  content: '\f05c';
  vertical-align: middle;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
    </style>
    <title>230327.OP-TEE</title>    
  </head>
  <body>
    <article class="markdown-body">
        <!-- Markdown-generated HTML content here -->
        <h1>230327.OP-TEE</h1>
<p>Created: 2023-04-05 17:23:23</p>
<h1>Questions</h1>
<ul>
<li>Basic Concepts<ul>
<li>https://github.com/OP-TEE</li>
<li>What is OP-TEE?</li>
<li>What is thre prefix OP of OP-TEE?</li>
<li>Are there alternative technologies of OP-TEE?</li>
<li>Does OP-TEE a software or a hardware solution?</li>
<li>Is OP-TEE a firmware?</li>
<li>Does OP-TEE only exist in secure world?</li>
<li>Are there successfull cases of OP-TEE?</li>
<li>What are different between ARM OP-TEE and Intel SMM? Please also summarize in a table.</li>
</ul>
</li>
<li>Boot<ul>
<li>Why does OP-TEE&rsquo;s reset function have two branches reset_primary and reset_secondary?</li>
</ul>
</li>
<li>Multi-Thread &amp; Multi-Process<ul>
<li>Can secure kernel and trusted applications in OP-TEE can be multi-thread?</li>
<li>What is secure context switching in TrustZone?</li>
<li>Does OP-TEE support multi-process?</li>
<li>Does OP-TEE support IPC?</li>
<li>Does OP-TEE OS exist in a single core or multiple cores at run-time?</li>
</ul>
</li>
<li>Memory<ul>
<li>Does OP-TEE support shared memory?</li>
<li>Can secure world can access memory in normal world?</li>
<li>Can normal world access memory in secure world?</li>
<li>How does OP-TEE manage memory?</li>
<li>Are data in memory in secure world encrypted?</li>
<li>What is SMAF?</li>
<li>What is CMA?</li>
</ul>
</li>
<li>Network<ul>
<li>Does OP-TEE support network communication in secure world?</li>
</ul>
</li>
<li>Signature<ul>
<li>Is signature required when a normal world application request a service in secure world?</li>
<li>Does OP-TEE support to verify a signature of a TA in X.509 certificate?</li>
</ul>
</li>
<li>Development<ul>
<li>Which languages do I use to develop apps in OP-TEE or to customize OP-TEE?</li>
<li>Can I use other langauges?</li>
<li>Does OP-TEE support ARMv7 and ARMv8?</li>
<li>Does OP-TEE have a shell?</li>
<li>Can I create a TA at run-time?</li>
<li>But what is TEECI_LoadSecureModule()</li>
<li>What are Static TA and Dynamic TA? Please also summarize them in a table.</li>
<li>Does TEE define Static TA and Dynamic TA?</li>
</ul>
</li>
<li>Qualcomm<ul>
<li>Does Qualcomm support OP-TEE?</li>
<li>Is QTEE open source?</li>
</ul>
</li>
<li>DRM<ul>
<li>How do I implement DRM of content decryption with OP-TEE?</li>
<li>So the content is decrypted in TA in secure world. Right?</li>
<li>But does it slow down the playback speed because of switching between normal world and secure world?</li>
<li>Can I use multi cores to solve the problem? For example, one core decrypts content and another core play content at the same time.</li>
<li>Does OP-TEE support TUI?</li>
<li>Can I develop a TA with TUI to play video in OP-TEE?</li>
<li>How do I implement a DRM solution using ClearKey in OP-TEE?</li>
</ul>
</li>
<li>Secure Storage<ul>
<li>Does OP-TEE support file system?</li>
<li>How does OP-TEE generate SSK from HUK in tee_fs_init_key_manager()?</li>
<li>In the function, can I read the content of the HUK?</li>
<li>How do I protect HUK from reading in OP-TEE?</li>
<li>Is SSK defined in GlobalPlatform?</li>
</ul>
</li>
</ul>
<hr />
<h1>Q &amp; A</h1>
<h2>Basic Concepts</h2>
<p><strong>Question:</strong> https://github.com/OP-TEE</p>
<p><strong>Answer:</strong></p>
<p>The link you provided, <a href="https://github.com/OP-TEE">https://github.com/OP-TEE</a>, is the official GitHub repository for the OP-TEE project. This repository contains the source code, documentation, and other resources related to OP-TEE, an open-source Trusted Execution Environment (TEE) based on the Arm TrustZone technology.</p>
<p>The repository is organized into several sub-projects, including:</p>
<ol>
<li>
<p>optee_os: The core component, which includes the secure kernel and related components that run within the secure world. It manages trusted applications, resources, and secure context switching.</p>
</li>
<li>
<p>optee_client: The library implementing the GlobalPlatform TEE Client API, which enables normal world applications to communicate with trusted applications in the secure world.</p>
</li>
<li>
<p>optee_test: A set of tests and examples to verify the functionality of the OP-TEE system, including trusted application examples and test suites for various cryptographic operations.</p>
</li>
<li>
<p>build: A set of scripts and configuration files to help users build and compile the OP-TEE components for different target platforms.</p>
</li>
</ol>
<p>The GitHub repository is an excellent starting point for developers interested in working with OP-TEE, as it provides the necessary resources and documentation to understand, build, and deploy OP-TEE on supported platforms. If you are interested in learning more or contributing to the project, you can explore the repository, read the documentation, and follow the guidelines provided.</p>
<hr />
<p><strong>Question:</strong> What is OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE (Open Portable Trusted Execution Environment) is an open-source project that aims to provide a secure and trusted execution environment for software applications on devices. OP-TEE is primarily designed for Arm TrustZone technology, which is used in various processors to create a secure area (trusted execution environment) separate from the normal operating system. This separation helps protect sensitive data and code from unauthorized access or tampering.</p>
<p>OP-TEE is made up of several components, including:</p>
<ol>
<li>Secure kernel: This is the core component of OP-TEE that runs in the secure world and manages trusted applications (TAs) and their execution.</li>
<li>Trusted applications: These are the secure applications that run within the secure world, providing security services to normal applications.</li>
<li>Client API: This is the interface that normal applications use to communicate with trusted applications.</li>
<li>TEE Internal Core API: This is the interface used by trusted applications to access TEE services provided by the secure kernel.</li>
</ol>
<p>OP-TEE is widely used in industries like mobile devices, IoT, automotive, and more, where security is of paramount importance. The project is maintained by Linaro, a collaborative organization that focuses on improving open-source software for Arm-based platforms.</p>
<hr />
<p><strong>Question:</strong> What is thre prefix OP of OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>The prefix &ldquo;OP&rdquo; in OP-TEE stands for &ldquo;Open Portable.&rdquo; It signifies that the project is an open-source implementation of a Trusted Execution Environment (TEE) that can be portably used across various platforms, mainly built around Arm TrustZone technology. The name highlights the goals of providing both transparency and flexibility to developers and users who want to create secure applications and services on a wide range of devices.</p>
<hr />
<p><strong>Question:</strong> Are there alternative technologies of OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>Yes, there are alternative technologies to OP-TEE that provide trusted execution environments or similar security features. Some of them include:</p>
<ol>
<li>
<p>Intel SGX (Software Guard Extensions): Intel SGX is a set of security-related instruction codes that are built into some Intel CPUs. It allows developers to create secure enclaves, which are isolated memory regions that protect sensitive data and code from unauthorized access, even from the host operating system or a hypervisor.</p>
</li>
<li>
<p>AMD SEV (Secure Encrypted Virtualization): AMD SEV is a hardware feature found in some AMD processors that encrypts the memory of virtual machines to protect data from unauthorized access. It aims to provide a secure execution environment for applications running in virtualized environments.</p>
</li>
<li>
<p>ARM TrustZone-M: TrustZone-M is a security extension for ARM Cortex-M processors, targeting microcontroller devices used in IoT, industrial control, and other embedded systems. While OP-TEE targets TrustZone technology in application processors, TrustZone-M is tailored for microcontrollers.</p>
</li>
<li>
<p>Google Titan M: Titan M is a custom security chip developed by Google to provide a secure environment for storing sensitive data and performing cryptographic operations on its Pixel smartphones. It is designed to protect the integrity of the bootloader, verify the operating system, and secure user data.</p>
</li>
<li>
<p>Apple Secure Enclave: The Secure Enclave is a coprocessor found in Apple devices, such as iPhones and iPads, that provides a secure environment for cryptographic operations and storage of sensitive data like encryption keys, biometric information, and device passcodes.</p>
</li>
</ol>
<p>These technologies may have different implementations, features, and target applications, but they all aim to enhance security by providing isolated execution environments and protecting sensitive data from unauthorized access.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE a software or a hardware solution?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE is primarily a software solution that leverages underlying hardware capabilities, specifically Arm TrustZone technology, to provide a secure and trusted execution environment for software applications on devices.</p>
<p>OP-TEE includes a secure kernel, trusted applications, and APIs that enable secure communication between the normal and secure worlds. While OP-TEE is a software implementation, it relies on the hardware-based security features provided by Arm TrustZone to create a separate, secure area for sensitive data and code execution.</p>
<p>In summary, OP-TEE is a software solution that takes advantage of hardware-based security technologies to achieve its goals of providing a secure environment for running trusted applications.</p>
<hr />
<p><strong>Question:</strong> Is OP-TEE a firmware?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE can be considered a firmware component, as it is a low-level software that interacts directly with the hardware and provides security services to the system. It serves as the trusted execution environment for devices using Arm TrustZone technology.</p>
<p>Firmware is a type of software that is typically stored in non-volatile memory and provides basic functionality or services to a device&rsquo;s hardware. In the case of OP-TEE, it provides the secure kernel, trusted applications, and APIs for managing and interacting with the secure environment.</p>
<p>OP-TEE is often integrated into the boot process of a device, alongside other firmware components like the bootloader, and it initializes the secure environment before the main operating system starts. This ensures that the secure services and trusted applications provided by OP-TEE are available to the system throughout its operation.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE only exist in secure world?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE is a Trusted Execution Environment (TEE) that leverages Arm TrustZone technology, which provides hardware-based isolation between the normal world and the secure world. OP-TEE consists of components that exist in both the normal world and the secure world.</p>
<ol>
<li>Secure world components:</li>
</ol>
<ul>
<li>Secure kernel: The OP-TEE secure kernel resides in the secure world and manages trusted applications, secure memory, and communication between the normal world and the secure world.</li>
<li>Trusted applications: These are secure services or applications that run in the secure world and provide functionality that requires a higher level of security and isolation.</li>
</ul>
<ol start="2">
<li>Normal world components:</li>
</ol>
<ul>
<li>TEE Client API: This is a library that normal world applications use to communicate with the secure world. It provides an interface for opening sessions, invoking commands, and managing shared memory with trusted applications.</li>
<li>TEE supplicant: The TEE supplicant is a user-space daemon in the normal world that handles certain requests from the secure world, such as loading trusted applications, filesystem operations, and cryptographic operations that involve the normal world&rsquo;s resources.</li>
</ul>
<p>Both the secure world and normal world components of OP-TEE work together to provide a secure and isolated environment for trusted applications, as well as a communication channel between normal world applications and the secure world.</p>
<p>In summary, OP-TEE does not only exist in the secure world. It consists of components in both the normal world and the secure world to create a comprehensive TEE solution that leverages Arm TrustZone technology.</p>
<hr />
<p><strong>Question:</strong> Are there successfull cases of OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>Yes, there have been successful use cases of OP-TEE across various industries and applications that require a secure and trusted execution environment. Some of these include:</p>
<ol>
<li>
<p>Mobile devices: OP-TEE is used in mobile devices like smartphones and tablets to provide a secure environment for handling sensitive data, such as biometric information, cryptographic keys, and DRM (Digital Rights Management) protection.</p>
</li>
<li>
<p>IoT devices: Internet of Things (IoT) devices, such as smart home appliances, wearables, and industrial sensors, benefit from the security provided by OP-TEE. It enables these devices to handle sensitive data securely, execute cryptographic operations, and maintain the confidentiality and integrity of the data being transmitted.</p>
</li>
<li>
<p>Automotive systems: OP-TEE can be used in automotive systems to secure in-vehicle communication, protect sensitive data, and enable secure over-the-air updates.</p>
</li>
<li>
<p>Payment systems: OP-TEE can provide a secure environment for payment applications, ensuring the confidentiality and integrity of financial transactions and sensitive user data.</p>
</li>
<li>
<p>Healthcare devices: Medical devices and healthcare systems can utilize OP-TEE to securely store and process patient data, protecting it from unauthorized access and tampering.</p>
</li>
</ol>
<p>While specific implementations may vary, these examples demonstrate the versatility and effectiveness of OP-TEE in providing a secure and trusted environment for a wide range of applications. The open-source nature of OP-TEE also makes it possible for developers and organizations to customize and adapt the software to fit their unique security requirements.</p>
<hr />
<p><strong>Question:</strong> What are different between ARM OP-TEE and Intel SMM? Please also summarize in a table.</p>
<p><strong>Answer:</strong></p>
<p>ARM OP-TEE and Intel SMM are different security technologies that provide secure and isolated execution environments for sensitive operations. Here&rsquo;s a comparison of the two:</p>
<ol>
<li>ARM OP-TEE:</li>
</ol>
<ul>
<li>Primarily designed for ARM-based platforms using TrustZone technology.</li>
<li>Open-source implementation, maintained by Linaro.</li>
<li>Provides a secure kernel, trusted applications, and APIs for communication between the normal and secure worlds.</li>
<li>Focuses on creating a Trusted Execution Environment (TEE) for secure application execution.</li>
<li>Targets a variety of industries, including mobile devices, IoT, automotive systems, and more.</li>
</ul>
<ol start="2">
<li>Intel SMM (System Management Mode):</li>
</ol>
<ul>
<li>Designed for Intel x86 processors.</li>
<li>A proprietary implementation by Intel.</li>
<li>Provides a separate CPU mode (SMM) with its own address space and execution environment.</li>
<li>Focuses on handling low-level system management tasks, such as power management, hardware monitoring, and firmware updates.</li>
<li>Primarily used for system management tasks on PCs, servers, and other x86-based systems.</li>
</ul>
<p>Summary in a table:</p>
<table>
<thead>
<tr>
<th>Feature/Aspect</th>
<th>ARM OP-TEE</th>
<th>Intel SMM</th>
</tr>
</thead>
<tbody>
<tr>
<td>Platform</td>
<td>ARM-based systems</td>
<td>Intel x86 processors</td>
</tr>
<tr>
<td>Implementation</td>
<td>Open-source</td>
<td>Proprietary</td>
</tr>
<tr>
<td>Primary Focus</td>
<td>Trusted Execution Environment (TEE)</td>
<td>System Management Tasks</td>
</tr>
<tr>
<td>Typical Applications</td>
<td>Mobile, IoT, automotive, etc.</td>
<td>PCs, servers, x86-based systems</td>
</tr>
<tr>
<td>Architecture</td>
<td>ARM TrustZone</td>
<td>System Management Mode</td>
</tr>
</tbody>
</table>
<p>Please note that while both technologies provide a secure and isolated execution environment, they serve different purposes and target different platforms. ARM OP-TEE is designed to enable secure applications on ARM-based devices, while Intel SMM is used for low-level system management tasks on Intel x86-based systems.</p>
<hr />
<h2>Boot</h2>
<p><strong>Question:</strong> Why does OP-TEE&rsquo;s reset function have two branches reset_primary and reset_secondary?</p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE, the reset function has two branches, <code>reset_primary</code> and <code>reset_secondary</code>, to handle the initialization process for multi-core systems. These branches are responsible for initializing the primary and secondary CPU cores, respectively, within the OP-TEE secure world.</p>
<ol>
<li>
<p><code>reset_primary</code>: This branch handles the initialization of the primary CPU core (core 0). The primary core is responsible for setting up the secure environment, initializing the secure kernel, and starting the other secondary cores. The primary core performs tasks such as configuring the MMU (Memory Management Unit), initializing the secure memory, setting up the interrupt controller, and more. Once the primary core has completed its initialization tasks, it starts executing the secure kernel.</p>
</li>
<li>
<p><code>reset_secondary</code>: This branch handles the initialization of secondary CPU cores (core 1, core 2, etc.). The secondary cores also need to set up their own environment, such as configuring their local MMU and enabling their local interrupts, before they can start executing the secure kernel. The primary core signals the secondary cores to begin their initialization process after it has completed its own initialization.</p>
</li>
</ol>
<p>The distinction between <code>reset_primary</code> and <code>reset_secondary</code> branches ensures that the primary core properly initializes the secure environment before the secondary cores start executing the secure kernel. This separation helps maintain a correct and secure boot process in multi-core systems, where multiple CPU cores need to work together within the secure world.</p>
<p>In summary, OP-TEE&rsquo;s reset function has two branches, <code>reset_primary</code> and <code>reset_secondary</code>, to handle the initialization process for multi-core systems, ensuring that the primary core sets up the secure environment correctly before the secondary cores start executing the secure kernel.</p>
<hr />
<h2>Multi-Thread &amp; Multi-Process</h2>
<p><strong>Question:</strong> Can secure kernel and trusted applications in OP-TEE can be multi-thread?</p>
<p><strong>Answer:</strong></p>
<p>As of now, the secure kernel and trusted applications in OP-TEE are primarily single-threaded. The secure world in OP-TEE does not support multi-threading within a single trusted application, meaning each trusted application can only execute one thread at a time.</p>
<p>However, OP-TEE does support parallelism in the sense that it allows multiple trusted applications to be loaded and executed concurrently. This is achieved through the use of secure context switching between different trusted applications, ensuring that only one trusted application is active at a time.</p>
<p>Although the secure environment itself is single-threaded, OP-TEE still enables concurrent communication with normal world applications. Multiple normal world applications can communicate with different trusted applications simultaneously, and OP-TEE will manage the context switching between them.</p>
<p>In summary, the secure kernel and trusted applications in OP-TEE are primarily single-threaded, but parallelism is achieved through secure context switching between multiple trusted applications and concurrent communication with normal world applications.</p>
<hr />
<p><strong>Question:</strong> What is secure context switching in TrustZone?</p>
<p><strong>Answer:</strong></p>
<p>Secure context switching in TrustZone refers to the process of transitioning between different secure contexts (trusted applications) within the secure world while maintaining isolation and security. ARM TrustZone technology provides a hardware-based separation between the normal world and the secure world, allowing both to run independently and securely.</p>
<p>In the context of OP-TEE and TrustZone, when multiple trusted applications are running or when a normal world application requests a service from a trusted application, the secure kernel manages the execution of these trusted applications by performing secure context switching. This involves:</p>
<ol>
<li>
<p>Saving the current context: The secure kernel saves the current state of the active trusted application, including its register values and memory, in a secure location.</p>
</li>
<li>
<p>Restoring the new context: The secure kernel restores the state of the trusted application that is being switched to by loading its previously saved register values and memory.</p>
</li>
<li>
<p>Switching execution: The secure kernel transfers control to the new trusted application, allowing it to continue executing where it left off.</p>
</li>
</ol>
<p>Secure context switching ensures that each trusted application&rsquo;s state is kept separate and secure from others, maintaining isolation and preventing unauthorized access or tampering. Additionally, it allows the secure kernel to manage the concurrent execution of multiple trusted applications and handle requests from normal world applications efficiently.</p>
<p>In summary, secure context switching in TrustZone is the process of managing and transitioning between different trusted applications within the secure world while maintaining isolation, security, and efficient execution.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE support multi-process?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE supports multiple trusted applications (TAs) running concurrently within the secure environment provided by the Arm TrustZone. While the secure world in OP-TEE is primarily single-threaded, it can handle multiple processes in the form of trusted applications.</p>
<p>When multiple trusted applications are loaded and running, OP-TEE manages their execution using secure context switching. This ensures that only one trusted application is active at a time, while maintaining isolation and security between different trusted applications. The secure kernel in OP-TEE is responsible for managing resources, handling requests from the normal world, and switching between the trusted applications as needed.</p>
<p>On the normal world side, multiple processes can communicate with different trusted applications simultaneously, and OP-TEE will manage the context switching between them.</p>
<p>In summary, OP-TEE supports multi-process execution in the form of multiple trusted applications running concurrently within the secure environment, while also allowing multiple normal world processes to communicate with these trusted applications.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE support IPC?</p>
<p><strong>Answer:</strong></p>
<p>Yes, OP-TEE supports Inter-Process Communication (IPC) between trusted applications (TAs) within the secure world and between normal world applications and trusted applications.</p>
<ol>
<li>
<p>IPC between trusted applications: Trusted applications in OP-TEE can share data and communicate with each other by invoking other trusted applications. However, the secure kernel must intermediate such communication to ensure isolation and maintain security. Trusted applications use the TEE_InvokeTACommand function to invoke another trusted application and pass data as parameters.</p>
</li>
<li>
<p>IPC between normal world applications and trusted applications: OP-TEE supports communication between normal world applications and trusted applications through the GlobalPlatform TEE Client API. Normal world applications can open a session with a trusted application, invoke commands, and share data with the trusted application while maintaining security.</p>
</li>
</ol>
<p>In both cases, OP-TEE manages the IPC to ensure isolation between different trusted applications and maintain the security of the secure environment. While the communication mechanisms may vary, OP-TEE provides the necessary APIs and infrastructure to support IPC between trusted applications and between normal world applications and trusted applications.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE OS exist in a single core or multiple cores at run-time?</p>
<p><strong>Answer:</strong></p>
<p>At runtime, the OP-TEE OS exists in a single core. It is designed to run on one core at a time in the secure world. However, OP-TEE supports concurrent execution of Trusted Applications (TAs) on different CPU cores. Although the OS itself runs on a single core, it can manage and schedule TAs running on separate cores, ensuring proper execution and isolation.</p>
<hr />
<h2>Memory</h2>
<p><strong>Question:</strong> Does OP-TEE support shared memory?</p>
<p><strong>Answer:</strong></p>
<p>Yes, OP-TEE supports shared memory, which allows normal world applications to share data with trusted applications (TAs) within the secure environment. Shared memory is used for exchanging data between the normal world and the secure world while maintaining security and isolation.</p>
<p>In OP-TEE, shared memory is managed by the GlobalPlatform TEE Client API, which provides functions for allocating, registering, and releasing shared memory. When a normal world application wants to share data with a trusted application, it creates a shared memory buffer using these API functions. The shared memory buffer is then passed as a parameter to the trusted application when invoking a command.</p>
<p>The secure kernel in OP-TEE ensures that the shared memory buffer is accessible by both the normal world application and the trusted application while preventing unauthorized access or tampering. The secure kernel also maintains the isolation between different trusted applications by limiting access to the shared memory buffers associated with each trusted application.</p>
<p>Please note that shared memory in OP-TEE is primarily used for communication between normal world applications and trusted applications. Sharing memory directly between different trusted applications is generally not supported, as it can compromise the isolation and security provided by the secure environment. Instead, trusted applications communicate with each other using the TEE_InvokeTACommand function, as mentioned in a previous answer regarding IPC support.</p>
<p>In summary, OP-TEE supports shared memory for exchanging data between normal world applications and trusted applications while maintaining security and isolation within the secure environment.</p>
<hr />
<p><strong>Question:</strong> Can secure world can access memory in normal world?</p>
<p><strong>Answer:</strong></p>
<p>In general, the secure world in OP-TEE can access memory in the normal world, but it must do so with caution. The secure world has a higher level of privilege, allowing it to access both secure and normal world memory. However, accessing normal world memory from the secure world can introduce potential security risks, such as data leaks or manipulation of sensitive information.</p>
<p>To minimize such risks, OP-TEE employs a set of precautions and guidelines:</p>
<ol>
<li>
<p>Use shared memory: When secure world applications need to access data from the normal world, it is recommended to use shared memory, which is explicitly allocated and managed by the GlobalPlatform TEE Client API. This ensures proper isolation and access control for the shared data.</p>
</li>
<li>
<p>Validate memory addresses: If the secure world must access normal world memory directly, it should first validate the memory address range to ensure it doesn&rsquo;t overlap with secure memory or any other protected memory region.</p>
</li>
<li>
<p>Be cautious of data manipulation: The secure world should be aware that normal world memory can be manipulated or tampered with by potentially malicious software running in the normal world. Sensitive operations should not rely solely on data stored in normal world memory without additional validation or protection.</p>
</li>
<li>
<p>Minimize normal world memory access: The secure world should minimize direct access to normal world memory whenever possible and instead rely on secure memory or shared memory buffers for data exchange.</p>
</li>
</ol>
<p>While the secure world in OP-TEE can access normal world memory, it should be done with caution and following proper guidelines to maintain the security and isolation provided by the ARM TrustZone technology.</p>
<hr />
<p><strong>Question:</strong> Can normal world access memory in secure world?</p>
<p><strong>Answer:</strong></p>
<p>In the context of OP-TEE and Arm TrustZone technology, the normal world cannot directly access the memory in the secure world. The TrustZone technology enforces hardware-based isolation between the normal and secure worlds, which prevents normal world software from accessing or tampering with secure world memory.</p>
<p>The secure world memory, which includes the secure kernel, trusted applications, and their associated data, is protected from unauthorized access by the normal world. This ensures that sensitive data and operations within the secure world remain confidential and secure.</p>
<p>If a normal world application needs to exchange data with a trusted application in the secure world, it must use shared memory, which is explicitly allocated and managed by the GlobalPlatform TEE Client API. This provides a controlled mechanism for data exchange between the normal and secure worlds, maintaining security and isolation.</p>
<p>In summary, the normal world cannot directly access memory in the secure world, thanks to the hardware-based isolation provided by Arm TrustZone technology. Data exchange between the two worlds is facilitated through shared memory, which is managed by the GlobalPlatform TEE Client API.</p>
<hr />
<p><strong>Question:</strong> How does OP-TEE manage memory?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. Memory management in OP-TEE involves several aspects:</p>
<ol>
<li>
<p>Secure memory allocation: OP-TEE uses secure memory for storing sensitive data and code related to the secure kernel and trusted applications (TAs). It ensures that secure memory is not accessible by the normal world to maintain confidentiality and integrity. OP-TEE provides APIs for trusted applications to allocate and deallocate secure memory dynamically.</p>
</li>
<li>
<p>Trusted Application memory isolation: OP-TEE maintains memory isolation between different trusted applications, preventing them from accessing each other&rsquo;s memory regions. This ensures the confidentiality and integrity of data and code in each trusted application.</p>
</li>
<li>
<p>Shared memory management: OP-TEE manages shared memory to facilitate secure data exchange between the normal world and the secure world. The GlobalPlatform TEE Client API provides functions to allocate, register, and release shared memory. OP-TEE ensures proper access control and isolation for shared memory buffers.</p>
</li>
<li>
<p>Memory mapping: OP-TEE manages the memory mapping for the secure world, ensuring that the memory regions for the secure kernel, trusted applications, and shared memory are correctly mapped to physical memory addresses.</p>
</li>
<li>
<p>Memory protection: OP-TEE enforces memory protection policies for the secure world, including access controls, permissions, and execution restrictions. This helps prevent unauthorized access, tampering, or execution of secure memory regions.</p>
</li>
<li>
<p>Memory management for trusted applications: Trusted applications in OP-TEE can request memory from the TEE Core, which is the secure kernel, through TEE Internal API functions like TEE_Malloc, TEE_Realloc, and TEE_Free. These functions allow trusted applications to allocate and manage memory dynamically within their secure environment.</p>
</li>
</ol>
<p>In summary, OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. This includes secure memory allocation, isolation between trusted applications, shared memory management, memory mapping, memory protection, and dynamic memory management for trusted applications.</p>
<hr />
<p><strong>Question:</strong> Are data in memory in secure world encrypted?</p>
<p><strong>Answer:</strong></p>
<p>Data stored in the memory of the secure world in OP-TEE is not encrypted by default. However, the secure world memory is protected by the hardware-based isolation provided by Arm TrustZone technology. TrustZone ensures that the normal world cannot directly access or tamper with the secure world&rsquo;s memory, which includes the secure kernel, trusted applications, and their associated data.</p>
<p>Although the data in the secure world memory is not encrypted, the isolation and access controls provided by TrustZone offer a strong level of protection. If an application or use case demands an even higher level of security, it is possible for trusted applications to implement additional encryption or other security measures for sensitive data stored in memory. This would depend on the specific requirements and threat model of the application or system.</p>
<p>In summary, data in the secure world memory is not encrypted by default in OP-TEE, but it is protected by the hardware-based isolation provided by Arm TrustZone technology. Additional encryption or security measures can be implemented by trusted applications if required.</p>
<hr />
<p><strong>Question:</strong> What is SMAF?</p>
<p><strong>Answer:</strong></p>
<p>SMAF stands for Secure Memory Allocation Framework, which is a part of the OP-TEE project. SMAF is designed to provide secure memory allocation and management in a Trusted Execution Environment (TEE). It allows OP-TEE to allocate, deallocate, and manage memory resources efficiently and securely within the secure world.</p>
<p>SMAF provides various features, including:</p>
<ol>
<li>
<p>Secure memory allocation: SMAF enables the allocation of secure memory for Trusted Applications (TAs) and the OP-TEE OS within the secure world.</p>
</li>
<li>
<p>Memory isolation: SMAF ensures that memory allocated to a TA is isolated from other TAs and the OP-TEE OS, protecting sensitive data from unauthorized access or tampering.</p>
</li>
<li>
<p>Fine-grained access control: SMAF provides fine-grained access control over memory regions, allowing TAs and the OP-TEE OS to specify access permissions for different memory areas.</p>
</li>
<li>
<p>Efficient memory management: SMAF includes mechanisms for efficient memory management, such as memory pooling and caching, to optimize resource utilization and reduce memory fragmentation.</p>
</li>
</ol>
<p>Overall, SMAF plays a critical role in maintaining the security and integrity of data within the OP-TEE environment. By providing secure memory allocation and management features, SMAF helps ensure that sensitive information remains protected from potential threats in the normal world and other trusted applications running in the secure world.</p>
<hr />
<p><strong>Question:</strong> What is CMA?</p>
<p><strong>Answer:</strong></p>
<p>CMA stands for Contiguous Memory Allocator, a feature in the Linux kernel that helps to allocate large contiguous blocks of memory. In systems where memory fragmentation is an issue, CMA can be particularly useful for devices and drivers that require large contiguous memory regions for their operation, such as multimedia hardware or devices using Direct Memory Access (DMA).</p>
<p>CMA works by reserving a portion of memory during the system boot process. This reserved memory region, known as the CMA pool, is kept separate from the general-purpose system memory. When a device or driver needs a large contiguous block of memory, it can request the allocation from the CMA pool. This approach reduces the likelihood of memory fragmentation and ensures that large contiguous memory regions are available when required.</p>
<p>CMA is not specific to OP-TEE but can be used in conjunction with OP-TEE in some cases. For example, OP-TEE may use CMA to allocate a large block of memory for a Trusted Application (TA) that requires a significant amount of contiguous memory. Additionally, CMA can be used to manage memory shared between the normal world and the secure world, ensuring that the shared memory regions are allocated contiguously and can be efficiently accessed by both worlds.</p>
<p>It is important to note that CMA should be used with caution, as reserving a large portion of memory for the CMA pool can impact overall system performance and memory utilization. Careful consideration of the trade-offs and system requirements is necessary when using CMA in a specific implementation.</p>
<hr />
<h2>Network</h2>
<p><strong>Question:</strong> Does OP-TEE support network communication in secure world?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE does not provide built-in support for direct network communication from within the secure world. The main reason for this is to maintain the security and isolation of the secure environment, as exposing networking capabilities directly to the secure world could introduce potential vulnerabilities or attack surfaces.</p>
<p>In most use cases, network communication is handled by normal world applications. If there is a need for secure communication involving trusted applications in the secure world, it is usually done indirectly:</p>
<ol>
<li>
<p>Normal world applications handle network communication and exchange data with trusted applications in the secure world using the GlobalPlatform TEE Client API and shared memory.</p>
</li>
<li>
<p>Secure operations, such as encryption, decryption, or authentication, can be performed by trusted applications in the secure world. The normal world application can then send or receive the processed data over the network.</p>
</li>
<li>
<p>If end-to-end security is required, the normal world application can use additional encryption or authentication protocols, in conjunction with secure operations performed by trusted applications.</p>
</li>
</ol>
<p>By handling network communication in the normal world and only exchanging data with the secure world as needed, OP-TEE maintains the isolation and security of the secure environment while still enabling secure network communication indirectly.</p>
<p>In summary, OP-TEE does not support direct network communication within the secure world. Instead, network communication is typically handled by normal world applications, which can securely exchange data with trusted applications in the secure world using the GlobalPlatform TEE Client API and shared memory.</p>
<hr />
<h2>Signature</h2>
<p><strong>Question:</strong> Is signature required when a normal world application request a service in secure world?</p>
<p><strong>Answer:</strong></p>
<p>A signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. The communication between the normal world application and the trusted application is facilitated using the GlobalPlatform TEE Client API, which ensures proper access control and isolation for shared memory buffers used for data exchange.</p>
<p>However, a signature may be used in certain scenarios to enhance security. For example, if the normal world application sends sensitive data or a critical command to the trusted application, it might be useful to sign the data or command to ensure integrity and authenticity. This would help prevent tampering or replay attacks, especially in cases where the normal world might be compromised.</p>
<p>In such cases, the normal world application can sign the data or command using a private key, and the trusted application in the secure world can verify the signature using the corresponding public key. This ensures that the data or command has not been altered and that it originates from a trusted source.</p>
<p>In summary, a signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. However, signatures can be used in certain scenarios to enhance security by ensuring the integrity and authenticity of data or commands sent to the secure world.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE support to verify a signature of a TA in X.509 certificate?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE supports verifying the signature of a Trusted Application (TA) using X.509 certificates. This verification process is essential to ensure the authenticity and integrity of the TA before loading it into the secure world.</p>
<p>By default, OP-TEE uses a custom file format for TA binaries, which includes a signature generated with a private key. The signature is verified using the corresponding public key during the TA loading process. This public key is typically embedded into the OP-TEE core during the build process.</p>
<p>If you want to use X.509 certificates for verifying TA signatures, you can follow these steps:</p>
<ol>
<li>Build the OP-TEE project with the <code>CFG_TA_ASN1_DER_FORMAT</code> configuration option enabled. This option tells OP-TEE to expect TAs to be signed with X.509 certificates instead of the default custom format.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nx">make</span> <span class="nx">CFG_TA_ASN1_DER_FORMAT</span><span class="p">=</span><span class="nx">y</span>
</code></pre></div>

<ol start="2">
<li>
<p>Sign your TA using an X.509 certificate. You can use tools like OpenSSL to create a certificate and sign the TA binary.</p>
</li>
<li>
<p>Embed the root certificate (or a certificate chain) used to sign the TA into the OP-TEE core during the build process. This certificate is used to verify the TA signature at runtime.</p>
</li>
<li>
<p>When loading a TA, OP-TEE will use the embedded certificate(s) to verify the TA&rsquo;s signature in the X.509 certificate format.</p>
</li>
</ol>
<p>Please note that you&rsquo;ll need to modify your build process and potentially some OP-TEE components to support this feature. Make sure to consult the OP-TEE documentation and source code for more information on how to enable and use X.509 certificates for TA signature verification.</p>
<hr />
<h2>Development</h2>
<p><strong>Question:</strong> Which languages do I use to develop apps in OP-TEE or to customize OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>To develop trusted applications for OP-TEE or to customize the OP-TEE framework, you primarily work with the C programming language. Both the OP-TEE OS (the secure kernel) and trusted applications are typically written in C to ensure low-level control, performance, and compatibility with the Arm TrustZone architecture.</p>
<ol>
<li>
<p>Trusted Applications: To develop a trusted application (TA) for OP-TEE, you write your application code in C, using the TEE Internal Core API as specified by GlobalPlatform. This API provides functions and types for managing memory, cryptography, secure storage, and other operations within the trusted application.</p>
</li>
<li>
<p>Customizing OP-TEE: If you want to modify or extend the OP-TEE OS itself, you will also work with C. The OP-TEE OS codebase is written in C and can be customized to meet specific requirements or to add new features. However, customizing the OP-TEE OS requires a deeper understanding of the secure kernel&rsquo;s internals and the Arm TrustZone technology.</p>
</li>
</ol>
<p>For normal world applications that communicate with the trusted applications, you can use various programming languages, as long as they can interface with the TEE Client API, which is usually provided as a C library. This means that you can use C, C++, or other languages that support C-compatible FFI (Foreign Function Interface) to interact with the secure world.</p>
<p>To summarize, you primarily use the C programming language to develop trusted applications and customize the OP-TEE framework, while normal world applications can be developed using various programming languages, as long as they can interface with the TEE Client API.</p>
<hr />
<p><strong>Question:</strong> Can I use other langauges?</p>
<p><strong>Answer:</strong></p>
<p>While the primary language for developing trusted applications (TAs) and customizing OP-TEE is C, it is possible to use other languages in some scenarios. However, this usually involves additional steps, and you may need to consider the limitations and compatibility of the chosen language with the TEE environment.</p>
<p>For normal world applications, you have more flexibility in choosing a programming language, as long as it can interface with the TEE Client API. Many popular programming languages have Foreign Function Interface (FFI) capabilities, which allow them to call C functions from native libraries. Some examples of such languages include:</p>
<ul>
<li>C++</li>
<li>Python (using <code>ctypes</code> or <code>cffi</code>)</li>
<li>Rust (using <code>bindgen</code> or <code>ctypes</code>)</li>
<li>Go (using <code>cgo</code>)</li>
<li>Node.js (using <code>ffi-napi</code> or <code>node-ffi</code>)</li>
</ul>
<p>For trusted applications, using a language other than C is more challenging, as it must meet certain requirements, such as being compatible with the TEE environment, the TEE Internal Core API, and the constraints of the secure world. Some potential options include:</p>
<ol>
<li>
<p>C++: You may be able to use a subset of C++ to develop trusted applications, as long as you handle low-level details and ensure compatibility with the TEE environment. However, you would need to be cautious about using certain C++ features, such as exceptions and the standard library, which may not be supported or might introduce security risks.</p>
</li>
<li>
<p>Rust: Rust is a systems programming language with strong safety guarantees, which could be suitable for developing trusted applications. There has been some work on using Rust for OP-TEE trusted applications, such as the <code>rust-optee-trustzone-sdk</code> project (<a href="https://github.com/apache/incubator-teaclave-trustzone-sdk">https://github.com/apache/incubator-teaclave-trustzone-sdk</a>). This project provides a Rust SDK for creating TAs and a set of bindings to the TEE Internal Core API.</p>
</li>
</ol>
<p>Using other high-level languages like Python, Java, or JavaScript for trusted applications is generally not feasible due to their runtime environments, memory management, and performance characteristics, which may not be compatible with the constraints of the secure world.</p>
<p>In summary, while it is possible to use other languages for normal world applications and, to some extent, for trusted applications, the primary language for OP-TEE development remains C. When considering an alternative language, be sure to evaluate its compatibility with the TEE environment, the API, and the specific requirements of your application.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE support ARMv7 and ARMv8?</p>
<p><strong>Answer:</strong></p>
<p>Yes, OP-TEE supports both ARMv7 and ARMv8 architectures. OP-TEE is designed to work with Arm TrustZone technology, which is available on both ARMv7 and ARMv8-based processors. Arm TrustZone provides hardware-based isolation between the normal world and the secure world, allowing OP-TEE to implement a Trusted Execution Environment (TEE) that can run trusted applications securely.</p>
<p>While ARMv7 and ARMv8 have some differences in terms of instruction sets and features, OP-TEE is compatible with both architectures and can be used to build secure systems on devices using either ARMv7 or ARMv8 processors.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE have a shell?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE does not have a traditional shell like those found in Unix-like operating systems. However, OP-TEE provides a feature called the &ldquo;Secure Shell&rdquo; (S-Shell), which allows developers and users to interact with the secure world using a command-line interface. The S-Shell is primarily used for debugging purposes and is not intended for production use.</p>
<p>The S-Shell can be accessed using a UART (Universal Asynchronous Receiver/Transmitter) connection to the device running OP-TEE. This connection allows you to view log messages, interact with the secure world, and execute basic commands to manage trusted applications, memory, and other secure resources.</p>
<p>It is important to note that the S-Shell feature should be used carefully and only in controlled environments, as it could potentially expose sensitive information or allow unauthorized access to secure resources if misused.</p>
<p>In summary, while OP-TEE does not have a traditional shell, it does provide an S-Shell feature for debugging purposes. This feature should be used with caution, as it can potentially expose sensitive information or allow unauthorized access to secure resources if not properly managed.</p>
<hr />
<p><strong>Question:</strong> Can I create a TA at run-time?</p>
<p><strong>Answer:</strong></p>
<p>Creating a Trusted Application (TA) at runtime is not a typical use case for OP-TEE. TAs are usually developed, compiled, and signed offline before being deployed to the target device. In the normal process, TAs are loaded by the secure kernel (in the secure world) when requested by a client application (in the normal world).</p>
<p>However, if you have a specific use case that requires creating a TA at runtime, you could theoretically implement a custom mechanism for loading and running code in the secure world dynamically. This would involve significant modifications to the OP-TEE framework and would need to be done with extreme caution to ensure security is maintained.</p>
<p>Such a dynamic TA loading mechanism would likely require the following steps:</p>
<ol>
<li>Develop and compile the TA code in a suitable format that can be loaded into the secure world at runtime.</li>
<li>Transfer the compiled TA code to the target device securely.</li>
<li>Modify the secure kernel to support loading and executing the TA code dynamically, including verifying its authenticity and integrity.</li>
<li>Implement proper access control and isolation mechanisms to ensure the newly loaded TA does not compromise the security of the existing TAs and the secure world.</li>
</ol>
<p>It is crucial to emphasize that implementing a runtime TA creation mechanism is a complex and potentially risky endeavor, and it may introduce security vulnerabilities if not done correctly. You should carefully consider the security implications and whether the benefits of such a feature outweigh the risks before attempting to implement it.</p>
<hr />
<p><strong>Question:</strong> But what is TEECI_LoadSecureModule()</p>
<p><strong>Answer:</strong></p>
<p>My apologies for any confusion earlier. <code>TEECI_LoadSecureModule()</code> is not a part of the standard OP-TEE or GlobalPlatform TEE APIs. It seems to be a custom function name that might have been used in a specific implementation or context.</p>
<p>It&rsquo;s important to reiterate that the standard OP-TEE and GlobalPlatform TEE APIs do not provide a built-in function for loading or creating Trusted Applications (TAs) at runtime. TAs are generally pre-built, signed, and deployed to the device as binaries. The secure kernel then loads the TA when requested by a client application.</p>
<p>If you have encountered <code>TEECI_LoadSecureModule()</code> in some source code or documentation, it might be a custom function that has been implemented for a specific use case or project. To understand its purpose and how it works, you would need to refer to the documentation or source code of that particular implementation.</p>
<hr />
<p><strong>Question:</strong> What are Static TA and Dynamic TA? Please also summarize them in a table.</p>
<p><strong>Answer:</strong></p>
<p>Static TA (Trusted Application) and Dynamic TA are two types of Trusted Applications used within the OP-TEE framework. Here&rsquo;s a summary of their differences in a table:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Static TA</th>
<th>Dynamic TA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loading mechanism</td>
<td>Built into the OP-TEE core</td>
<td>Loaded at runtime as separate binaries</td>
</tr>
<tr>
<td>Memory management</td>
<td>Pre-allocated memory within the TEE core</td>
<td>Allocated dynamically when the TA is loaded</td>
</tr>
<tr>
<td>Lifespan</td>
<td>Lives for the entire duration of the TEE core</td>
<td>Loaded and unloaded on-demand, based on the client&rsquo;s request</td>
</tr>
<tr>
<td>Flexibility</td>
<td>Limited, as changes require recompiling the TEE core</td>
<td>Highly flexible, can be updated or replaced independently of the TEE core</td>
</tr>
<tr>
<td>Initialization process</td>
<td>Initializes during TEE core startup</td>
<td>Initializes when first invoked by a client</td>
</tr>
<tr>
<td>Performance</td>
<td>Faster, as no additional loading is needed</td>
<td>Slower, due to the need to load and initialize the TA at runtime</td>
</tr>
<tr>
<td>Storage</td>
<td>No separate storage required, as it&rsquo;s part of the TEE core</td>
<td>Requires storage for the separate TA binary</td>
</tr>
</tbody>
</table>
<p>Static TAs are built directly into the OP-TEE core binary, which means they are always available when the TEE is running. They have pre-allocated memory within the TEE core and are initialized during the TEE core startup. This makes them faster in terms of performance but less flexible since any changes to a Static TA require recompiling the entire OP-TEE core.</p>
<p>Dynamic TAs, on the other hand, are loaded at runtime as separate binaries. They are more flexible and can be updated or replaced independently of the OP-TEE core. However, they may have a slightly slower performance due to the need to load and initialize the TA at runtime. Dynamic TAs are loaded and unloaded on-demand based on the client&rsquo;s request and have memory allocated dynamically when the TA is loaded.</p>
<hr />
<p><strong>Question:</strong> Does TEE define Static TA and Dynamic TA?</p>
<p><strong>Answer:</strong></p>
<p>The terms &ldquo;Static TA&rdquo; and &ldquo;Dynamic TA&rdquo; are specific to the OP-TEE implementation and are not part of the GlobalPlatform TEE (Trusted Execution Environment) specifications. The GlobalPlatform TEE specifications define the APIs and security requirements for trusted applications, but they do not dictate how TAs should be loaded, stored, or managed within a TEE implementation.</p>
<p>The concepts of static and dynamic TAs are unique to the OP-TEE project and serve as a way to distinguish between different loading and linking mechanisms for trusted applications within the OP-TEE framework. Other TEE implementations might use different terminology or approaches to manage trusted applications.</p>
<p>In summary, the terms &ldquo;Static TA&rdquo; and &ldquo;Dynamic TA&rdquo; are specific to OP-TEE and are not part of the GlobalPlatform TEE specifications.</p>
<hr />
<h2>Qualcomm</h2>
<p><strong>Question:</strong> Does Qualcomm support OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>As of my knowledge cutoff in September 2021, Qualcomm does not officially support OP-TEE for their platforms. Instead, they provide their own Trusted Execution Environment (TEE) solution, known as Qualcomm Trusted Execution Environment (QTEE). QTEE is based on ARM TrustZone technology and is designed to provide a secure environment for running trusted applications on Qualcomm Snapdragon processors.</p>
<p>QTEE offers similar functionality to OP-TEE, providing a secure environment for running sensitive code and protecting sensitive data from unauthorized access or tampering. It includes features such as secure boot, secure storage, cryptographic services, and key management.</p>
<p>While Qualcomm officially supports QTEE on their platforms, it is possible that some developers or third-party companies have attempted to port OP-TEE to Qualcomm devices. However, such ports may not be officially supported by Qualcomm and may not offer the same level of integration, performance, or security as the QTEE solution.</p>
<hr />
<p><strong>Question:</strong> Is QTEE open source?</p>
<p><strong>Answer:</strong></p>
<p>Qualcomm Trusted Execution Environment (QTEE) is not fully open-source. While some components and tools related to QTEE are available as open-source projects, the core implementation of QTEE is proprietary and closed-source.</p>
<p>Qualcomm provides certain tools, libraries, and APIs to facilitate the development of trusted applications (TAs) for QTEE, and some of these resources may be available as open-source projects. However, the QTEE OS and other critical components are closed-source and maintained by Qualcomm.</p>
<p>This is in contrast to OP-TEE, which is an open-source TEE solution maintained by Linaro and supported by various industry partners. With OP-TEE, developers have access to the full source code, enabling them to examine, modify, and contribute to the project as needed.</p>
<hr />
<h2>DRM</h2>
<p><strong>Question:</strong> How do I implement DRM of content decryption with OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>Implementing DRM content decryption with OP-TEE requires the development of a Trusted Application (TA) that handles the decryption process securely within the TEE environment. Here is a step-by-step guide to help you implement DRM content decryption using OP-TEE:</p>
<ol>
<li>
<p>Define decryption requirements: Identify the specific encryption schemes and formats used for the protected content, such as AES-CTR, AES-CBC, or others.</p>
</li>
<li>
<p>Develop a Trusted Application: Create a TA that handles the decryption process. The TA should receive encrypted content and any necessary decryption keys or metadata from the normal world and perform the decryption securely within the TEE environment. It should also return the decrypted content to the normal world application for playback.</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_InvokeCommandEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">session_context</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">command_id</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">param_types</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="n">TEE_NUM_PARAMS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">command_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="nl">TA_DRM_DECRYPT_CMD</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ta_drm_decrypt</span><span class="p">(</span><span class="n">param_types</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<ol start="3">
<li>Implement decryption functionality: Within the TA, implement the necessary decryption algorithms and functionality. You can use the cryptographic operations provided by the TEE Internal API to perform the decryption.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">TEE_Result</span><span class="w"> </span><span class="nf">ta_drm_decrypt</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">param_types</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="n">TEE_NUM_PARAMS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_OperationHandle</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_HANDLE_NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_ObjectHandle</span><span class="w"> </span><span class="n">key_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_HANDLE_NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a transient key object and set the decryption key</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_AllocateTransientObject</span><span class="p">(</span><span class="n">TEE_TYPE_AES</span><span class="p">,</span><span class="w"> </span><span class="n">key_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key_handle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_PopulateTransientObject</span><span class="p">(</span><span class="n">key_handle</span><span class="p">,</span><span class="w"> </span><span class="n">key_attr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate a new operation and set the key for decryption</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_AllocateOperation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_ALG_AES_CBC_NOPAD</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_MODE_DECRYPT</span><span class="p">,</span><span class="w"> </span><span class="n">key_size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_SetOperationKey</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">key_handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Perform the decryption</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_CipherDoFinal</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">encrypted_data</span><span class="p">,</span><span class="w"> </span><span class="n">encrypted_data_size</span><span class="p">,</span><span class="w"> </span><span class="n">decrypted_data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">decrypted_data_size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<ol start="4">
<li>Integrate with the normal world application: Develop a normal world application that communicates with the TA using OP-TEE&rsquo;s GlobalPlatform TEE Client API. The normal world application should be responsible for obtaining encrypted content, the decryption key, and any necessary metadata from the DRM system, and then passing this information to the TA for decryption.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">TEEC_Result</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="n">TEEC_Session</span><span class="w"> </span><span class="n">session</span><span class="p">;</span><span class="w"></span>
<span class="n">TEEC_Operation</span><span class="w"> </span><span class="n">op</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="c1">// Prepare the operation parameters</span>
<span class="n">op</span><span class="p">.</span><span class="n">paramTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_PARAM_TYPES</span><span class="p">(</span><span class="n">TEEC_MEMREF_TEMP_INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_MEMREF_TEMP_INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_MEMREF_TEMP_OUTPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_NONE</span><span class="p">);</span><span class="w"></span>
<span class="n">op</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tmpref</span><span class="p">.</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">encrypted_data</span><span class="p">;</span><span class="w"></span>
<span class="n">op</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tmpref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">encrypted_data_size</span><span class="p">;</span><span class="w"></span>
<span class="n">op</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tmpref</span><span class="p">.</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decryption_key</span><span class="p">;</span><span class="w"></span>
<span class="n">op</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tmpref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decryption_key_size</span><span class="p">;</span><span class="w"></span>
<span class="n">op</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">tmpref</span><span class="p">.</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decrypted_data</span><span class="p">;</span><span class="w"></span>
<span class="n">op</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">tmpref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decrypted_data_size</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Invoke the TA command for decryption</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_InvokeCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="p">,</span><span class="w"> </span><span class="n">TA_DRM_DECRYPT_CMD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<ol start="5">
<li>Test and validate: Test your TA and normal world application to ensure proper decryption and playback of the protected content. Verify that the content is decrypted securely within the TEE environment and is protected from unauthorized access or tampering.</li>
</ol>
<p>By following these steps, you can implement DRM content decryption with OP-TEE, ensuring that the decryption process is secure and protected within</p>
<hr />
<p><strong>Question:</strong> So the content is decrypted in TA in secure world. Right?</p>
<p><strong>Answer:</strong></p>
<p>Yes, that&rsquo;s correct. In the described DRM implementation, the content is decrypted within the Trusted Application (TA) running in the secure world of OP-TEE. The TA receives encrypted content and decryption keys from the normal world application and performs the decryption securely within the TEE environment. The decrypted content is then returned to the normal world application for playback. This approach ensures that sensitive information, such as decryption keys and decrypted content, is protected within the secure world, preventing unauthorized access or tampering.</p>
<hr />
<p><strong>Question:</strong> But does it slow down the playback speed because of switching between normal world and secure world?</p>
<p><strong>Answer:</strong></p>
<p>Switching between the normal world and the secure world does introduce some overhead, as the system needs to perform context switching and maintain the isolation between the two environments. However, this overhead is generally small compared to the overall processing time required for content decryption and playback.</p>
<p>The exact performance impact will depend on various factors, such as the hardware platform, the complexity of the decryption algorithm, and the size of the content being processed. In most cases, the benefits of secure content decryption within the TEE outweigh the slight performance overhead introduced by the world-switching.</p>
<p>To minimize the performance impact, you can optimize the design of your Trusted Application and normal world application. For example, you can:</p>
<ol>
<li>Minimize the number of world switches by processing larger chunks of encrypted content in a single invocation of the Trusted Application.</li>
<li>Optimize the cryptographic operations within the Trusted Application by leveraging hardware-accelerated cryptographic functions, if available on your platform.</li>
<li>Optimize data handling and buffering between the normal world application and the Trusted Application to reduce data copying and memory allocation overhead.</li>
</ol>
<p>By carefully designing and optimizing your implementation, you can ensure that the performance impact of secure content decryption in the TEE is minimized while still providing robust security for your DRM system.</p>
<hr />
<p><strong>Question:</strong> Can I use multi cores to solve the problem? For example, one core decrypts content and another core play content at the same time.</p>
<p><strong>Answer:</strong></p>
<p>Yes, using multi-core processing can help improve the performance of your DRM implementation by parallelizing the decryption and playback processes. If your platform supports multiple cores, you can assign different tasks to different cores to minimize the overhead introduced by secure world and normal world switching. Here&rsquo;s a general approach to achieve this:</p>
<ol>
<li>
<p>Assign content decryption to one core: Designate one core to handle the decryption process within the Trusted Application in the secure world. This core will be responsible for processing encrypted content and performing the decryption using the provided keys.</p>
</li>
<li>
<p>Assign content playback to another core: Designate a different core to handle the playback process in the normal world. This core will be responsible for receiving the decrypted content from the Trusted Application and managing the playback process, including rendering, audio synchronization, and user interaction.</p>
</li>
<li>
<p>Implement inter-core communication: Develop a mechanism for inter-core communication to allow the decryption core and the playback core to exchange data efficiently. This can be achieved using shared memory buffers, message queues, or other communication techniques suitable for your platform.</p>
</li>
<li>
<p>Manage synchronization and buffering: Implement synchronization and buffering mechanisms to ensure smooth playback while maintaining the parallelism between decryption and playback processes. This may involve using semaphores, mutexes, or other synchronization primitives to coordinate data exchange between the cores and prevent buffer overflows or underflows.</p>
</li>
</ol>
<p>By using multi-core processing, you can offload the decryption process to a separate core, reducing the impact of secure world and normal world switching on playback performance. However, keep in mind that implementing a multi-core DRM solution can be more complex, as it requires careful design and synchronization to ensure smooth operation and proper security. Be sure to thoroughly test and validate your implementation to ensure it meets the performance and security requirements of your DRM system.</p>
<hr />
<p><strong>Question:</strong> Does OP-TEE support TUI?</p>
<p><strong>Answer:</strong></p>
<p>Yes, OP-TEE supports Trusted User Interface (TUI), which allows developers to create secure and isolated user interfaces for Trusted Applications (TAs) running within the TEE environment. TUI ensures that sensitive user inputs, such as passwords, PINs, or biometric data, are protected from potential threats in the normal world by providing a secure, isolated display and input handling mechanism.</p>
<p>OP-TEE&rsquo;s TUI implementation leverages ARM TrustZone technology to protect the display and input resources from unauthorized access or tampering. The TUI is rendered and managed within the secure world, and the input data collected through the TUI is kept secure, preventing any leakage to the normal world.</p>
<p>To implement a TUI in your OP-TEE project, you&rsquo;ll need to follow these steps:</p>
<ol>
<li>
<p>Develop a Trusted Application: Create a TA that handles the secure processing required by your application, including any input collected through the TUI.</p>
</li>
<li>
<p>Implement the TUI: Design and develop the TUI within your TA, using the TEE Internal API and any available TUI-specific extensions provided by your platform or device vendor. This may involve creating secure framebuffer objects, managing touch input events, and handling user interaction.</p>
</li>
<li>
<p>Integrate with the normal world application: Develop a normal world application that communicates with your TA, triggering the display of the TUI and receiving any results produced by the TA after processing the secure input.</p>
</li>
<li>
<p>Test and validate: Test your TA, TUI, and normal world application to ensure proper functionality, security, and user experience.</p>
</li>
</ol>
<p>Please note that the specifics of implementing a TUI may vary depending on the hardware platform and device vendor, as different vendors may provide their own TUI extensions or libraries for use with OP-TEE. Consult the documentation and resources provided by your platform or device vendor for detailed guidance on implementing a TUI in your particular environment.</p>
<hr />
<p><strong>Question:</strong> Can I develop a TA with TUI to play video in OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>Developing a Trusted Application (TA) with a Trusted User Interface (TUI) to play video within the OP-TEE secure world is theoretically possible, but there are several practical challenges and limitations to consider. Here are some of the primary concerns:</p>
<ol>
<li>
<p>Performance: Video playback typically requires significant processing power, and the secure world in OP-TEE is generally not designed for high-performance tasks. Video playback within a TA might result in suboptimal performance compared to playback in the normal world.</p>
</li>
<li>
<p>Hardware support: Video playback often relies on hardware acceleration (e.g., GPU or video decoding hardware) to provide smooth and efficient performance. Access to such hardware components from the secure world might not be available or may require platform-specific modifications.</p>
</li>
<li>
<p>Limited resources: OP-TEE and TAs typically have access to a limited amount of memory and processing resources compared to the normal world. This constraint might impact video playback quality and performance.</p>
</li>
<li>
<p>Complexity: Implementing video playback within a TA requires handling various codecs, formats, and hardware components within the secure environment, which can significantly increase the complexity of your solution.</p>
</li>
<li>
<p>Use case justification: Playing video in a TA with TUI may not be necessary in most use cases. It&rsquo;s essential to evaluate if the benefits of secure video playback within the TEE outweigh the complexity, performance, and resource implications.</p>
</li>
</ol>
<p>If you require a secure video playback solution, consider alternative approaches, such as using a DRM system in the normal world and leveraging the TEE for securely handling decryption keys and content decryption. This way, you can still ensure the security of sensitive information while benefiting from the performance and hardware capabilities available in the normal world.</p>
<p>If you have a specific use case that mandates secure video playback within the TEE, consult your hardware platform and device vendor documentation to understand the capabilities and limitations of your target environment. You may need to work closely with the vendor to develop a custom solution that meets your requirements while addressing the challenges and limitations mentioned above.</p>
<hr />
<p><strong>Question:</strong> How do I implement a DRM solution using ClearKey in OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>To implement a DRM solution using ClearKey in OP-TEE, you&rsquo;ll need to develop a Trusted Application (TA) that handles the decryption process within the secure world of OP-TEE, and a normal world application (e.g., a browser or media player) that communicates with the TA for decrypting media content. Here are the general steps:</p>
<ol>
<li>
<p><strong>Develop a Trusted Application (TA):</strong> Create a TA that securely handles decryption keys and content decryption within the TEE environment. The TA will receive encrypted content and decryption keys from the normal world application and perform the decryption securely within the TEE.</p>
</li>
<li>
<p><strong>Implement the ClearKey decryption algorithm:</strong> Since ClearKey is a simple and open-source key system, you can readily find implementations or libraries that can be integrated into your TA. You will need to implement the decryption algorithm (usually AES-128-CBC or AES-128-CTR) within the TA to decrypt the content.</p>
</li>
<li>
<p><strong>Develop a normal world application:</strong> Create a browser or media player application that uses the Encrypted Media Extensions (EME) API with the ClearKey key system. This application will be responsible for handling media playback, parsing the encrypted content, and extracting the necessary metadata (e.g., content encryption keys, initialization vectors) to pass to the TA for decryption.</p>
</li>
<li>
<p><strong>Communication between normal world application and TA:</strong> Establish a secure communication channel between your normal world application and the TA. Your normal world application will send encrypted media content, keys, and other required metadata to the TA, which will then decrypt the content and return it to the normal world application for playback.</p>
</li>
<li>
<p><strong>Test and validate your implementation:</strong> Ensure that your DRM solution works correctly by testing it with various encrypted media content and key configurations. Make sure the implementation provides the necessary security features to protect the content and keys from unauthorized access or tampering.</p>
</li>
</ol>
<p>Keep in mind that ClearKey is a basic key system primarily intended for testing and development purposes. In a production environment, you may want to use a more robust and secure DRM system, such as Widevine or PlayReady, depending on your requirements and platform support. Additionally, be aware that implementing a DRM solution in OP-TEE can be complex, and you&rsquo;ll need to consider the hardware and platform limitations, performance, and security requirements for your specific use case.</p>
<hr />
<h2>Secure Storage</h2>
<p><strong>Question:</strong> Does OP-TEE support file system?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE itself does not provide a full-fledged file system like those found in traditional operating systems. However, it does offer secure storage functionality that allows trusted applications to store and manage persistent data securely. The secure storage feature in OP-TEE is designed to protect sensitive data from unauthorized access and tampering.</p>
<p>The secure storage is implemented using a key-value store model, where each object (file) is associated with a unique identifier. Trusted applications can use the TEE Internal Core API to read, write, and delete objects in the secure storage. This API provides functions like <code>TEE_CreatePersistentObject</code>, <code>TEE_OpenPersistentObject</code>, <code>TEE_ReadObjectData</code>, <code>TEE_WriteObjectData</code>, and <code>TEE_CloseAndDeletePersistentObject</code>.</p>
<p>Under the hood, the secure storage in OP-TEE uses encryption and authentication techniques to protect the stored data. The actual storage is typically located in the normal world file system, but the data is encrypted and protected in such a way that it can only be accessed and manipulated by the intended trusted applications in the secure world.</p>
<p>In summary, OP-TEE does not have a traditional file system, but it does provide secure storage functionality for trusted applications to store and manage sensitive data securely.</p>
<hr />
<p><strong>Question:</strong> How does OP-TEE generate SSK from HUK in tee_fs_init_key_manager()?</p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE, the <code>tee_fs_init_key_manager()</code> function is responsible for generating the Secure Storage Key (SSK) from the Hardware Unique Key (HUK). This process takes place during the initialization of the secure file system. The function can be found in the <code>core/tee/tee_fs_key_manager.c</code> file in the OP-TEE source code.</p>
<p>Here&rsquo;s an overview of the steps involved in generating the SSK from the HUK in <code>tee_fs_init_key_manager()</code>:</p>
<ol>
<li>Retrieve the HUK: The HUK is obtained by calling <code>tee_otp_get_hw_unique_key()</code>. This function retrieves the device-specific hardware unique key and stores it in a <code>tee_hw_unique_key</code> structure.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">tee_hw_unique_key</span><span class="w"> </span><span class="n">huk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tee_otp_get_hw_unique_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huk</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_ERROR_SECURITY</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<ol start="2">
<li>Create a message containing a static string and the device&rsquo;s chip ID: The message is created by concatenating a static string (e.g., &ldquo;ONLY_FOR_tee_fs_ssk&rdquo;) and the device&rsquo;s chip ID, which can be obtained using <code>tee_otp_get_die_id()</code>.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="kt">uint8_t</span><span class="w"> </span><span class="n">message</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ssk_gen_message</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TEE_FS_KM_CHIP_ID_LENGTH</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">ssk_gen_message</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ssk_gen_message</span><span class="p">));</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tee_otp_get_die_id</span><span class="p">(</span><span class="n">message</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ssk_gen_message</span><span class="p">),</span><span class="w"> </span><span class="n">TEE_FS_KM_CHIP_ID_LENGTH</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_SUCCESS</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_ERROR_SECURITY</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<ol start="3">
<li>Derive the SSK: The SSK is derived from the HUK using the HMAC-SHA-256 function. The HMAC function takes the HUK as the key and the message created in the previous step as input data. The result is a 256-bit output, which is used as the SSK.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="kt">uint8_t</span><span class="w"> </span><span class="n">digest</span><span class="p">[</span><span class="n">TEE_FS_KM_HMAC_SHA256_DIGEST_SIZE</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tee_do_hmac_sha256</span><span class="p">(</span><span class="n">huk</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">huk</span><span class="p">.</span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">message</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">),</span><span class="w"> </span><span class="n">digest</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>

<span class="n">memcpy</span><span class="p">(</span><span class="n">tee_fs_ssk</span><span class="p">.</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">digest</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tee_fs_ssk</span><span class="p">.</span><span class="n">key</span><span class="p">));</span><span class="w"></span>
</code></pre></div>

<p>After these steps, the SSK is generated and stored in the <code>tee_fs_ssk</code> global variable, which is used by the secure file system for encryption and decryption.</p>
<p>In summary, the <code>tee_fs_init_key_manager()</code> function in OP-TEE generates the SSK from the HUK by first retrieving the HUK and then using the HMAC-SHA-256 function with a message consisting of a static string and the device&rsquo;s chip ID. The derived SSK is then used for encryption and decryption in the secure file system.</p>
<hr />
<p><strong>Question:</strong> In the function, can I read the content of the HUK?</p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE&rsquo;s <code>tee_fs_init_key_manager()</code> function, the Hardware Unique Key (HUK) is retrieved and stored in a local variable. While it is technically possible to read the content of the HUK within this function, doing so would pose a security risk. The HUK is intended to be a secret key, unique to each device, and should not be exposed to unauthorized parties.</p>
<p>If you want to inspect the HUK for debugging or development purposes, you can use debug logging functions (such as <code>DMSG()</code> or <code>EMSG()</code>) to print the content of the HUK within the <code>tee_fs_init_key_manager()</code> function. However, you should remove or disable such logging statements before deploying your OP-TEE build in a production environment, to ensure the security of the HUK.</p>
<p>Keep in mind that exposing the HUK can lead to potential security vulnerabilities, as it serves as the basis for deriving various other keys (such as the Secure Storage Key) used in OP-TEE&rsquo;s secure services. It is crucial to handle the HUK and other sensitive data carefully to maintain the overall security of the system.</p>
<hr />
<p><strong>Question:</strong> How do I protect HUK from reading in OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>Protecting the Hardware Unique Key (HUK) is essential for ensuring the security of an OP-TEE-based system. Since the HUK is used as the basis for deriving other keys and securing various sensitive operations, it is crucial to keep it confidential. Here are some best practices for protecting the HUK in OP-TEE:</p>
<ol>
<li>
<p>Limit access to the HUK: Ensure that the HUK is only accessed by the necessary parts of the OP-TEE core and limit its exposure to other components. This can be achieved by using the HUK only within trusted functions and avoiding passing it as a parameter to other functions or storing it in global variables.</p>
</li>
<li>
<p>Avoid logging the HUK: When developing or debugging OP-TEE, avoid logging the HUK or any derived keys. If you need to debug HUK-related issues, make sure to remove or disable any logging statements before deploying your build in a production environment.</p>
</li>
<li>
<p>Protect HUK storage in hardware: The HUK is usually stored in a secure, tamper-resistant location within the device hardware, such as a one-time programmable (OTP) memory or a secure element. Ensure that the hardware implementation adequately protects the HUK from unauthorized access or tampering.</p>
</li>
<li>
<p>Protect the HUK during retrieval: When the HUK is retrieved from hardware, use platform-specific secure functions to access it, and make sure that the retrieval process is implemented securely to prevent unauthorized access to the HUK.</p>
</li>
<li>
<p>Secure software implementation: Follow secure coding practices to minimize the risk of software vulnerabilities that could lead to unauthorized access to the HUK or other sensitive data. Regularly review and update the OP-TEE implementation to incorporate the latest security patches and enhancements.</p>
</li>
<li>
<p>Secure boot process: Implement a secure boot process to ensure that only authorized and trusted code can execute on the device. This will help prevent potential attacks that could compromise the HUK or other sensitive information.</p>
</li>
</ol>
<p>By following these best practices, you can help protect the HUK from unauthorized access and maintain the security of your OP-TEE-based system. Remember that safeguarding the HUK is crucial, as it serves as the foundation for various other keys and secure operations within the system.</p>
<hr />
<p><strong>Question:</strong> Is SSK defined in GlobalPlatform?</p>
<p><strong>Answer:</strong></p>
<p>The Secure Storage Key (SSK) concept, as implemented in OP-TEE, is not directly defined by the GlobalPlatform TEE specifications. The GlobalPlatform TEE specifications define a set of APIs and security requirements for Trusted Applications and the TEE itself but do not specifically address the implementation details of secure storage.</p>
<p>In OP-TEE, the SSK is used for encrypting and decrypting data stored in the secure storage. It is derived from the Hardware Unique Key (HUK) using a Key Derivation Function (KDF). While this implementation choice is specific to OP-TEE, it aligns with the broader security goals outlined by the GlobalPlatform TEE specifications, such as ensuring the confidentiality and integrity of data in secure storage.</p>
<p>The GlobalPlatform TEE specifications provide guidance on general security requirements, but individual TEE implementations, such as OP-TEE, can choose how to implement specific features like secure storage and key management, as long as they meet the overall security objectives of the specifications.</p>
<hr />
    </article>
  </body>
</html>
