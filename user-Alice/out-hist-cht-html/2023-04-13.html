
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="github.css" type="text/css">
    <title>2023-04-13</title>    
  </head>
  <body>
    <article class="markdown-body">
        <!-- Markdown-generated HTML content here -->
        <h1>2023-04-13</h1>
<p>Created: 2023-05-01 22:18:02</p>
<h1>Chats</h1>
<ul>
<li>Arm.0410.md<ul>
<li><code>[08:48]</code> How do I specify the execution states (64-bit, 32-bit) of Armv8-A? <code>(Arm.0410.md)</code></li>
<li><code>[08:50]</code> How do I specify AArch32 and AArch64 of Armv8-A? <code>(Arm.0410.md)</code></li>
<li><code>[09:13]</code> Below ariticle &ldquo;In aarch32 state, what is the mechanism to switch to aarch64 in software?&rdquo; come from https://community.arm.com/support-forums/f/architectures-and-processors-forum/6706/in-aarch32-state-what-is-the-mechanism-to-switch-to-aarch64-in-software &hellip; &hellip; <code>(Arm.0410.md)</code></li>
<li><code>[09:17]</code> How do I specify only AArch32 of Armv8-A at run-time? <code>(Arm.0410.md)</code></li>
<li><code>[09:34]</code> Is uboot 32-bit or 64-bit? <code>(Arm.0410.md)</code></li>
</ul>
</li>
<li>EME.0413.md<ul>
<li><code>[11:06]</code> The below text is &ldquo;1. Introduction&rdquo; chapter of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></li>
<li><code>[11:07]</code> The below text is &ldquo;Abstract&rdquo; and &ldquo;Status of This Document&rdquo; chapters of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></li>
<li><code>[11:10]</code> The below text is &ldquo;2. Definitions&rdquo; chapter of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></li>
<li><code>[11:11]</code> The below text is the second part of &ldquo;2. Definitions&rdquo; chapter of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></li>
<li><code>[11:13]</code> What is CDN? <code>(EME.0413.md)</code></li>
<li><code>[11:15]</code> What is Media Stack? <code>(EME.0413.md)</code></li>
<li><code>[11:17]</code> What is MediaKeySession? <code>(EME.0413.md)</code></li>
<li><code>[11:19]</code> Which components does MediaKeySession contain? <code>(EME.0413.md)</code></li>
<li><code>[11:20]</code> Does Media Stack contain many MediaKeySession? <code>(EME.0413.md)</code></li>
<li><code>[11:22]</code> Where do frames exist in Encrypted Media Extensions? <code>(EME.0413.md)</code></li>
</ul>
</li>
<li>OP-TEE.0327.md<ul>
<li><code>[17:07]</code> Who can allocate SMAF memory? TA or CA <code>(OP-TEE.0327.md)</code></li>
<li><code>[17:58]</code> What is opteed? <code>(OP-TEE.0327.md)</code></li>
<li><code>[18:01]</code> What is Op-TEE Dispatcher? <code>(OP-TEE.0327.md)</code></li>
<li><code>[21:54]</code> What is libteec.so? <code>(OP-TEE.0327.md)</code></li>
<li><code>[21:55]</code> Does libteec.so run in EL0 or EL1? <code>(OP-TEE.0327.md)</code></li>
<li><code>[21:56]</code> Does optee.ko run in EL1? <code>(OP-TEE.0327.md)</code></li>
<li><code>[21:58]</code> What is TEE supplicant? <code>(OP-TEE.0327.md)</code></li>
<li><code>[23:03]</code> What is HUK? <code>(OP-TEE.0327.md)</code></li>
<li><code>[23:04]</code> So what is TSK? <code>(OP-TEE.0327.md)</code></li>
</ul>
</li>
<li>DRM.0402.md<ul>
<li><code>[17:15]</code> What is secure data path? <code>(DRM.0402.md)</code></li>
</ul>
</li>
<li>FF-A.0409.md<ul>
<li><code>[21:09]</code> What is SMCCC? <code>(FF-A.0409.md)</code></li>
<li><code>[22:45]</code> What is SPL? <code>(FF-A.0409.md)</code></li>
<li><code>[22:56]</code> What is fip.bin? <code>(FF-A.0409.md)</code></li>
</ul>
</li>
<li>OP-TEE.History.0407.md<ul>
<li><code>[21:37]</code> What is SPU? <code>(OP-TEE.History.0407.md)</code></li>
<li><code>[21:40]</code> Does SPU have secret keys? <code>(OP-TEE.History.0407.md)</code></li>
</ul>
</li>
<li>TrustZone.0329.md<ul>
<li><code>[22:31]</code> Are EL3 and S-EL3 same? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
</ul>
<hr />
<h1>Q &amp; A</h1>
<h2>Arm.0410.md</h2>
<p><strong>Question:</strong> <code>[08:48]</code> How do I specify the execution states (64-bit, 32-bit) of Armv8-A? <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In Armv8-A architecture, the execution state (64-bit or 32-bit) is determined by the Exception Level (EL) and the current mode of operation. The Armv8-A processors have four Exception Levels (EL0 to EL3), with EL0 being the least privileged and EL3 being the most privileged.</p>
<p>To specify the execution state:</p>
<ol>
<li>
<p>AArch64 (64-bit): When operating in AArch64 state, all Exception Levels (EL0 to EL3) use 64-bit general-purpose registers and execute 64-bit instructions. The operating system and applications running on an Armv8-A processor in AArch64 state will be 64-bit.</p>
</li>
<li>
<p>AArch32 (32-bit): In AArch32 state, the processor operates in a manner compatible with the Armv7-A architecture. The processor will use 32-bit general-purpose registers and execute 32-bit ARM or Thumb instructions. In AArch32 state, there are two modes of operation, ARM and Thumb, with Thumb being a more compact instruction set.</p>
</li>
</ol>
<p>In most cases, the choice of execution state is determined by the operating system and firmware during system initialization. Modern operating systems, such as Linux or Android, running on Armv8-A processors typically use the AArch64 state for better performance and memory addressing capabilities.</p>
<p>When writing assembly code or configuring a bootloader, you may need to specify the execution state explicitly. In assembly code, you can use directives like <code>.arch armv8-a</code> for AArch64 and <code>.arch armv8-a+nofp</code> for AArch32. In bootloader configuration, you may need to select the appropriate options to set the target execution state.</p>
<p>In summary, the execution state of an Armv8-A processor is determined by its current mode of operation and Exception Level. Operating systems and firmware typically handle the choice of execution state during system initialization, but you may need to specify it explicitly when writing low-level code or configuring bootloaders.</p>
<hr />
<p><strong>Question:</strong> <code>[08:50]</code> How do I specify AArch32 and AArch64 of Armv8-A? <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In Armv8-A, the execution state (AArch32 or AArch64) is determined by the Exception Level (EL) at which the processor is operating. To specify the execution state for Armv8-A, you need to configure the system during startup or when switching between exception levels. The initial execution state and switch between states are managed by low-level firmware or the operating system.</p>
<p>Here&rsquo;s an overview of how to specify the AArch32 and AArch64 execution states:</p>
<ol>
<li>
<p>When the system starts, the processor begins at the highest available exception level (usually EL3) in the AArch64 state. The firmware initializes the system and configures the desired execution state for each exception level.</p>
</li>
<li>
<p>To switch the execution state for a specific exception level, you need to modify the appropriate system control register. For example, when switching from EL3 to EL1, the firmware can set the appropriate bit in the SCR_EL3 register to configure the processor to enter AArch32 or AArch64 state at EL1.</p>
</li>
</ol>
<ul>
<li>To set AArch64 state for EL1: Set the SCR_EL3.EA bit to 0 (AArch64 state)</li>
<li>To set AArch32 state for EL1: Set the SCR_EL3.EA bit to 1 (AArch32 state)</li>
</ul>
<ol start="3">
<li>When configuring a hypervisor at EL2, you can use the HCR_EL2 register to set the execution state for lower exception levels (EL1 and EL0):</li>
</ol>
<ul>
<li>To set AArch64 state for EL1: Set the HCR_EL2.RW bit to 1 (AArch64 state)</li>
<li>To set AArch32 state for EL1: Set the HCR_EL2.RW bit to 0 (AArch32 state)</li>
</ul>
<p>Please note that these configurations are usually done by the system firmware or the operating system during startup or when transitioning between exception levels. Modifying these settings requires a deep understanding of the system and the Armv8-A architecture to ensure correct operation.</p>
<hr />
<p><strong>Question:</strong> <code>[09:13]</code> Below ariticle &ldquo;In aarch32 state, what is the mechanism to switch to aarch64 in software?&rdquo; come from https://community.arm.com/support-forums/f/architectures-and-processors-forum/6706/in-aarch32-state-what-is-the-mechanism-to-switch-to-aarch64-in-software &hellip; &hellip; <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The discussion in the linked forum post provides a deeper insight into how execution states can be switched between AArch32 and AArch64 in ARMv8-A architecture.</p>
<p>To summarize the key points from the discussion:</p>
<ol>
<li>
<p>Any exception type in AArch32 state could potentially lead to the execution state changing to AArch64. However, no exception taken while in AArch64 will result in the execution state changing to AArch32.</p>
</li>
<li>
<p>For exception returns, an exception return in AArch64 might cause the execution state to change to AArch32. No exception return in AArch32 can lead to the execution state changing to AArch64, except indirectly through triggering another exception that causes the switch.</p>
</li>
<li>
<p>A change of execution state can only occur if there is also a change in Exception Level (EL). For example, an exception from EL0 to EL1 could lead to a change in the execution state, but an exception from EL1 to EL1 could not.</p>
</li>
<li>
<p>The ARMv8-A architecture manual provides pseudocode for handling various exceptions and switching between AArch32 and AArch64 states. The manual can be referred to for understanding the specific conditions for each type of exception.</p>
</li>
</ol>
<p>The exact mechanism for switching between AArch32 and AArch64 execution states depends on the exception type and the system configuration, and can be found in the ARMv8-A architecture manual.</p>
<hr />
<p><strong>Question:</strong> <code>[09:17]</code> How do I specify only AArch32 of Armv8-A at run-time? <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In ARMv8-A architecture, you can use the Execution state (AArch32 or AArch64) depending on the current Exception Level (EL) and the settings of specific configuration registers. Here&rsquo;s how you can ensure the system operates in AArch32 mode at runtime:</p>
<ol>
<li>
<p>Configure the relevant registers:
   - If you are in the Secure state, you need to set the <code>SCR_EL3.RW</code> bit to 0.
   - If you are in the Non-secure state, you need to set the <code>HCR_EL2.RW</code> bit to 0.</p>
</li>
<li>
<p>When executing in the context of an OS or hypervisor, ensure that your software configures the registers correctly to maintain the AArch32 mode. This might include configuring the <code>SCTLR_ELx</code> register and other system registers as needed.</p>
</li>
<li>
<p>When running applications, ensure they are compiled for AArch32 mode. When an exception occurs (e.g., an interrupt or a system call), and the system transitions to a higher EL, it will remain in AArch32 mode if the settings mentioned in step 1 are properly configured.</p>
</li>
</ol>
<p>By following these steps, you ensure that your ARMv8-A system operates in AArch32 mode at runtime. Keep in mind that, depending on your use case, certain performance and features available in AArch64 mode might not be accessible when operating in AArch32 mode.</p>
<hr />
<p><strong>Question:</strong> <code>[09:34]</code> Is uboot 32-bit or 64-bit? <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>U-Boot, or the Universal Bootloader, is a widely used open-source bootloader that can be built for various target platforms and architectures. It can be built for both 32-bit and 64-bit ARM architectures depending on the target system and its requirements.</p>
<p>When building U-Boot for a specific ARM platform, you can configure it to support either 32-bit (AArch32) or 64-bit (AArch64) execution states, depending on the underlying hardware and your requirements. If your target system is based on ARMv8-A or a newer architecture, you may choose to build U-Boot in 64-bit mode to take advantage of the features and performance improvements offered by the AArch64 execution state.</p>
<p>In summary, U-Boot can be built as either 32-bit or 64-bit, depending on the target platform and requirements. The specific execution state depends on the build configuration and the target hardware capabilities.</p>
<hr />
<h2>EME.0413.md</h2>
<p><strong>Question:</strong> <code>[11:06]</code> The below text is &ldquo;1. Introduction&rdquo; chapter of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<ol>
<li>Introduction</li>
</ol>
<p>This section provides an overview of the Encrypted Media Extensions (EME) specification outlined by the World Wide Web Consortium (W3C). EME enables web developers to work with encrypted media content through a standardized API that is compatible with various content protection mechanisms. This allows content providers to create a single application solution for all devices without needing to modify client-side implementations for each user agent or use case.</p>
<p>The EME specification supports encrypted content following container-specific &ldquo;common encryption&rdquo; specifications, allowing for compatibility across different key systems. The unencrypted container of the supported content allows metadata to be provided to the application and maintains compatibility with other HTMLMediaElement features.</p>
<p>Implementers are advised to be mindful of the security and privacy threats and concerns outlined in the EME specification. Key aspects of the specification include the integration and use of underlying Key System implementations, provisions related to security and privacy, as well as guidelines for handling user-specific information and providing users with control over their privacy.</p>
<p>It is important to note that while the EME specification is independent of the source of media data, many implementations only support decrypting media data provided via Media Source Extensions (MSE).</p>
<p>The EME specification also provides an example of a generic stack implemented using the proposed APIs, which highlights the possible flow of API calls and events. However, other combinations of API calls and events can also be utilized.</p>
<hr />
<p><strong>Question:</strong> <code>[11:07]</code> The below text is &ldquo;Abstract&rdquo; and &ldquo;Status of This Document&rdquo; chapters of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Abstract</p>
<p>The Encrypted Media Extensions (EME) proposal extends the HTMLMediaElement, providing APIs to control the playback of encrypted content. EME supports various use cases, from simple clear key decryption to high-value video, depending on the user agent implementation. The API allows applications to control license and key exchange, facilitating the development of robust playback applications compatible with a range of content decryption and protection technologies.</p>
<p>EME does not define a content protection or Digital Rights Management (DRM) system. Instead, it defines a common API for discovering, selecting, and interacting with DRM systems and simpler content encryption systems. Compliance with the specification does not require implementing DRM, as only the Clear Key system is mandated as a common baseline.</p>
<p>The common API supports basic content encryption capabilities, leaving functions like authentication and authorization to page authors. This is done by requiring content protection system-specific messaging to be mediated by the page, rather than assuming out-of-band communication between the encryption system and a license or other servers.</p>
<p>Status of This Document</p>
<p>As of December 2019, the link to the Latest Editor&rsquo;s Draft was updated. The Encrypted Media Extensions document is published as a W3C Recommendation by the HTML Media Extensions Working Group. Comments and feedback are welcome through the GitHub repository or the mailing list archive.</p>
<p>An implementation report used during the Candidate Recommendation exit phase is provided by the Working Group. The document has been reviewed by W3C Members, software developers, and other interested parties and is endorsed by the Director. As a stable document, it can be used as reference material or cited in other documents. W3C promotes the widespread deployment of the specification to enhance the functionality and interoperability of the Web.</p>
<p>The document was produced by a group operating under the 5 February 2004 W3C Patent Policy, and W3C maintains a public list of patent disclosures related to the deliverables of the group. The document is governed by the 1 March 2017 W3C Process Document.</p>
<hr />
<p><strong>Question:</strong> <code>[11:10]</code> The below text is &ldquo;2. Definitions&rdquo; chapter of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<ol start="2">
<li>Definitions</li>
</ol>
<p>Content Decryption Module (CDM)
A CDM is the client component providing functionality, such as decryption, for one or more Key Systems.</p>
<p>Key System
A Key System is a generic term for a decryption mechanism or content protection provider. Key System strings uniquely identify a Key System and are used by the user agent to select a CDM and identify the source of a key-related event.</p>
<p>Key Session
A Key Session, or Session, provides a context for message exchange with the CDM, resulting in keys being made available to the CDM. Sessions are embodied as MediaKeySession objects and are associated with a single instance of Initialization Data provided in the generateRequest() call.</p>
<p>Session ID
A Session ID is a unique string identifier generated by the CDM to identify MediaKeySession objects.</p>
<p>Key
A key refers to a decryption key that can be used to decrypt blocks within media data. Each key is uniquely identified by a key ID.</p>
<p>Usable For Decryption
A key is considered usable for decryption if the CDM is certain the key is currently usable to decrypt one or more blocks of media data.</p>
<p>Key ID
A key ID is a sequence of octets that uniquely identifies the key.</p>
<p>Known Key
A key is considered to be known to a session if the CDM&rsquo;s implementation of the session contains any information about it, regardless of whether the actual key is usable or its value is known.</p>
<p>License
A license is key system-specific state information that includes one or more keys, each associated with a key ID, and potentially other information about key usage.</p>
<p>Initialization Data
Initialization Data is container-specific data used by a CDM to generate a license request.</p>
<p>Associable Values
Two or more identifiers or values are associable if they are identical or it is possible to correlate or associate them with a reasonable amount of time and effort.</p>
<p>Distinctive Value
A Distinctive Value is a value, piece of data, or observable behavior or timing that is not shared across a large population of users or client devices.</p>
<p>Permanent Identifiers
A Permanent Identifier is a value or piece of data that is indelible in some way or otherwise non-trivial for the user to remove, reset, or change.</p>
<p>Distinctive Permanent Identifier
A Distinctive Permanent Identifier is a Permanent Identifier that is distinctive.</p>
<hr />
<p><strong>Question:</strong> <code>[11:11]</code> The below text is the second part of &ldquo;2. Definitions&rdquo; chapter of https://www.w3.org/TR/encrypted-media &hellip; &hellip; <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The text provided is an excerpt from the &ldquo;2. Definitions&rdquo; chapter of the W3C Encrypted Media Extensions (EME) document. It discusses various terms and concepts used in the context of encrypted media. Some key definitions and concepts mentioned include:</p>
<ol>
<li>
<p>Distinctive Identifier: A value that can be associated or correlated by an entity external to the client, beyond what a user may expect on the web platform. Distinctive Identifiers must adhere to identifier requirements like being encrypted, unique per origin and profile, and clearable.</p>
</li>
<li>
<p>Cross-Origin Limitations: To provide Initialization Data in the encrypted event, media data must be CORS-same-origin with the embedding page. If media data is cross-origin, authors should use the crossorigin attribute on the HTMLMediaElement and CORS headers on the media data response.</p>
</li>
<li>
<p>Mixed Content Limitations: Media data must not be mixed content to provide Initialization Data in the encrypted event.</p>
</li>
<li>
<p>Time: Time must be equivalent to that represented in ECMAScript Time Values and Time Range.</p>
</li>
<li>
<p>Expiration Time: The time after which keys will no longer be usable for decryption.</p>
</li>
<li>
<p>Browsing Profile: Refers to different contexts, modes, or temporary states that are expected to behave independently with respect to application-visible state and data in a User Agent on a given machine.</p>
</li>
<li>
<p>Valid Media MIME Type: A valid media MIME type is a media MIME type that is also a valid MIME type, including valid parameters such as codecs.</p>
</li>
</ol>
<p>The excerpt provides detailed explanations, notes, and examples related to these definitions and concepts.</p>
<hr />
<p><strong>Question:</strong> <code>[11:13]</code> What is CDN? <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A Content Delivery Network (CDN) is a system of distributed servers that deliver web content, such as images, videos, stylesheets, and scripts, to users based on their geographical location. The primary goal of a CDN is to improve the performance and availability of web content by reducing the latency experienced by users when they access resources on the internet.</p>
<p>When a user requests a resource, the CDN directs the request to the nearest server (also known as an edge server) in its network, minimizing the distance the data needs to travel and thus reducing latency. CDNs are commonly used by websites with a global audience to ensure faster loading times and a better user experience.</p>
<p>In addition to reducing latency, CDNs can also improve reliability and security by distributing the load across multiple servers and providing protection against DDoS attacks and other web threats.</p>
<hr />
<p><strong>Question:</strong> <code>[11:15]</code> What is Media Stack? <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A Media Stack refers to the collection of software components, protocols, and technologies used to process, transmit, and display multimedia content, such as audio and video, on various devices. The media stack is responsible for handling tasks such as encoding, decoding, streaming, buffering, and rendering media content in a way that ensures a smooth and seamless user experience.</p>
<p>A typical media stack consists of several layers, including:</p>
<ol>
<li>
<p>Application Layer: This layer contains the user interface and interacts with the user, enabling them to access and control the media content.</p>
</li>
<li>
<p>Media Framework Layer: This layer manages the playback of media content and provides APIs for application developers to build media-related features.</p>
</li>
<li>
<p>Codec Layer: This layer handles the encoding and decoding of media content. Codecs (encoder-decoder) are used to compress and decompress audio and video data to enable efficient transmission and storage.</p>
</li>
<li>
<p>Transport Layer: This layer is responsible for transmitting media content over a network. It includes protocols like Real-Time Messaging Protocol (RTMP), Dynamic Adaptive Streaming over HTTP (DASH), and HTTP Live Streaming (HLS) for streaming media content over the internet.</p>
</li>
<li>
<p>Operating System and Hardware Layer: This layer includes the operating system, device drivers, and hardware components that interact with the media stack. It ensures proper integration of media playback with the device&rsquo;s hardware, such as audio and video output systems.</p>
</li>
</ol>
<p>These layers work together to provide a seamless media playback experience for users, regardless of the device or network conditions. The media stack must be optimized for performance, scalability, and compatibility to handle various media formats, codecs, and streaming protocols.</p>
<hr />
<p><strong>Question:</strong> <code>[11:17]</code> What is MediaKeySession? <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>MediaKeySession</code> is an interface in the Encrypted Media Extensions (EME) API, which is a part of the HTML5 standard. The EME API enables web applications to play encrypted media content by providing a means for key exchange and license management between the web application, the Content Decryption Module (CDM), and a license server.</p>
<p>A <code>MediaKeySession</code> object represents a single session between the web application and the CDM. Each session is associated with a unique set of keys or licenses needed to decrypt the protected media content. The <code>MediaKeySession</code> interface provides methods for generating and exchanging messages between the web application and the CDM, allowing the CDM to request and receive decryption keys from a license server.</p>
<p>The typical steps for using <code>MediaKeySession</code> are:</p>
<ol>
<li>Create a <code>MediaKeys</code> object, which represents the CDM, and associate it with an HTML5 <code>HTMLMediaElement</code> (e.g., a <code>&lt;video&gt;</code> element).</li>
<li>Create a <code>MediaKeySession</code> object by calling the <code>createSession()</code> method on the <code>MediaKeys</code> object.</li>
<li>Generate a license request by calling the <code>generateRequest()</code> method on the <code>MediaKeySession</code> object with the required Initialization Data (obtained from the encrypted media content).</li>
<li>Send the license request to the license server.</li>
<li>The license server responds with the required decryption keys or licenses.</li>
<li>Update the <code>MediaKeySession</code> with the decryption keys or licenses received from the license server using the <code>update()</code> method.</li>
</ol>
<p>Once the <code>MediaKeySession</code> has been updated with the appropriate decryption keys or licenses, the media content can be decrypted by the CDM and played back by the <code>HTMLMediaElement</code>. The <code>MediaKeySession</code> also provides methods for managing key expiration and handling session close events.</p>
<hr />
<p><strong>Question:</strong> <code>[11:19]</code> Which components does MediaKeySession contain? <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The <code>MediaKeySession</code> interface in the Encrypted Media Extensions (EME) API does not &ldquo;contain&rdquo; components in a hierarchical sense, but it does provide several properties and methods that allow web applications to interact with Content Decryption Modules (CDMs) for handling encrypted media content. Here are the key properties and methods associated with <code>MediaKeySession</code>:</p>
<ol>
<li>
<p>Properties:
   - <code>sessionId</code>: A read-only property that represents a unique identifier for the session. It is generated by the CDM and can be used to reference the session for subsequent operations.</p>
</li>
<li>
<p>Methods:
   - <code>generateRequest(initDataType, initData)</code>: Generates a license request based on the provided Initialization Data (<code>initData</code>) and its type (<code>initDataType</code>). This method returns a Promise that resolves once the request is created, allowing the application to send the request to the appropriate license server.
   - <code>load(sessionId)</code>: Loads data for a specified <code>sessionId</code> into a new session. This method is useful for loading previously persisted session data, like when resuming playback after a page refresh. It returns a Promise that resolves with a boolean indicating if the data was successfully loaded or not.
   - <code>update(response)</code>: Updates the session with the license or key data received from the license server. The <code>response</code> parameter contains the data. This method returns a Promise that resolves once the session has been updated with the new data.
   - <code>close()</code>: Closes the session and releases any resources associated with it, such as decryption keys. This method returns a Promise that resolves when the session is closed.
   - <code>remove()</code>: Removes any license or key data associated with the session, making the keys no longer usable for decryption. This method returns a Promise that resolves when the data has been removed.</p>
</li>
<li>
<p>Event Handlers:
   - <code>onkeystatuseschange</code>: An event handler that gets called when key status changes occur, such as when a key expires or is released.
   - <code>onmessage</code>: An event handler that gets called when the CDM sends a message to the web application, usually related to license requests or errors.</p>
</li>
</ol>
<p>These properties, methods, and event handlers work together to enable web applications to manage encrypted media sessions, request licenses, update keys, and handle related events.</p>
<hr />
<p><strong>Question:</strong> <code>[11:20]</code> Does Media Stack contain many MediaKeySession? <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The term &ldquo;Media Stack&rdquo; refers to the collection of components, technologies, and interfaces that are involved in media processing and playback in a web browser. This includes components like media codecs, streaming protocols, and APIs like HTMLMediaElement, Media Source Extensions (MSE), and Encrypted Media Extensions (EME).</p>
<p>In the context of EME and encrypted media playback, a Media Stack may interact with multiple MediaKeySessions. Each MediaKeySession represents a unique session for managing encrypted media keys, licenses, and associated events.</p>
<p>During the playback of encrypted media, an application can create and manage multiple MediaKeySessions for different purposes, such as handling different pieces of content, managing multiple keys or licenses, or dealing with different encryption schemes. So, in this sense, the Media Stack can indeed work with multiple MediaKeySessions.</p>
<p>However, it is essential to understand that the Media Stack does not &ldquo;contain&rdquo; MediaKeySessions in a hierarchical sense, but rather interacts with them as part of the overall media processing and playback workflow.</p>
<hr />
<p><strong>Question:</strong> <code>[11:22]</code> Where do frames exist in Encrypted Media Extensions? <code>(EME.0413.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the context of Encrypted Media Extensions (EME), frames refer to the individual video or audio samples that are part of the media stream. EME does not directly handle frames but focuses on the encryption and decryption aspect of media content.</p>
<p>Frames exist within the encrypted media container, such as MPEG-DASH or HLS. These media containers have segments, which contain encrypted frames. The media container&rsquo;s role is to package the video and audio frames along with the necessary metadata required for playback, including encryption-related information like initialization data.</p>
<p>When the media player requests a segment, it processes the encrypted frames and passes the encryption-related information to the EME. The EME then handles the necessary key management, license acquisition, and decryption of content using the Content Decryption Module (CDM). Once the frames are decrypted, they are passed back to the media player for decoding and rendering.</p>
<p>In summary, frames exist within the encrypted media container, and EME manages the process of decryption but does not directly handle the frames themselves. The media player, together with EME and the underlying Content Decryption Module (CDM), work cohesively to handle, decrypt, and render the frames for playback.</p>
<hr />
<h2>OP-TEE.0327.md</h2>
<p><strong>Question:</strong> <code>[17:07]</code> Who can allocate SMAF memory? TA or CA <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the context of OP-TEE (Open Portable Trusted Execution Environment), the SMAF (Secure Memory Allocation Framework) is used to allocate memory for TAs (Trusted Applications).</p>
<p>Typically, the allocation of SMAF memory is managed by the OP-TEE OS (Trusted OS) and is not directly accessible by the CAs (Client Applications) running in the normal world. The reason for this is to maintain a strict separation between the secure and normal worlds, which is essential for the security and isolation of the trusted applications.</p>
<p>When a CA wants to communicate with a TA, it does so using the OP-TEE client API, which allows the CA to send messages and data to the TA. The OP-TEE OS then handles the secure allocation of memory for the TA, ensuring that the sensitive data and code execution remain protected within the secure environment.</p>
<p>In summary, the SMAF memory allocation is typically managed by the OP-TEE OS and is intended for use by TAs, while CAs interact with TAs through the OP-TEE client API.</p>
<hr />
<p><strong>Question:</strong> <code>[17:58]</code> What is opteed? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>opteed</code> is a reference to the OP-TEE driver running in a normal world operating system like Linux. It stands for &ldquo;OP-TEE Daemon&rdquo; and is responsible for handling communication between client applications (CAs) in the normal world and trusted applications (TAs) in the secure world.</p>
<p>The <code>opteed</code> driver is responsible for managing sessions, invoking commands, and handling shared memory buffers when a normal world application interacts with a trusted application running in the secure world of OP-TEE.</p>
<p>It is important to note that <code>opteed</code> is not a standalone daemon process but rather a kernel-level driver that facilitates the communication between the two environments. It is also sometimes referred to as the &ldquo;OP-TEE Linux driver&rdquo; or the &ldquo;OP-TEE Linux Kernel driver.&rdquo;</p>
<hr />
<p><strong>Question:</strong> <code>[18:01]</code> What is Op-TEE Dispatcher? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The OP-TEE dispatcher, sometimes referred to as the &ldquo;Secure Monitor Call (SMC) dispatcher&rdquo; or simply &ldquo;dispatcher,&rdquo; is a component within the OP-TEE Trusted Execution Environment that handles communication between the normal world (non-secure) and the secure world (OP-TEE environment).</p>
<p>When a client application (CA) in the normal world wants to communicate with a trusted application (TA) in the secure world, it sends a request through the OP-TEE driver (opteed) in the form of an SMC call. The SMC call is then intercepted by the OP-TEE dispatcher, which is responsible for processing the call, routing it to the appropriate TA, and returning the results back to the caller.</p>
<p>The dispatcher is responsible for managing the communication and ensuring the security and isolation of the TAs from the normal world, as well as handling secure world tasks such as opening and closing sessions, invoking commands, and managing shared memory.</p>
<p>In summary, the OP-TEE dispatcher is a crucial component that bridges the gap between the normal world and the secure world, ensuring secure communication and execution of trusted applications within the OP-TEE environment.</p>
<hr />
<p><strong>Question:</strong> <code>[21:54]</code> What is libteec.so? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>libteec.so</code> is a shared library in the OP-TEE (Open Portable Trusted Execution Environment) system, which is part of the client-side implementation of the GlobalPlatform TEE Client API. This library allows client applications (CAs) in the normal world to communicate with trusted applications (TAs) running in the secure world, i.e., inside the TEE.</p>
<p>The TEE Client API specifies a set of functions that client applications can use to open and close sessions with trusted applications, to send commands and data to the TAs, and to manage shared memory between the normal world and the secure world. <code>libteec.so</code> provides the implementation of these functions, handling the low-level communication with the OP-TEE OS, usually through a dedicated driver.</p>
<p>In summary, <code>libteec.so</code> is a crucial component that enables applications running in the normal world to utilize the secure services provided by trusted applications within the OP-TEE environment.</p>
<hr />
<p><strong>Question:</strong> <code>[21:55]</code> Does libteec.so run in EL0 or EL1? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>libteec.so</code> runs in EL0 (Exception Level 0) since it is a user-space library that is part of client applications (CAs) in the normal world. EL0 is the lowest privilege level and is where applications run on ARM-based systems.</p>
<p>EL1 (Exception Level 1) is the level at which operating system kernel code runs, and it has a higher privilege level than EL0. The OP-TEE OS, which manages trusted applications (TAs) in the secure world, runs at a higher exception level (EL1 in AArch64 or S-EL1 in AArch32) to ensure isolation between the normal and secure worlds. However, <code>libteec.so</code> is not part of the OP-TEE OS; it is a user-space library for communicating with the TEE from the normal world.</p>
<hr />
<p><strong>Question:</strong> <code>[21:56]</code> Does optee.ko run in EL1? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>optee.ko</code> is a Linux kernel module that runs in the normal world. Since it is part of the kernel, it runs at EL1 (Exception Level 1) on AArch64 systems. EL1 is the level at which operating system kernel code runs, and it has a higher privilege level than EL0, where user-space applications run.</p>
<p>However, it is important to note that <code>optee.ko</code> runs in the normal world, not in the secure world. It serves as a driver to facilitate communication between client applications (CAs) in the normal world and the OP-TEE OS in the secure world. The actual OP-TEE OS runs at a higher exception level (EL1 in AArch64 or S-EL1 in AArch32) in the secure world to ensure isolation between the normal and secure worlds.</p>
<hr />
<p><strong>Question:</strong> <code>[21:58]</code> What is TEE supplicant? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The TEE (Trusted Execution Environment) supplicant is a user-space daemon in the normal world that works alongside the OP-TEE environment. It serves as an intermediary between the TEE OS and the normal world&rsquo;s user-space applications, facilitating communication and providing additional services for TEE operations.</p>
<p>Some of the primary responsibilities of the TEE supplicant include:</p>
<ol>
<li>Loading and managing shared libraries for Trusted Applications (TAs).</li>
<li>Handling communication with storage services, such as file access and data persistence, for TAs.</li>
<li>Assisting with inter-process communication (IPC) between client applications (CAs) and TAs.</li>
<li>Managing cryptographic operations that require access to the normal world.</li>
</ol>
<p>The TEE supplicant is an essential component of the OP-TEE ecosystem, working in tandem with the kernel-side driver (e.g., optee.ko) and user-space TEE client libraries (e.g., libteec.so) to enable a seamless, secure execution environment for sensitive applications.</p>
<hr />
<p><strong>Question:</strong> <code>[23:03]</code> What is HUK? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>HUK stands for Hardware Unique Key. It is a unique, device-specific key that is generated and stored within a device&rsquo;s hardware during manufacturing. HUKs are used to provide a root of trust and ensure secure device identification and authentication. In the context of OP-TEE, the Hardware Unique Key can be used to derive other cryptographic keys to secure various aspects of the system, such as secure storage or secure communication.</p>
<hr />
<p><strong>Question:</strong> <code>[23:04]</code> So what is TSK? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TSK stands for Trusted Storage Key. In the context of OP-TEE, it is a key used to encrypt and authenticate the data stored in the secure storage. The TSK is derived from the Hardware Unique Key (HUK) and other device-specific information, which ensures that the encrypted data can only be accessed and decrypted by the same device. This provides a secure way to store sensitive data, such as cryptographic keys or user credentials, on the device.</p>
<hr />
<h2>DRM.0402.md</h2>
<p><strong>Question:</strong> <code>[17:15]</code> What is secure data path? <code>(DRM.0402.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A secure data path, in the context of digital content protection and DRM (Digital Rights Management) systems, refers to a protected and encrypted communication channel used for transmitting sensitive information, such as content keys, licenses, and encrypted digital content. The secure data path helps to ensure that the data remains confidential and tamper-proof as it moves through various stages of processing, from content delivery to rendering or playback on a user&rsquo;s device.</p>
<p>A secure data path typically involves several key components:</p>
<ol>
<li>
<p>Encryption: Sensitive data is encrypted using strong cryptographic algorithms, ensuring that it remains confidential and unreadable to unauthorized parties during transmission and storage.</p>
</li>
<li>
<p>Authentication: Both the sender and receiver of the data must prove their identities using cryptographic techniques, such as digital signatures or certificates, to ensure that the data is only shared with authorized parties.</p>
</li>
<li>
<p>Secure communication protocols: Protocols like TLS (Transport Layer Security) or DTLS (Datagram Transport Layer Security) are used to establish secure communication channels between the sender and receiver, providing confidentiality, integrity, and authentication for the transmitted data.</p>
</li>
<li>
<p>Hardware-based security: In some cases, secure data paths may utilize hardware-based security features, such as Trusted Execution Environments (TEEs) or secure enclaves, to further protect sensitive data and cryptographic operations from potential software attacks or vulnerabilities.</p>
</li>
<li>
<p>End-to-end protection: A secure data path aims to maintain the confidentiality and integrity of the data throughout its entire lifecycle, from content creation and encryption to delivery, decryption, and playback on the end-user&rsquo;s device.</p>
</li>
</ol>
<p>By implementing a secure data path, content providers and DRM systems can protect sensitive information and digital content from unauthorized access, tampering, or eavesdropping, ensuring that the content is only accessible and consumable by authorized users or devices according to the specified usage rights and restrictions.</p>
<hr />
<h2>FF-A.0409.md</h2>
<p><strong>Question:</strong> <code>[21:09]</code> What is SMCCC? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The SMCCC (Secure Monitor Call Calling Convention) is a standardized calling convention for ARM-based systems, which defines how Secure Monitor Calls (SMCs) are used to request services from a secure monitor, such as Trusted Firmware-A (TF-A). SMCCC provides a consistent interface for communication between the non-secure world (e.g., an operating system) and the secure world (e.g., a trusted execution environment or firmware). This standardized interface allows for better interoperability between different software components and platforms in ARM-based systems.</p>
<hr />
<p><strong>Question:</strong> <code>[22:45]</code> What is SPL? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p>SPL (Secondary Program Loader) is a term used in the context of embedded systems and bootloaders. It is a small, lightweight bootloader that runs before the primary bootloader and is responsible for initializing essential hardware components, such as clocks, memory, and peripherals. After performing the required initialization, the SPL loads the primary bootloader (e.g., U-Boot) into memory and transfers control to it, allowing the primary bootloader to continue the boot process and eventually load the operating system. The use of an SPL can help improve boot time, reduce the complexity of the primary bootloader, and provide a uniform interface for different hardware platforms.</p>
<hr />
<p><strong>Question:</strong> <code>[22:56]</code> What is fip.bin? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>fip.bin</code> (Firmware Image Package) is a binary file used in Arm Trusted Firmware-A (TF-A) for packing multiple firmware images into a single file. It is used as a part of the boot process in Arm-based systems, particularly in the context of Armv8-A architecture.</p>
<p>The <code>fip.bin</code> file typically contains a collection of firmware images, such as:</p>
<ol>
<li>BL1 (First Level Bootloader): Responsible for initial platform setup and loading BL2.</li>
<li>BL2 (Second Level Bootloader): Responsible for loading BL3x images.</li>
<li>BL3-1 (EL3 Runtime Firmware): Provides runtime services, such as PSCI (Power State Coordination Interface), to the lower ELs (Exception Levels).</li>
<li>BL3-2 (Trusted OS Firmware): The Secure-EL1 Payload, typically the TrustZone-based OS or a secure monitor.</li>
<li>BL3-3 (Non-Trusted Firmware): The Non-secure-EL1 Payload, usually the main OS bootloader like U-Boot or GRUB.</li>
</ol>
<p>The <code>fip.bin</code> file is created using the <code>fiptool</code> utility provided by Arm Trusted Firmware. The tool combines the various firmware images into a single binary, which can then be loaded and executed by the platform&rsquo;s bootloader during the boot process. This approach simplifies firmware management and distribution while also enabling the bootloader to locate and authenticate the required images more easily.</p>
<hr />
<h2>OP-TEE.History.0407.md</h2>
<p><strong>Question:</strong> <code>[21:37]</code> What is SPU? <code>(OP-TEE.History.0407.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The Secure Processing Unit (SPU) is a hardware-based security component developed by Qualcomm for their Snapdragon SoCs (System on a Chip). Introduced in 2017, the SPU functions as a Trusted Execution Environment (TEE) and leverages ARM TrustZone technology to create an isolated secure environment within the processor. This secure environment is designed to protect sensitive data, execute security-related tasks, and provide an additional layer of hardware-based security.</p>
<p>The SPU is a separate subsystem within the Snapdragon SoCs, distinct from the main CPU. By being a dedicated hardware component, it offers enhanced security features, ensuring that sensitive data and operations are isolated from potential vulnerabilities in the main CPU or other system components. This helps prevent unauthorized access or tampering, even if other parts of the system are compromised.</p>
<hr />
<p><strong>Question:</strong> <code>[21:40]</code> Does SPU have secret keys? <code>(OP-TEE.History.0407.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, the Secure Processing Unit (SPU) in Qualcomm&rsquo;s Snapdragon SoCs can store and manage secret keys. The SPU is designed to handle sensitive data, including cryptographic keys, ensuring that they are protected from unauthorized access or tampering.</p>
<p>The SPU provides hardware-based security features, such as secure key storage, secure boot, and cryptographic operations, all within an isolated environment separate from the main CPU. By securely managing secret keys and performing encryption and decryption operations within the SPU, it helps maintain the confidentiality and integrity of sensitive data, even if other parts of the system are compromised.</p>
<p>In summary, the SPU in Qualcomm&rsquo;s Snapdragon SoCs is designed to store and manage secret keys securely, providing an additional layer of hardware-based security for sensitive data and operations.</p>
<hr />
<h2>TrustZone.0329.md</h2>
<p><strong>Question:</strong> <code>[22:31]</code> Are EL3 and S-EL3 same? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>No, EL3 and S-EL3 are not the same. EL3 refers to the Exception Level 3, which is the highest privilege level in the ARMv8-A architecture. It is typically used by the Secure Monitor or firmware running in the Secure World.</p>
<p>S-EL3, on the other hand, is an abbreviation for Secure Exception Level 3. It refers to EL3 when the processor is operating in the Secure World. The Secure World has its own set of Exception Levels (S-EL0, S-EL1, and S-EL3), which operate independently of the Non-secure World&rsquo;s Exception Levels (EL0, EL1, and EL2).</p>
<p>While both EL3 and S-EL3 are related to the Secure World, the difference lies in their representation:</p>
<ul>
<li>EL3: Refers to Exception Level 3 in general, without explicitly specifying the security state.</li>
<li>S-EL3: Explicitly refers to Exception Level 3 in the Secure World.</li>
</ul>
<hr />
    </article>
  </body>
</html>
