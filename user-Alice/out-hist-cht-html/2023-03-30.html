<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>body {
  max-width: 980px;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable,
.markdown-body .highlighttable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr,
.markdown-body .highlighttable {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite,
.markdown-body .highlighttable pre,
.markdown-body .highlighttable div.highlight {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td,
.markdown-body .highlighttable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  border-radius: 3px;
}

.markdown-body code:not(.highlight):not(.codehilite), .markdown-body samp {
  background-color: rgba(0,0,0,0.04);
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite,
.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
}

.markdown-body .codehilite,
.markdown-body .highlight,
.markdown-body pre {
  border-radius: 3px;
}

.markdown-body :not(.highlight) > pre {
  background-color: #f7f7f7;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

.markdown-body diagram-div, .markdown-body div.uml-sequence-diagram, .markdown-body, div.uml-flowchart {
  overflow: auto;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js'></script><script>MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS", "output/NativeMML"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true,
    ignoreClass: ".*|",
    processClass: "arithmatex"
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false,
  messageStyle: 'none'
});
</script><style>/*GitHub*/
.highlight {background-color:#f7f7f7;color:#333333;}
.highlight .hll {background-color:#ffffcc;}
.highlight .c{color:#999988;font-style:italic}
.highlight .err{color:#a61717;background-color:#e3d2d2}
.highlight .k{font-weight:bold}
.highlight .o{font-weight:bold}
.highlight .cm{color:#999988;font-style:italic}
.highlight .cp{color:#999999;font-weight:bold}
.highlight .c1{color:#999988;font-style:italic}
.highlight .cs{color:#999999;font-weight:bold;font-style:italic}
.highlight .gd{color:#000000;background-color:#ffdddd}
.highlight .ge{font-style:italic}
.highlight .gr{color:#aa0000}
.highlight .gh{color:#999999}
.highlight .gi{color:#000000;background-color:#ddffdd}
.highlight .go{color:#888888}
.highlight .gp{color:#555555}
.highlight .gs{font-weight:bold}
.highlight .gu{color:#800080;font-weight:bold}
.highlight .gt{color:#aa0000}
.highlight .kc{font-weight:bold}
.highlight .kd{font-weight:bold}
.highlight .kn{font-weight:bold}
.highlight .kp{font-weight:bold}
.highlight .kr{font-weight:bold}
.highlight .kt{color:#445588;font-weight:bold}
.highlight .m{color:#009999}
.highlight .s{color:#dd1144}
.highlight .n{color:#333333}
.highlight .na{color:teal}
.highlight .nb{color:#0086b3}
.highlight .nc{color:#445588;font-weight:bold}
.highlight .no{color:teal}
.highlight .ni{color:purple}
.highlight .ne{color:#990000;font-weight:bold}
.highlight .nf{color:#990000;font-weight:bold}
.highlight .nn{color:#555555}
.highlight .nt{color:navy}
.highlight .nv{color:teal}
.highlight .ow{font-weight:bold}
.highlight .w{color:#bbbbbb}
.highlight .mf{color:#009999}
.highlight .mh{color:#009999}
.highlight .mi{color:#009999}
.highlight .mo{color:#009999}
.highlight .sb{color:#dd1144}
.highlight .sc{color:#dd1144}
.highlight .sd{color:#dd1144}
.highlight .s2{color:#dd1144}
.highlight .se{color:#dd1144}
.highlight .sh{color:#dd1144}
.highlight .si{color:#dd1144}
.highlight .sx{color:#dd1144}
.highlight .sr{color:#009926}
.highlight .s1{color:#dd1144}
.highlight .ss{color:#990073}
.highlight .bp{color:#999999}
.highlight .vc{color:teal}
.highlight .vg{color:teal}
.highlight .vi{color:teal}
.highlight .il{color:#009999}
.highlight .gc{color:#999;background-color:#EAF2F5}
</style><title>2023-03-30</title></head><body><article class="markdown-body"><h1>2023-03-30</h1>
<p>Created: 2023-11-08 12:40:14</p>
<h1>Chats</h1>
<ul>
<li>TrustZone.0329.md<ul>
<li><code>[09:30]</code> What are relationships of SPD, SPM and SMC? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:35]</code> What is Secure Monitor? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:38]</code> Is SPD an optional component? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:40]</code> Can I use SPD instead of SM? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:41]</code> Is normal world a secure parition? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:42]</code> Is secure world a secure partition? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:44]</code> Does boot loader only run in secure world, not in normal world? <code>(TrustZone.0329.md)</code></li>
<li><code>[21:56]</code> How to swtich secure world to normal world when booting? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
<li>OP-TEE.j721e.0330.md<ul>
<li><code>[10:19]</code> https://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-rt-jacinto7/08_04_00_03/exports/docs/linux/Foundational_Components_OPTEE.html?highlight=trusted <code>(OP-TEE.j721e.0330.md)</code></li>
<li><code>[10:20]</code> 3.10. OP-TEE ... ... <code>(OP-TEE.j721e.0330.md)</code></li>
<li><code>[10:23]</code> What is GP? <code>(OP-TEE.j721e.0330.md)</code></li>
<li><code>[10:24]</code> What is RPMB? <code>(OP-TEE.j721e.0330.md)</code></li>
<li><code>[10:26]</code> What is KEK? <code>(OP-TEE.j721e.0330.md)</code></li>
<li><code>[10:27]</code> Is a KEK unique for each device? <code>(OP-TEE.j721e.0330.md)</code></li>
</ul>
</li>
<li>OP-TEE.0327.md<ul>
<li><code>[14:54]</code> Does OP-TEE only exist in secure world? <code>(OP-TEE.0327.md)</code></li>
</ul>
</li>
<li>OP-TEE.Intel.0330.md<ul>
<li><code>[21:35]</code> https://www.intel.com/content/www/us/en/developer/topic-technology/open/op-tee/overview.html <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:38]</code> Skip To Main Content ... ... <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:39]</code> Overview ... ... <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:39]</code> What is Intel KGT? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:41]</code> What are difference and same between Intel KGT and Intel SGX? Please summarize them in a table? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:41]</code> Is Intel KGT compatible to TEE? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:42]</code> Intel KGT and Intel SGX. Which one is better? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:43]</code> Be data in memory enclaves must encrypted in Intel SGX? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:46]</code> How do I attack Intel SGX? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:47]</code> How are data encrypted in memory enclave in Intel SGX? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:49]</code> What are isolation methods of Intel KGT and Intel SGX? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:50]</code> Can Intel KGT host Intel SGX? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:50]</code> Can Intel SGX host Intel KGT? <code>(OP-TEE.Intel.0330.md)</code></li>
<li><code>[21:52]</code> Which isolation method is better? <code>(OP-TEE.Intel.0330.md)</code></li>
</ul>
</li>
</ul>
<hr />
<h1>Q &amp; A</h1>
<h2>TrustZone.0329.md</h2>
<p><strong>Question:</strong> What are relationships of SPD, SPM and SMC?</p>
<p><strong>Answer:</strong></p>
<p>The Secure Partition Manager (SPM), Secure Partition Dispatcher (SPD), and Secure Monitor Call (SMC) are related concepts in the context of ARM TrustZone technology, which provides a secure and isolated environment for sensitive applications and data. Here's a brief explanation of each concept and their relationships:</p>
<ol>
<li>
<p>Secure Monitor Call (SMC): SMC is a special instruction used to switch between the Secure and Non-Secure states in ARM TrustZone. When SMC is executed, the processor transitions to the Secure state, and the Secure Monitor (typically running at S-EL3) is responsible for handling the call. The Secure Monitor can then perform the requested operation or forward the request to a more specific component, such as the SPM or an SPD.</p>
</li>
<li>
<p>Secure Partition Manager (SPM): The SPM is responsible for managing Secure Partitions (SPs), which are isolated execution environments that host Trusted Applications (TAs) or other secure services. The SPM handles tasks such as creating, initializing, and terminating SPs, as well as managing access to secure resources. When the Non-Secure world needs to access a service provided by an SP, it can use the SMC instruction to request the SPM's assistance.</p>
</li>
<li>
<p>Secure Partition Dispatcher (SPD): The SPD is an optional component that facilitates communication between the Non-Secure world and the Secure world, particularly when using an SMC. The SPD can handle requests from the Non-Secure world, forward them to the appropriate SP, and return the results to the Non-Secure caller. In some implementations, the SPM and SPD can be combined into a single component.</p>
</li>
</ol>
<p>In summary, SMC is an instruction used to transition between Secure and Non-Secure states, while the SPM and SPD are components that manage Secure Partitions and facilitate communication between the two worlds. When an SMC is issued, the request is</p>
<hr />
<p><strong>Question:</strong> What is Secure Monitor?</p>
<p><strong>Answer:</strong></p>
<p>The Secure Monitor is a critical component of the ARM TrustZone security technology that acts as an intermediary between the Secure and Non-Secure worlds. It operates at the highest privilege level (S-EL3) within the Secure world, ensuring the integrity and confidentiality of the Secure environment.</p>
<p>The primary responsibilities of the Secure Monitor include:</p>
<ol>
<li>
<p>Handling transitions between Secure and Non-Secure states: When a Secure Monitor Call (SMC) instruction is executed by the Non-Secure world, the processor switches to the Secure state, and the Secure Monitor takes control to process the request. It can either perform the requested operation or forward the request to other components, such as the Secure Partition Manager (SPM) or a specific Secure Partition (SP).</p>
</li>
<li>
<p>Managing resources and access control: The Secure Monitor oversees access to secure system resources, such as memory regions, peripherals, and cryptographic keys, ensuring that only authorized Secure software components can access them.</p>
</li>
<li>
<p>Enforcing the security policy: The Secure Monitor is responsible for implementing and enforcing the overall security policy for the system. This includes defining the security boundaries between the Secure and Non-Secure worlds, as well as ensuring that the Secure world remains protected from potential attacks originating from the Non-Secure world.</p>
</li>
</ol>
<p>In essence, the Secure Monitor is a vital component of ARM TrustZone that provides a trusted execution environment for security-sensitive applications and data, while also managing the transitions and interactions between the Secure and Non-Secure worlds.</p>
<hr />
<p><strong>Question:</strong> Is SPD an optional component?</p>
<p><strong>Answer:</strong></p>
<p>Yes, the Secure Partition Dispatcher (SPD) is an optional component within the ARM TrustZone security architecture. The SPD is responsible for managing and scheduling the execution of Secure Partitions (SPs) in the Secure world. It is a more advanced way of handling Secure services compared to the traditional monolithic Secure Monitor, which directly handles Secure world requests.</p>
<p>Using SPD allows for a more modular and flexible approach to implementing Secure services. However, if your use case does not require the functionality provided by Secure Partitions, you can choose not to include the SPD in your system. In that case, you will rely on the Secure Monitor to handle Secure world requests directly or use a different mechanism for managing Secure services.</p>
<p>Ultimately, the choice of whether to include an SPD in your system depends on your specific security requirements and the desired level of flexibility and modularity in your Secure software stack.</p>
<hr />
<p><strong>Question:</strong> Can I use SPD instead of SM?</p>
<p><strong>Answer:</strong></p>
<p>Yes, you can use the Secure Partition Dispatcher (SPD) instead of the traditional Secure Monitor (SM) in your ARM TrustZone-enabled system. The SPD provides a more flexible and modular approach to managing Secure services by handling and scheduling the execution of Secure Partitions (SPs) in the Secure world.</p>
<p>When using the SPD, the responsibility for managing Secure services is shifted from the monolithic Secure Monitor to the individual Secure Partitions, which are isolated from each other and can be developed and updated independently.</p>
<p>However, keep in mind that this decision depends on your specific security requirements and the desired level of flexibility and modularity in your Secure software stack. If you choose to use the SPD, it will replace the SM as the primary mechanism for managing Secure services in your system.</p>
<hr />
<p><strong>Question:</strong> Is normal world a secure parition?</p>
<p><strong>Answer:</strong></p>
<p>No, the Normal World is not a Secure Partition. The Normal World and Secure World are separate execution environments in ARM TrustZone-enabled systems. The Secure World is designed for running security-sensitive code and handling sensitive data, whereas the Normal World is intended for running general-purpose applications and operating systems.</p>
<p>Secure Partitions (SPs) are isolated execution environments within the Secure World. These partitions allow the development and management of security services and Trusted Applications (TAs) independently from each other. They provide additional separation and isolation for sensitive code and data within the Secure World.</p>
<p>In contrast, the Normal World does not provide the same level of protection and isolation as the Secure World and its Secure Partitions, making it unsuitable for hosting security-critical components.</p>
<hr />
<p><strong>Question:</strong> Is secure world a secure partition?</p>
<p><strong>Answer:</strong></p>
<p>No, the Secure World is not a Secure Partition, but it contains Secure Partitions. The Secure World is a separate, protected execution environment enabled by ARM TrustZone technology, designed for running security-sensitive code and handling sensitive data.</p>
<p>Secure Partitions (SPs) are isolated execution environments within the Secure World. They provide additional separation and isolation for sensitive code and data, allowing the development and management of security services and Trusted Applications (TAs) independently from each other.</p>
<p>So, while the Secure World provides a protected environment, Secure Partitions offer even more granular isolation within the Secure World itself.</p>
<hr />
<p><strong>Question:</strong> Does boot loader only run in secure world, not in normal world?</p>
<p><strong>Answer:</strong></p>
<p>Bootloaders can run in both the Secure World and the Normal World, depending on the specific use case and platform. In a secure boot process, the initial bootloader stages run in the Secure World to ensure the integrity and authenticity of the system's firmware and subsequent software components.</p>
<p>Once the initial validation is complete, the bootloader may hand over control to the Normal World, allowing the operating system and applications to boot up and run.</p>
<p>However, in some cases, a bootloader may run entirely in the Normal World if the platform doesn't require secure boot or if the secure boot process is handled differently. Ultimately, whether the bootloader runs in the Secure World or the Normal World depends on the specific hardware, firmware, and security requirements of the system.</p>
<hr />
<p><strong>Question:</strong> How to swtich secure world to normal world when booting?</p>
<p><strong>Answer:</strong></p>
<p>When booting a system with TrustZone technology, the processor starts in the Secure World by default. To switch from the Secure World to the Normal World during the boot process, you can follow these general steps:</p>
<ol>
<li>
<p><strong>Initialize the Secure World</strong>: In the Secure World, the secure bootloader initializes the necessary hardware components, sets up the secure environment, and configures the memory and peripherals access permissions.</p>
</li>
<li>
<p><strong>Validate and load the Normal World software</strong>: The secure bootloader validates the Normal World software, such as the operating system or bootloader, using cryptographic techniques like digital signatures. Once validation is successful, it loads the software into the memory designated for the Normal World.</p>
</li>
<li>
<p><strong>Configure the processor</strong>: Before switching to the Normal World, the secure bootloader sets up the processor's state, registers, and exception levels. It also configures the system registers, such as the Secure Configuration Register (SCR) and the Monitor Vector Base Address Register (MVBAR), to define the behavior of the system when switching between the Secure World and the Normal World.</p>
</li>
<li>
<p><strong>Switch to the Normal World</strong>: The secure bootloader performs a Secure Monitor Call (SMC) or an Exception Return (ERET) to switch the processor from the Secure World to the Normal World. This transition is facilitated by the Secure Monitor, which is responsible for handling the state switch between the two worlds.</p>
</li>
</ol>
<p>After these steps, the processor enters the Normal World, and the Normal World software, such as the operating system or bootloader, starts executing.</p>
<p>Please note that these steps are a general outline and may vary depending on the specific platform, hardware, and firmware implementations.</p>
<hr />
<h2>OP-TEE.j721e.0330.md</h2>
<p><strong>Question:</strong> https://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-rt-jacinto7/08_04_00_03/exports/docs/linux/Foundational_Components_OPTEE.html?highlight=trusted</p>
<p><strong>Answer:</strong></p>
<p>I'm sorry, but as an AI language model, I cannot browse the web or access external links. However, I can try to help answer any questions you may have about the Texas Instruments Jacinto 7 Processor or OP-TEE (Open Portable Trusted Execution Environment).</p>
<p>The Texas Instruments Jacinto 7 Processor is an automotive processor designed for advanced driver assistance systems (ADAS) and in-vehicle infotainment (IVI) applications. It is a System-on-Chip (SoC) solution that integrates multiple processing cores, including Arm Cortex-A72 and Cortex-R5F cores, along with a TI C71x DSP and multiple accelerators for computer vision and deep learning tasks.</p>
<p>OP-TEE (Open Portable Trusted Execution Environment) is an open-source implementation of the TEE (Trusted Execution Environment) for Arm Cortex-A based processors. It provides a secure environment for executing trusted applications isolated from the normal operating system, ensuring confidentiality and integrity of sensitive data and applications.</p>
<p>If you have any specific questions about these topics, feel free to ask, and I'll do my best to help.</p>
<hr />
<p><strong>Question:</strong></p>
<pre><code>3.10. OP-TEE
Overview

OP-TEE is a Trusted Execution Environment (TEE) designed as companion to a non-secure Linux kernel running on Arm; Cortex-A cores using the TrustZone technology. OP-TEE binary is compiled with U-Boot and following are the instructions for compiling and booting it.

Furthur information about it can be found at: https://optee.readthedocs.io/en/latest/general/about.html

Official OP-TEE documentation here.

Getting the OP-TEE Source Code

$ git clone https://github.com/OP-TEE/optee_os.git
Getting Security Dev Tool

$ git clone https://git.ti.com/git/security-development-tools/core-secdev-k3.git -b master
$ export TI_SECURE_DEV_PKG=`pwd`/core-secdev-k3
Building OP-TEE

On GP
$ make CROSS_COMPILE64=aarch64-linux-gnu- PLATFORM=k3-j721e CFG_ARM64_core=y
With debug parameters
$ make CROSS_COMPILE64=aarch64-none-linux-gnu- PLATFORM=k3-j721e CFG_ARM64_core=y CFG_TEE_CORE_LOG_LEVEL=2 CFG_TEE_CORE_DEBUG=y
Sign image for HS
$ {TI_SECURE_DEV_PKG}/scripts/secure-binary-image.sh ./out/arm-plat-k3/core/tee-pager_v2.bin ./out/arm-plat-k3/core/tee-pager_v2.bin.signed
Secure Storage with RPMB (For HS)

OP-TEE provides secure storage functionality. TI SoCs with HS configuration have a KEK embedded in them that is programmed across OP-TEE instances that are distributed in a derived manner. Each HS device has its own signing key which is different from other HS devices.

For enabling RPMB support along with secure storage, additional flags need to be passed to the build instructions. The information for the flags can be found here. https://optee.readthedocs.io/en/latest/architecture/secure_storage.html

There is a hybrid mode in which both the flags i.e CFG_REE_FS=y and CFG_RPMB_FS=y are enabled. This mode stores the state of the Secure Storage directory in RPMB partition to check for the integrity of the data present in it. It is the recommended way.

E.g. For enabling hybrid mode of RPMB along with REE_FS

$ make CROSS_COMPILE64=aarch64-linux-gnu- PLATFORM=k3-j721e CFG_ARM64_core=y CFG_REE_FS=y CFG_RPMB_FS=y
$ {TI_SECURE_DEV_PKG}/scripts/secure-binary-image.sh ./out/arm-plat-k3/core/tee-pager_v2.bin ./out/arm-plat-k3/core/tee-pager_v2.bin.signed
OPTEE-client also needs to be updated to enable the use of real emmc instead of the virtual emmc that is enabled by default

Getting OP-TEE Client source code

$ git clone https://github.com/OP-TEE/optee_client
Building OP-TEE Client with RPMB support

$ make CROSS_COMPILE="aarch64-linux-gnu-" PLATFORM=k3 CFG_TEE_SUPP_LOG_LEVEL=2 RPMB_EMU=0 CFG_ARM64_core=y
Now update optee-client binary and libraries on your SD card with the generated ones in out/export/usr folder

Building u-boot with OP-TEE os

If building for an HS device, tee-pager_v2.bin must be signed before it is packaged in tispl.bin. To sign the binary, the script secure-binary-image.sh is called as shown above with the path to the newly built binary: tee-pager_v2.bin (the first argument) and with the expected output binary path and name: tee-pager_v2.bin.signed (the second argument). Once the binary is signed, continue with the HS boot instructions found here: Build U-Boot.

Expected binary output

Generated binary: tee-pager_v2.bin
Binary saved saved in: &lt;path-to-optee&gt;/out/arm-plat-k3/core
Integrate binary output into U-boot

Go to u-boot folder &lt;path-to-u-boot&gt;
Re-build U-boot with A72/A53 instructions found under: Build U-Boot, but with the TEE parameter pointing to the newly built tee-pager_v2.bin. i.e. TEE=&lt;path-to-optee&gt;/out/arm-plat-k3/core/tee-pager_v2.bin
Note

tee-pager_v2.bin may be called bl32.bin in other documentation.

© Copyright 1995-2021, Texas Instruments Incorporated. All rights reserved.
Trademarks | Privacy policy | Terms of use | Terms of sale
</code></pre>
<p><strong>Answer:</strong></p>
<p>Based on the information provided, the instructions explain how to build and integrate OP-TEE with the Jacinto 7 Processor for both GP and HS devices. Here's a summary of the steps:</p>
<ol>
<li><strong>Get the OP-TEE Source Code</strong>: Clone the OP-TEE source code from GitHub.</li>
<li><strong>Get the Security Dev Tool</strong>: Clone the TI Security Development Tools repository and set the TI_SECURE_DEV_PKG environment variable.</li>
<li><strong>Build OP-TEE</strong>: Build the OP-TEE binary for the k3-j721e platform using the provided commands.</li>
<li><strong>Sign the image for HS</strong>: If you are building for an HS device, sign the tee-pager_v2.bin using the provided script.</li>
<li><strong>Enable RPMB support and secure storage</strong>: To enable RPMB support along with secure storage, additional flags need to be passed to the build instructions. You can enable the hybrid mode of RPMB along with REE_FS by following the provided example.</li>
<li><strong>Get and build the OP-TEE Client with RPMB support</strong>: Clone the OP-TEE client source code and build it with the appropriate flags. Then, update the optee-client binary and libraries on your SD card with the generated ones in the out/export/usr folder.</li>
<li><strong>Build U-Boot with OP-TEE OS</strong>: Follow the instructions to build U-Boot with the TEE parameter pointing to the newly built tee-pager_v2.bin.</li>
<li><strong>Integrate binary output into U-Boot</strong>: Re-build U-Boot with A72/A53 instructions found under "Build U-Boot," but with the TEE parameter pointing to the newly built tee-pager_v2.bin.</li>
</ol>
<p>Remember that tee-pager_v2.bin may be referred to as bl32.bin in other documentation.</p>
<p>For additional information, you can refer to the official OP-TEE documentation at https://optee.readthedocs.io/en/latest/.</p>
<p>Please note that this is a summary of the instructions provided, and you should follow the detailed steps in the original text to build and integrate OP-TEE successfully.</p>
<hr />
<p><strong>Question:</strong> What is GP?</p>
<p><strong>Answer:</strong></p>
<p>In the context of the instructions provided, "GP" refers to "General Purpose" devices. When discussing Texas Instruments (TI) processors, the term is used to differentiate between two types of devices: General Purpose (GP) and High Security (HS).</p>
<p>General Purpose (GP) devices are designed for a broad range of applications and use cases. They typically do not include the same level of security features as High Security (HS) devices.</p>
<p>High Security (HS) devices, on the other hand, are designed with additional security features and are intended for use in applications that require a higher level of security, such as automotive systems, industrial control systems, or other safety-critical applications.</p>
<p>When building OP-TEE for a Jacinto 7 Processor, you may need to follow different steps depending on whether you are targeting a General Purpose (GP) or High Security (HS) device. For example, the instructions provided mention signing the tee-pager_v2.bin when building for an HS device, which is not required for a GP device.</p>
<hr />
<p><strong>Question:</strong> What is RPMB?</p>
<p><strong>Answer:</strong></p>
<p>RPMB stands for Replay Protected Memory Block. It is a security feature provided in eMMC (embedded Multi-Media Controller) and UFS (Universal Flash Storage) devices. RPMB is designed to offer a secure, tamper-resistant storage area for sensitive data and to protect against replay attacks.</p>
<p>In the context of OP-TEE and secure storage, RPMB is used to store sensitive information in a protected environment, ensuring data confidentiality and integrity. It can be used in combination with other secure storage options, such as REE_FS (Rich Execution Environment File System), to create a hybrid storage solution. The hybrid mode uses the Secure Storage directory in the RPMB partition to check for the integrity of the data present in it, providing an added layer of security.</p>
<p>When building OP-TEE with RPMB support, you need to pass additional flags to the build instructions, as mentioned in the provided steps. This enables the use of real eMMC storage instead of the default virtual eMMC storage.</p>
<hr />
<p><strong>Question:</strong> What is KEK?</p>
<p><strong>Answer:</strong></p>
<p>KEK stands for Key Encryption Key. In cryptography and secure systems, a KEK is used to securely transmit and store encryption keys. The main purpose of a KEK is to protect the actual encryption keys (also known as data encryption keys or DEKs) that are used to encrypt and decrypt sensitive data.</p>
<p>The KEK is used to encrypt the DEKs before they are stored or transmitted, and only authorized systems with the correct KEK can decrypt the DEKs to access the actual encryption keys. This adds an additional layer of security, ensuring that even if the encrypted DEKs are intercepted or compromised, an attacker would still need the KEK to decrypt and use them.</p>
<p>In the context of TI SoCs (System-on-Chip) with High Security (HS) configuration, a KEK is embedded in the devices and programmed across OP-TEE instances. Each HS device has its own unique signing key, which is different from other HS devices. This further enhances the security of the overall system, making it more difficult for attackers to compromise the sensitive data stored within.</p>
<hr />
<p><strong>Question:</strong> Is a KEK unique for each device?</p>
<p><strong>Answer:</strong></p>
<p>In the context of Texas Instruments (TI) System-on-Chip (SoC) devices with High Security (HS) configuration, each device does have a unique KEK (Key Encryption Key). This means that each HS device has its own signing key, which is different from other HS devices. This approach enhances the security of the overall system, making it more difficult for attackers to compromise the sensitive data stored within.</p>
<p>However, it's essential to understand that the uniqueness of a KEK depends on the specific implementation and the security requirements of the system. In some cases, KEKs may be shared among multiple devices or systems to enable secure communication between them.</p>
<p>In summary, while the KEKs in TI SoCs with HS configuration are unique for each device, the uniqueness of KEKs in other systems may vary depending on the specific implementation and security requirements.</p>
<hr />
<h2>OP-TEE.0327.md</h2>
<p><strong>Question:</strong> Does OP-TEE only exist in secure world?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE is a Trusted Execution Environment (TEE) that leverages Arm TrustZone technology, which provides hardware-based isolation between the normal world and the secure world. OP-TEE consists of components that exist in both the normal world and the secure world.</p>
<ol>
<li>
<p>Secure world components:</p>
</li>
<li>
<p>Secure kernel: The OP-TEE secure kernel resides in the secure world and manages trusted applications, secure memory, and communication between the normal world and the secure world.</p>
</li>
<li>
<p>Trusted applications: These are secure services or applications that run in the secure world and provide functionality that requires a higher level of security and isolation.</p>
</li>
<li>
<p>Normal world components:</p>
</li>
<li>
<p>TEE Client API: This is a library that normal world applications use to communicate with the secure world. It provides an interface for opening sessions, invoking commands, and managing shared memory with trusted applications.</p>
</li>
<li>TEE supplicant: The TEE supplicant is a user-space daemon in the normal world that handles certain requests from the secure world, such as loading trusted applications, filesystem operations, and cryptographic operations that involve the normal world's resources.</li>
</ol>
<p>Both the secure world and normal world components of OP-TEE work together to provide a secure and isolated environment for trusted applications, as well as a communication channel between normal world applications and the secure world.</p>
<p>In summary, OP-TEE does not only exist in the secure world. It consists of components in both the normal world and the secure world to create a comprehensive TEE solution that leverages Arm TrustZone technology.</p>
<hr />
<h2>OP-TEE.Intel.0330.md</h2>
<p><strong>Question:</strong> https://www.intel.com/content/www/us/en/developer/topic-technology/open/op-tee/overview.html</p>
<p><strong>Answer:</strong></p>
<p>The link you provided leads to the Intel website's page about Open-TEE, which is an open-source Trusted Execution Environment (TEE) developed by Intel. Open-TEE is designed to provide a secure and isolated environment for running trusted applications on Intel hardware platforms.</p>
<p>A TEE is a secure area of a computer system that is isolated from the main operating system and can provide a trusted execution environment for sensitive operations. TEEs are commonly used for tasks such as secure boot, secure storage, and secure authentication.</p>
<p>Open-TEE is based on the Trusted Computing Group's (TCG) Trusted Platform Module (TPM) specification and provides a standardized interface for interacting with the TEE. Open-TEE is designed to be platform-agnostic and can be used on a wide range of Intel hardware platforms.</p>
<p>Open-TEE is open-source software and is released under the Apache 2.0 license. The source code is available on GitHub, and developers can contribute to the project and build their own TEE solutions using the Open-TEE codebase.</p>
<p>Overall, Open-TEE is a useful tool for developers who need to build secure and trusted applications on Intel hardware platforms. By providing a standardized interface for interacting with the TEE, Open-TEE simplifies the development process and makes it easier to create secure applications that can be trusted to protect sensitive data and operations.</p>
<hr />
<p><strong>Question:</strong></p>
<pre><code>Skip To Main Content
Intel logo - Return to the home page
PRODUCTS
SUPPORT
SOLUTIONS
DEVELOPERS
PARTNERS
Sign In USA (ENGLISH)
Search
&lt;
Search Intel.com
Developers
Topics &amp; Technologies
Open Ecosystem
Projects
OP-TEE* for Intel® Architecture
OP-TEE* for Intel® Architecture
Overview    Solution: Two-Virtual Machines (VM)
Overview
This open source trusted execution environment implementation is originally based on Arm TrustZone* and maintained by Linaro*.

OP-TEE* for Intel® Architecture is the hardware virtualization-based OP-TEE solution for x86 systems from Intel. It has a fully compatible design and maximum reuse of OP-TEE. It's a full environment including an operating system, services, and APIs that consist of the following:

Operating system and kernel that:
Supports virtual address space isolation and privilege isolation
Works in event-driven model by request from the Rich Execution Environment (REE)
Drivers for a Linux* kernel
Libraries for client and trusted applications
Hypervisor that uses Intel® Kernel Guard Technology (Intel® KGT), which Intel open sourced in 2015.
Intel KGT
Solution: Two-Virtual Machines (VM)

Original equipment manufacturers (OEM) can develop their own rich operating system client applications and corresponding OP-TEE for Intel Architecture applications and services with the following setup:

One VM runs the OP-TEE operating system and trusted applications. The other VM runs a rich operating system.
Trusted applications are isolated with Intel® Virtualization Technology (Intel® VT) for IA-32, Intel® 64 and Intel® Architecture (Intel® VT-x).
An x86 OP-TEE driver and virtual machine monitor (VMM) from Intel.
A hypervisor (like Intel KGT) creates the two VMs for the rich and OP-TEE operating systems.




Report an Issue

Contact Us



a comparison of a rich execution environment to an op tee execution environment structures
Figure 1. Stack of OP-TEE for Intel architecture

open at intel logo
Explore the world of Intel’s open platform projects, contributions, community initiatives, and more at open.intel.com.


Company Overview Contact Intel Newsroom Investors Careers Corporate Responsibility Diversity &amp; Inclusion Public Policy
© Intel Corporation Terms of Use *Trademarks Cookies Privacy Supply Chain Transparency Site Map  Recycling
Intel technologies may require enabled hardware, software or service activation. // No product or component can be absolutely secure. // Your costs and results may vary. // Performance varies by use, configuration and other factors. // See our complete legal Notices and Disclaimers. // Intel is committed to respecting human rights and avoiding complicity in human rights abuses. See Intel’s Global Human Rights Principles. Intel’s products and software are intended only to be used in applications that do not cause or contribute to a violation of an internationally recognized human right.

Intel Footer Logo
</code></pre>
<p><strong>Answer:</strong></p>
<p>This is the same content that I provided a response to in my previous message. If you have any further questions or concerns, please let me know.</p>
<hr />
<p><strong>Question:</strong></p>
<pre><code>Overview
This open source trusted execution environment implementation is originally based on Arm TrustZone* and maintained by Linaro*.

OP-TEE* for Intel® Architecture is the hardware virtualization-based OP-TEE solution for x86 systems from Intel. It has a fully compatible design and maximum reuse of OP-TEE. It's a full environment including an operating system, services, and APIs that consist of the following:

Operating system and kernel that:
Supports virtual address space isolation and privilege isolation
Works in event-driven model by request from the Rich Execution Environment (REE)
Drivers for a Linux* kernel
Libraries for client and trusted applications
Hypervisor that uses Intel® Kernel Guard Technology (Intel® KGT), which Intel open sourced in 2015.
Intel KGT
Solution: Two-Virtual Machines (VM)

Original equipment manufacturers (OEM) can develop their own rich operating system client applications and corresponding OP-TEE for Intel Architecture applications and services with the following setup:

One VM runs the OP-TEE operating system and trusted applications. The other VM runs a rich operating system.
Trusted applications are isolated with Intel® Virtualization Technology (Intel® VT) for IA-32, Intel® 64 and Intel® Architecture (Intel® VT-x).
An x86 OP-TEE driver and virtual machine monitor (VMM) from Intel.
A hypervisor (like Intel KGT) creates the two VMs for the rich and OP-TEE operating systems.




Report an Issue

Contact Us



a comparison of a rich execution environment to an op tee execution environment structures
Figure 1. Stack of OP-TEE for Intel architecture
</code></pre>
<p><strong>Answer:</strong></p>
<p>As previously mentioned, OP-TEE for Intel Architecture is an open-source trusted execution environment that is based on Arm TrustZone and is maintained by Linaro. It is designed for x86 systems from Intel and includes an operating system, services, and APIs. The operating system and kernel support virtual address space isolation and privilege isolation and work in an event-driven model by request from the Rich Execution Environment (REE). Drivers for a Linux kernel and libraries for client and trusted applications are also included.</p>
<p>The OP-TEE solution for Intel Architecture uses a hypervisor that utilizes Intel Kernel Guard Technology (Intel KGT), which is an open-source hypervisor from Intel that was released in 2015. OEMs can develop their own rich operating system client applications and corresponding OP-TEE for Intel Architecture applications and services with the setup described in the solution: two virtual machines (VM).</p>
<p>One VM runs the OP-TEE operating system and trusted applications while the other runs a rich operating system. Trusted applications are isolated using Intel Virtualization Technology (Intel VT) for IA-32, Intel 64, and Intel Architecture (Intel VT-x). An x86 OP-TEE driver and virtual machine monitor (VMM) from Intel are also included. The hypervisor, such as Intel KGT, creates the two VMs for the rich and OP-TEE operating systems.</p>
<p>Overall, OP-TEE for Intel Architecture provides a secure and isolated environment for running trusted applications on x86 systems from Intel. It is a useful tool for developers who need to build secure and trusted applications on Intel hardware platforms.</p>
<hr />
<p><strong>Question:</strong> What is Intel KGT?</p>
<p><strong>Answer:</strong></p>
<p>Intel Kernel Guard Technology (KGT) is an open-source hypervisor that was released by Intel in 2015. It is designed to provide hardware-assisted isolation and protection for critical system resources in a virtualized environment.</p>
<p>Intel KGT is built on top of the Intel Virtualization Technology (Intel VT) hardware and provides a lightweight and efficient hypervisor that can be used to run untrusted code in a protected environment. It allows the creation of isolated virtual machines that can securely execute guest operating systems and applications, while protecting the host operating system and other virtual machines from potential threats.</p>
<p>One of the key features of Intel KGT is its ability to create virtual machines (VMs) that are very small in size and consume minimal system resources. This makes it well-suited for use cases where a lightweight hypervisor is needed, such as in embedded systems or IoT devices.</p>
<p>Overall, Intel KGT is a useful tool for developers who need to build secure and efficient virtualized environments on Intel hardware platforms. As an open-source project, it is also available for developers to customize and contribute to, making it a flexible and versatile option for a wide range of applications.</p>
<hr />
<p><strong>Question:</strong> What are difference and same between Intel KGT and Intel SGX? Please summarize them in a table?</p>
<p><strong>Answer:</strong></p>
<p>Here's a summary table that highlights some of the differences and similarities between Intel Kernel Guard Technology (KGT) and Intel Software Guard Extensions (SGX):</p>
<p>| Feature | Intel KGT | Intel SGX |
| --- | --- | --- |
| Purpose | Lightweight hypervisor for virtualization | Hardware-based security for protecting code and data |
| Protection | Protects critical system resources in a virtualized environment | Protects code and data in memory from other processes |
| Execution | Runs untrusted code in a protected environment | Executes trusted code in a protected environment |
| Hardware | Built on Intel Virtualization Technology (Intel VT) hardware | Built on special CPU instructions and memory protections |
| Use cases | Embedded systems, IoT devices | Cloud computing, data center security, edge computing |
| Deployment | Deploys on existing systems without additional hardware | Requires hardware support for Intel SGX |
| Isolation | Provides hardware-assisted isolation between virtual machines | Provides hardware-assisted isolation between trusted and untrusted code |
| Software | Open-source software | Closed-source software |
| API | Provides a set of APIs for interacting with the hypervisor | Provides a set of APIs for creating and managing secure enclaves |
| Security | Designed to protect critical system resources and provide a secure virtual environment | Designed to protect code and data from unauthorized access and tampering |</p>
<p>While Intel KGT and Intel SGX both provide hardware-assisted security features, they serve different purposes and are used in different use cases. Intel KGT is a lightweight hypervisor that provides hardware-assisted isolation for virtual machines, while Intel SGX is a hardware-based security feature that protects code and data from unauthorized access and tampering. Additionally, Intel KGT is open-source software that can be deployed on existing systems without additional hardware, while Intel SGX requires hardware support for SGX-enabled processors.</p>
<hr />
<p><strong>Question:</strong> Is Intel KGT compatible to TEE?</p>
<p><strong>Answer:</strong></p>
<p>Yes, Intel Kernel Guard Technology (KGT) is compatible with Trusted Execution Environments (TEEs). In fact, one of the use cases for Intel KGT is to provide a lightweight and efficient hypervisor for running a TEE in a virtualized environment.</p>
<p>TEEs are designed to provide a secure and isolated environment for running trusted applications, and they are commonly used for tasks such as secure boot, secure storage, and secure authentication. By running a TEE in a virtualized environment with Intel KGT, developers can create a secure and efficient platform for running trusted applications that is protected from potential threats.</p>
<p>Overall, Intel KGT is a useful tool for developers who need to build secure and trusted virtualized environments, including those that utilize TEEs. Its hardware-assisted isolation capabilities, combined with its lightweight design, make it well-suited for use cases where a secure and efficient virtual environment is needed.</p>
<hr />
<p><strong>Question:</strong> Intel KGT and Intel SGX. Which one is better?</p>
<p><strong>Answer:</strong></p>
<p>It's difficult to say which technology is "better" between Intel Kernel Guard Technology (KGT) and Intel Software Guard Extensions (SGX), as they serve different purposes and are used in different contexts.</p>
<p>Intel KGT is a lightweight hypervisor that provides hardware-assisted isolation for virtual machines. It is designed to protect critical system resources in a virtualized environment and is well-suited for use cases such as embedded systems or IoT devices. Its open-source software and ability to deploy on existing systems without additional hardware make it a flexible and versatile option for building secure and efficient virtualized environments.</p>
<p>On the other hand, Intel SGX is a hardware-based security feature that provides protection for code and data in memory from other processes. It is designed to protect against a wide range of threats, including unauthorized access, tampering, and reverse engineering. Intel SGX is well-suited for use cases such as cloud computing, data center security, and edge computing.</p>
<p>Ultimately, the choice between Intel KGT and Intel SGX depends on the specific use case and the type of security requirements that need to be met. In some cases, both technologies may even be used together, as they can complement each other to provide a more comprehensive security solution.</p>
<hr />
<p><strong>Question:</strong> Be data in memory enclaves must encrypted in Intel SGX?</p>
<p><strong>Answer:</strong></p>
<p>Yes, data in memory enclaves must be encrypted in Intel Software Guard Extensions (SGX) to provide protection against unauthorized access or tampering.</p>
<p>SGX provides a secure enclave within a process that is isolated from the rest of the process and the system. The enclave is created by the process and is encrypted using keys that are generated by the CPU. Data within the enclave is also encrypted using these keys, which means that even if an attacker gains access to the memory of the process, they cannot access or modify the data within the enclave.</p>
<p>In addition to encryption, SGX also provides other security features such as sealing and attestation. Sealing allows data to be protected and securely transported between enclaves, while attestation verifies the identity and integrity of the enclave to ensure that it has not been tampered with.</p>
<p>Overall, encryption is a critical component of SGX's security features and is essential for protecting data in memory enclaves from unauthorized access or tampering.</p>
<hr />
<p><strong>Question:</strong> How do I attack Intel SGX?</p>
<p><strong>Answer:</strong></p>
<p>Attacking Intel Software Guard Extensions (SGX) is a complex task that requires advanced knowledge of the technology and the underlying hardware. While it is not impossible to attack SGX, doing so requires a significant amount of effort and resources. Here are some possible attack vectors that have been identified by security researchers:</p>
<ol>
<li>
<p>Side-channel attacks: Side-channel attacks involve measuring physical characteristics of a system, such as power consumption or electromagnetic radiation, to extract sensitive information. SGX is vulnerable to some types of side-channel attacks, such as cache timing attacks and power analysis attacks.</p>
</li>
<li>
<p>Memory attacks: Memory attacks involve exploiting vulnerabilities in the memory management of a system to gain access to protected data. SGX is designed to protect against memory attacks, but there have been some vulnerabilities identified in the past, such as the Foreshadow attack.</p>
</li>
<li>
<p>Malware attacks: Malware attacks involve infecting a system with malicious software that can bypass SGX protections or steal sensitive data from within the enclave. SGX is not designed to protect against malware attacks, so it is important to ensure that the system is secure and free from malware.</p>
</li>
<li>
<p>Physical attacks: Physical attacks involve physically tampering with the system to gain access to sensitive information. This type of attack is difficult to execute and requires physical access to the system.</p>
</li>
</ol>
<p>It is worth noting that Intel is continually improving SGX and addressing potential vulnerabilities as they are discovered. Regular software updates and security patches should be installed to ensure that the system is protected against known vulnerabilities. Additionally, best practices for secure coding, system hardening, and access control should be followed to reduce the risk of successful attacks.</p>
<hr />
<p><strong>Question:</strong> How are data encrypted in memory enclave in Intel SGX?</p>
<p><strong>Answer:</strong></p>
<p>Data in memory enclaves in Intel Software Guard Extensions (SGX) is encrypted using a combination of hardware and software encryption mechanisms.</p>
<p>When an enclave is created, the CPU generates a unique key pair for that enclave, consisting of a public key and a private key. The private key is stored securely within the CPU and cannot be accessed or modified by software outside of the enclave. The public key is used to establish a secure channel between the enclave and the software outside of the enclave.</p>
<p>Once the secure channel is established, software within the enclave can use standard cryptographic algorithms, such as AES or RSA, to encrypt and decrypt data as needed. The CPU provides hardware support for these cryptographic algorithms, which means that they can be executed within the enclave with minimal performance overhead.</p>
<p>To protect against potential side-channel attacks, SGX also implements various security features, such as randomizing memory locations, encrypting the entire memory space of the enclave, and using secure hashing algorithms.</p>
<p>Overall, the combination of hardware and software encryption mechanisms, along with additional security features, provides strong protection for data in memory enclaves in SGX. However, it is still important to follow best practices for secure coding and system hardening to ensure that the system is protected against potential attacks.</p>
<hr />
<p><strong>Question:</strong> What are isolation methods of Intel KGT and Intel SGX?</p>
<p><strong>Answer:</strong></p>
<p>Both Intel Kernel Guard Technology (KGT) and Intel Software Guard Extensions (SGX) provide isolation mechanisms to protect against unauthorized access and tampering. However, the specific methods of isolation are different for each technology.</p>
<p>Intel KGT provides isolation through virtualization technology, using a hypervisor to create virtual machines (VMs) that are isolated from each other and the host system. The hypervisor uses Intel VT hardware to enforce isolation between the VMs, ensuring that each VM has its own isolated memory space and access to only the resources that have been explicitly granted. This virtualization-based isolation is similar to the isolation provided by other hypervisors such as VMware or Hyper-V.</p>
<p>On the other hand, Intel SGX provides isolation through secure enclaves, which are isolated regions of memory within a process that are protected from access by other processes, the operating system, and even the CPU itself. The memory within an enclave is encrypted and can only be accessed by code that has been trusted and signed by the enclave owner. The enclave also includes hardware protections against tampering, such as sealing and attestation, which further enhance its security.</p>
<p>Overall, both Intel KGT and Intel SGX provide effective isolation mechanisms, but they are used in different contexts and have different strengths and weaknesses. Intel KGT is well-suited for creating secure and isolated virtualized environments, while Intel SGX is designed to protect against a wide range of attacks and provide strong protection for sensitive data and code.</p>
<hr />
<p><strong>Question:</strong> Can Intel KGT host Intel SGX?</p>
<p><strong>Answer:</strong></p>
<p>Yes, Intel Kernel Guard Technology (KGT) can host Intel Software Guard Extensions (SGX) enclaves within a virtual machine (VM). This allows SGX to be used in a virtualized environment while maintaining the security and isolation benefits of both technologies.</p>
<p>To host SGX enclaves within a VM using KGT, the hypervisor creates a VM that is configured with the necessary hardware resources to support SGX, such as Intel VT-x and Intel TXT. Within the VM, the operating system and software can then create and manage SGX enclaves as they would on a non-virtualized system.</p>
<p>However, it is worth noting that hosting SGX within a VM can impact its performance and security. The additional layer of virtualization can introduce overhead and potential vulnerabilities, and it may not be suitable for all use cases. Therefore, it is important to carefully evaluate the security and performance implications of using SGX within a virtualized environment and implement appropriate security measures to mitigate any potential risks.</p>
<hr />
<p><strong>Question:</strong> Can Intel SGX host Intel KGT?</p>
<p><strong>Answer:</strong></p>
<p>No, Intel Software Guard Extensions (SGX) cannot host Intel Kernel Guard Technology (KGT).</p>
<p>SGX is a technology that provides secure enclaves within a process to protect code and data from unauthorized access or tampering. The purpose of SGX is to provide a secure execution environment within a process, while KGT is a lightweight hypervisor that provides isolation and protection for virtual machines.</p>
<p>While SGX can be used in a virtualized environment, such as within a virtual machine created by a hypervisor like KGT, it cannot host or provide the functionality of KGT itself. KGT is designed to provide hardware-assisted isolation for virtual machines, while SGX is designed to protect code and data within a process.</p>
<p>Overall, SGX and KGT serve different purposes and are used in different contexts. SGX is well-suited for protecting sensitive code and data within a process, while KGT is well-suited for creating secure and isolated virtualized environments.</p>
<hr />
<p><strong>Question:</strong> Which isolation method is better?</p>
<p><strong>Answer:</strong></p>
<p>It is difficult to say which isolation method is better between Intel Kernel Guard Technology (KGT) and Intel Software Guard Extensions (SGX), as they serve different purposes and are used in different contexts.</p>
<p>KGT provides isolation through virtualization technology, using a hypervisor to create virtual machines (VMs) that are isolated from each other and the host system. This virtualization-based isolation is well-suited for creating secure and isolated virtualized environments, such as in embedded systems or IoT devices.</p>
<p>SGX, on the other hand, provides isolation through secure enclaves, which are isolated regions of memory within a process that are protected from access by other processes, the operating system, and even the CPU itself. SGX is designed to protect against a wide range of attacks and provide strong protection for sensitive data and code, making it well-suited for use cases such as cloud computing, data center security, and edge computing.</p>
<p>Overall, the choice between KGT and SGX depends on the specific use case and the type of security requirements that need to be met. Both technologies provide effective isolation mechanisms, but they are used in different contexts and have different strengths and weaknesses. In some cases, both technologies may even be used together, as they can complement each other to provide a more comprehensive security solution.</p>
<hr /></article></body></html>