
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="github.css" type="text/css">
    <title>2023-03-29</title>    
  </head>
  <body>
    <article class="markdown-body">
        <!-- Markdown-generated HTML content here -->
        <h1>2023-03-29</h1>
<p>Created: 2023-04-26 23:54:58</p>
<h1>Questions</h1>
<ul>
<li>Normal World &amp; Secure World <code>(230329.TrustZone.txt)</code><ul>
<li><code>[08:51]</code> Can Normal world and Secure World run at the same time in ARM? <code>(TrustZone.0329.md)</code></li>
<li><code>[08:52]</code> But can Normal world and Secure World run at the same time in multi processors of ARM? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
<li>Memory <code>(230329.TrustZone.txt)</code><ul>
<li><code>[08:53]</code> How to define memory size of secure world? <code>(TrustZone.0329.md)</code></li>
<li><code>[08:53]</code> Can memory size of secure world be changed? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
<li>SM &amp; SPM &amp; SPD <code>(230329.TrustZone.txt)</code><ul>
<li><code>[08:55]</code> What is SMC? <code>(TrustZone.0329.md)</code></li>
<li><code>[08:57]</code> Can secure world request a service in normal world via SMC? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:00]</code> What is SPD? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:03]</code> Can SPD handle the request from the secure world? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:05]</code> What is SPM? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:41]</code> Why are SPD and SPM mutually exclusive? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
<li>Secure Partition <code>(230329.TrustZone.txt)</code><ul>
<li><code>[09:04]</code> What is SP? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:05]</code> Can different SPs communicate together? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:06]</code> How to create a SP and when? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:08]</code> Can I create a SP in run-time? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:08]</code> What is TA? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:24]</code> How do TAs and SPs communicate each other? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:43]</code> Can a SP host many TAs? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:44]</code> Can a TA communicate different SP? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
<li>Privilege Levels <code>(230329.TrustZone.txt)</code><ul>
<li><code>[09:44]</code> What are EL0, EL1, EL2, S-EL0, S-EL1, S-EL2, S-EL3? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
<li>Basic Concepts <code>(230328.TEE.txt)</code><ul>
<li><code>[10:04]</code> https://en.wikipedia.org/wiki/Trusted_execution_environment <code>(TEE.0328.md)</code></li>
<li><code>[13:55]</code> Please summarize Intel SGX and ARM TrustZone in tables. <code>(TEE.0328.md)</code></li>
<li><code>[13:58]</code> What are different between ARM SMC and Intel SMI? Please also summarize in a table. <code>(TEE.0328.md)</code></li>
<li><code>[13:59]</code> Please describe TEE in Intel. <code>(TEE.0328.md)</code></li>
<li><code>[14:00]</code> What are APIs of TEE? Please classify them. <code>(TEE.0328.md)</code></li>
<li><code>[14:02]</code> Can I add a myself TEE API? <code>(TEE.0328.md)</code></li>
</ul>
</li>
<li>Memory <code>(230327.OP-TEE.txt)</code><ul>
<li><code>[16:19]</code> How does OP-TEE manage memory? <code>(OP-TEE.0327.md)</code></li>
<li><code>[16:27]</code> Are data in memory in secure world encrypted? <code>(OP-TEE.0327.md)</code></li>
</ul>
</li>
<li>Signature <code>(230327.OP-TEE.txt)</code><ul>
<li><code>[16:44]</code> Is signature required when a normal world application request a service in secure world? <code>(OP-TEE.0327.md)</code></li>
</ul>
</li>
<li>CA &amp; TA <code>(230328.TEE.txt)</code><ul>
<li><code>[16:56]</code> How does an  application in normal world request a service with shared memory of a trusted application in a secure world? Please describe the process with APIs. <code>(TEE.0328.md)</code></li>
<li><code>[17:10]</code> Which functions are used by TA (trusted application) in the above process? <code>(TEE.0328.md)</code></li>
<li><code>[17:16]</code> Could you please draw a sequence diagram of TEEC_InitializeContext, TEEC_OpenSession, TEEC_RegisterSharedMemory, TEEC_InvokeCommand, TEEC_ReleaseSharedMemory, TEEC_CloseSession, TEEC_FinalizeContext, TA_CreateEntryPoint, TA_DestroyEntryPoint, TA_OpenSessionEntryPoint, TA_CloseSessionEntryPoint, TA_InvokeCommandEntryPoint <code>(TEE.0328.md)</code></li>
<li><code>[17:25]</code> Is the above sequence described in GlobalPlatform? <code>(TEE.0328.md)</code></li>
<li><code>[17:27]</code> Which document describe it? <code>(TEE.0328.md)</code></li>
<li><code>[17:36]</code> Please give me two sample codes of the above sequence. One is for CA and another is for TA. <code>(TEE.0328.md)</code></li>
<li><code>[17:40]</code> Please write sample code of TA again. The code should be complete. <code>(TEE.0328.md)</code></li>
</ul>
</li>
</ul>
<hr />
<h1>Chats</h1>
<ul>
<li>TrustZone.0329.md<ul>
<li><code>[09:10]</code> What are relationships between TA and SP? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:11]</code> Can I say that an SP contain many TAs? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:13]</code> Can I say that a TA uses a SP? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:15]</code> How does TA use SP? <code>(TrustZone.0329.md)</code></li>
<li><code>[09:22]</code> How do I leverage TAs and SPs? <code>(TrustZone.0329.md)</code></li>
</ul>
</li>
<li>OP-TEE.0327.md<ul>
<li><code>[16:32]</code> How does a normal world application request a service in secure world? <code>(OP-TEE.0327.md)</code></li>
<li><code>[16:35]</code> Could you please draw a sequence diagram? <code>(OP-TEE.0327.md)</code></li>
<li><code>[16:40]</code> Thank you for your response. You are smart. <code>(OP-TEE.0327.md)</code></li>
<li><code>[17:01]</code> How does an  application in normal world request a service with shared memory of a trusted application in a secure world? Please describe the process in OP-TEE with API and functions. <code>(OP-TEE.0327.md)</code></li>
<li><code>[17:04]</code> Which functions are used by TA (trusted application) in the above process? <code>(OP-TEE.0327.md)</code></li>
<li><code>[17:06]</code> Are above functions defined in TEE standard? <code>(OP-TEE.0327.md)</code></li>
</ul>
</li>
<li>TEE.0328.md<ul>
<li><code>[16:47]</code> How does a normal world application request a service in secure world? <code>(TEE.0328.md)</code></li>
<li><code>[16:49]</code> How does a normal world application request a service with shared memory in secure world? Please describe the process and give APIs of TEE. <code>(TEE.0328.md)</code></li>
<li><code>[16:51]</code> How does a normal world application request a service with shared memory in secure world? Please describe the process and give APIs of both worlds. <code>(TEE.0328.md)</code></li>
<li><code>[17:12]</code> Could you please draw a sequence diagram for my above two questions? <code>(TEE.0328.md)</code></li>
</ul>
</li>
</ul>
<hr />
<h1>Q &amp; A</h1>
<h2>Normal World &amp; Secure World <code>(230329.TrustZone.txt)</code></h2>
<p><strong>Question:</strong> <code>[08:51]</code> Can Normal world and Secure World run at the same time in ARM? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In ARM TrustZone, the Normal world and Secure world cannot run concurrently. The processor can only execute code in either the Normal world or the Secure world at any given time. The two worlds are isolated from each other, and the processor switches between them based on events such as interrupts or requests for secure services. TrustZone uses a secure monitor mode to facilitate the transition between the two worlds, ensuring that the secure and non-secure states remain separate and protected.</p>
<hr />
<p><strong>Question:</strong> <code>[08:52]</code> But can Normal world and Secure World run at the same time in multi processors of ARM? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, in a multi-processor ARM system, it is possible for the Normal world and Secure world to run concurrently on separate cores. Each core in the system can be executing in either the Normal world or the Secure world independently. This allows for parallel processing of tasks in both worlds. However, it is important to note that the isolation between the two worlds is still maintained, and each core must follow the same TrustZone mechanisms to transition between the worlds when required.</p>
<hr />
<h2>Memory <code>(230329.TrustZone.txt)</code></h2>
<p><strong>Question:</strong> <code>[08:53]</code> How to define memory size of secure world? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Defining the memory size for the secure world in an ARM TrustZone-enabled system is highly dependent on the specific System-on-Chip (SoC) being used. Each SoC has different characteristics and mechanisms for allocating and partitioning memory resources between the secure and non-secure worlds.</p>
<p>Typically, the memory size for the secure world is defined during the system&rsquo;s initialization or configuration phase. The process involves configuring TrustZone-specific hardware components such as TrustZone Protection Controller (TZPC) and TrustZone Address Space Controller (TZASC) to set access permissions and memory partitions.</p>
<p>To define the memory size of the secure world, follow these general steps:</p>
<ol>
<li>
<p>Determine the available memory resources: Consult your SoC&rsquo;s technical reference manual or datasheet to identify the available memory resources and their respective addresses.</p>
</li>
<li>
<p>Configure TZPC and TZASC: Based on the desired memory size for the secure world, configure the TZPC and TZASC registers to partition the memory accordingly. This may involve setting up specific regions and access permissions for secure and non-secure worlds. Some SoCs might provide alternative or additional mechanisms for memory partitioning.</p>
</li>
<li>
<p>Verify and update your secure world software: Ensure your secure world software is aware of the allocated memory size and adapts its memory management accordingly.</p>
</li>
</ol>
<p>Please note that these steps are generalized, and you should refer to the documentation of your specific SoC for exact procedures and register configurations.</p>
<hr />
<p><strong>Question:</strong> <code>[08:53]</code> Can memory size of secure world be changed? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In most ARM TrustZone-enabled systems, the memory size of the secure world is typically defined during the system&rsquo;s initialization or configuration phase. However, whether the memory size of the secure world can be changed at runtime depends on the specific System-on-Chip (SoC) being used and its support for dynamic memory partitioning.</p>
<p>Some SoCs may allow for dynamic reconfiguration of TrustZone components like the TrustZone Protection Controller (TZPC) and TrustZone Address Space Controller (TZASC) during runtime, enabling changes to memory partitioning between the secure and non-secure worlds. In such cases, the secure world software would also need to support and be aware of such changes to adapt its memory management accordingly.</p>
<p>To determine if your specific SoC supports changing the memory size of the secure world at runtime, consult the technical reference manual or datasheet provided by the manufacturer. It&rsquo;s important to consider the potential security implications and any restrictions when dynamically changing memory partitioning, as it could introduce new attack surfaces or vulnerabilities.</p>
<hr />
<h2>SM &amp; SPM &amp; SPD <code>(230329.TrustZone.txt)</code></h2>
<p><strong>Question:</strong> <code>[08:55]</code> What is SMC? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>SMC stands for Secure Monitor Call, which is an ARM instruction used in TrustZone-enabled systems. The SMC instruction is used to transfer control between the non-secure (Normal) world and the secure world. When the non-secure world needs to access a secure resource or service, it uses the SMC instruction to trigger a switch to the secure world. The secure world then handles the request, performs the necessary operations, and returns control back to the non-secure world using the ERET (Exception Return) instruction.</p>
<p>The SMC instruction ensures that transitions between the two worlds are securely managed and controlled, allowing the secure world to maintain its isolation and integrity. Secure Monitor Calls are essential for implementing security services and trusted applications that require isolation from the non-secure world while still providing a controlled interface for communication between the two worlds.</p>
<hr />
<p><strong>Question:</strong> <code>[08:57]</code> Can secure world request a service in normal world via SMC? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, the secure world can request a service in the normal world via SMC. Although it&rsquo;s more common for the normal world to request services from the secure world, the secure world may still need to access certain resources or services in the normal world. In such cases, the secure world can use SMC to make a request to the normal world.</p>
<p>However, it&rsquo;s important to note that the secure world should carefully manage any interactions with the normal world to avoid compromising its own security. When the secure world needs to access services or resources in the normal world, it should do so with the understanding that the normal world is potentially untrusted and might attempt to exploit any vulnerabilities in the communication process. Therefore, the implementation of such communication should be done cautiously, with a focus on maintaining the isolation and integrity of the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[09:00]</code> What is SPD? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the context of ARM TrustZone, SPD (Secure Payload Dispatcher) is a component responsible for managing and dispatching Secure Partition (SP) requests. An SPD serves as an intermediary layer between the normal world and secure world, allowing for the secure processing of service requests from the normal world.</p>
<p>When a normal world application requires services provided by the secure world, it issues a request via SMC (Secure Monitor Call). The SPD receives this request, identifies the appropriate secure partition to handle the request, and dispatches the service execution to the corresponding partition. After the secure partition has processed the request, the SPD returns the result to the normal world.</p>
<p>By using an SPD, the secure world can maintain better isolation and security, as the SPD ensures that the normal world does not have direct access to secure partitions or their resources.</p>
<hr />
<p><strong>Question:</strong> <code>[09:03]</code> Can SPD handle the request from the secure world? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, the Secure Payload Dispatcher (SPD) can handle requests from both the normal world and the secure world. Although it is more common for the normal world to make service requests to the secure world, there might be cases where the secure world needs to access resources or services available in the normal world.</p>
<p>In such scenarios, the SPD plays a similar role in managing and dispatching these requests. It serves as an intermediary between the two worlds, ensuring that the communication is secure and that the appropriate services are invoked to handle the requests. This way, the secure world can access resources in the normal world without compromising its security and isolation.</p>
<hr />
<p><strong>Question:</strong> <code>[09:05]</code> What is SPM? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>SPM stands for Secure Partition Manager. In the context of ARM TrustZone or systems with secure partitions, the SPM is a component responsible for managing and orchestrating the execution of Secure Partitions (SPs). The SPM&rsquo;s role includes controlling access to resources, managing communication between SPs, ensuring the isolation of different secure partitions, and enforcing security policies.</p>
<p>In a nutshell, the Secure Partition Manager provides a framework for the secure world to manage the lifecycle and interactions of multiple secure partitions, ensuring that the security and isolation properties of each partition are maintained.</p>
<hr />
<p><strong>Question:</strong> <code>[09:41]</code> Why are SPD and SPM mutually exclusive? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The Secure Partition Manager (SPM) and the Secure Partition Dispatcher (SPD) are two different approaches to managing secure partitions in the ARMv8.4-A architecture, and they are mutually exclusive because they serve different purposes and are intended for different use cases.</p>
<ol>
<li>
<p>Secure Partition Manager (SPM): SPM is designed for the ARMv8.4-A architecture and is responsible for managing Secure Partitions (SPs). SPs are isolated execution environments running inside the secure world, which can host multiple security services or Trusted Applications (TAs). The SPM is responsible for creating, initializing, scheduling, and managing communication between SPs. It enables fine-grained partitioning of resources and services within the secure world.</p>
</li>
<li>
<p>Secure Partition Dispatcher (SPD): SPD is a part of ARM Trusted Firmware (ATF) and is used to manage secure services in ARMv8-A architecture. SPD provides an interface between the Normal World (NW) and the Secure World (SW). It is responsible for dispatching secure service requests from the NW to the appropriate secure execution environment, such as an SP or a TA, and returning the results back to the NW.</p>
</li>
</ol>
<p>The reason they are mutually exclusive is that they cater to different architectural versions and use cases. SPM is designed specifically for ARMv8.4-A and provides advanced features for managing SPs, while SPD is used in ARMv8-A to manage secure services.</p>
<p>Using both SPM and SPD simultaneously would lead to conflicts in terms of resource allocation, scheduling, and communication between the secure world and the normal world. To avoid confusion and ensure proper secure partition management, either SPM or SPD is used, depending on the target ARM architecture and the specific use case.</p>
<hr />
<h2>Secure Partition <code>(230329.TrustZone.txt)</code></h2>
<p><strong>Question:</strong> <code>[09:04]</code> What is SP? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>SP stands for Secure Partition, which is a software component or execution environment running within the secure world of ARM TrustZone. Secure Partitions are designed to provide isolation and protection for sensitive code and data, such as cryptographic operations, key management, or secure storage. The secure world hosts these SPs, which can communicate with the normal world through a well-defined interface, typically via SMC (Secure Monitor Call) instructions.</p>
<p>SPs help to ensure that critical operations and information remain protected from potentially malicious or insecure code running in the normal world. By isolating these components, TrustZone enhances the overall security of a system.</p>
<hr />
<p><strong>Question:</strong> <code>[09:05]</code> Can different SPs communicate together? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, different Secure Partitions (SPs) can communicate with each other within the secure world. However, this communication should be carefully designed and managed to maintain the isolation and security properties of each SP. Typically, an intermediary component like a secure partition manager or the secure monitor itself is responsible for facilitating communication between different SPs, ensuring that information sharing adheres to the security policies and requirements of each partition.</p>
<p>To enable secure communication between different SPs, developers should implement well-defined interfaces and access control policies to prevent unauthorized access or information leaks between partitions, maintaining the overall security goals of the system.</p>
<hr />
<p><strong>Question:</strong> <code>[09:06]</code> How to create a SP and when? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Creating a Secure Partition (SP) typically involves a few steps and is usually done during the system initialization or when a secure application needs to be launched. Here are the steps to create an SP:</p>
<ol>
<li>
<p>Design: Begin by identifying the secure functionality or application you want to isolate in a separate SP. Determine the security requirements, resource access, and communication interfaces needed for the secure partition.</p>
</li>
<li>
<p>Implementation: Implement the secure functionality or application, adhering to the security requirements and following best practices for secure programming. This may involve writing code and creating any necessary data structures, as well as implementing communication interfaces to interact with other SPs or the normal world.</p>
</li>
<li>
<p>Configuration: Configure the system to support the SP. This might involve configuring memory regions, peripherals, and access controls to meet the security requirements of the SP. This is typically done in the system&rsquo;s bootloader, firmware, or Secure Partition Manager (SPM), depending on the platform.</p>
</li>
<li>
<p>Initialization: Load and initialize the SP during system startup or when required. This process includes loading the secure partition&rsquo;s code and data into the protected memory regions and initializing the partition&rsquo;s state. The SPM or another trusted component may handle this initialization process.</p>
</li>
<li>
<p>Execution: Once initialized, the SP can be executed, providing its secure functionality to other components or applications in the system. The SPM or a trusted scheduler will manage the execution of the SP, ensuring proper isolation and adherence to security policies.</p>
</li>
</ol>
<p>Creating an SP depends on the specific platform or system you are working with, as well as the requirements of your secure application. Ensure that you consult the relevant documentation and guidelines for your platform to create and manage secure partitions effectively.</p>
<hr />
<p><strong>Question:</strong> <code>[09:08]</code> Can I create a SP in run-time? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Creating a Secure Partition (SP) during runtime is generally not recommended, as it could introduce security risks and may not be supported by some platforms. Secure Partitions are typically initialized during system startup or secure application launch to ensure proper isolation and security.</p>
<p>However, if your platform supports creating an SP during runtime and you have a valid use case, it might be possible. You would need to ensure that you take the necessary precautions to maintain the security of the system and the SPs, including:</p>
<ol>
<li>Ensuring proper isolation between the newly created SP and the rest of the system, including other SPs.</li>
<li>Configuring memory regions, peripherals, and access controls correctly.</li>
<li>Verifying the integrity and authenticity of the code and data being loaded into the new SP.</li>
</ol>
<p>Keep in mind that creating an SP during runtime may be more complex and error-prone than creating one during system startup or secure application launch. You should carefully consider the security implications and consult your platform&rsquo;s documentation to determine if this approach is supported and appropriate for your use case.</p>
<hr />
<p><strong>Question:</strong> <code>[09:08]</code> What is TA? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TA stands for Trusted Application. In the context of ARM TrustZone or Trusted Execution Environments (TEEs), a Trusted Application is a secure piece of software running in the secure world. These applications are designed to handle sensitive data or perform security-critical operations, isolated from the normal world or non-secure applications.</p>
<p>Trusted Applications typically run on top of a TEE Operating System (TEE OS), which provides services like secure storage, cryptographic operations, and secure communication with the normal world. The TEE OS is responsible for managing and isolating multiple Trusted Applications, ensuring that they don&rsquo;t interfere with each other or leak sensitive data. Examples of TEE OSs include OP-TEE and Trustonic Kinibi.</p>
<p>Trusted Applications are usually loaded and instantiated by the TEE OS based on requests from the normal world or other secure world components. They can be used to perform a wide range of tasks, such as digital rights management, secure payment processing, biometric authentication, and more.</p>
<hr />
<p><strong>Question:</strong> <code>[09:24]</code> How do TAs and SPs communicate each other? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TAs (Trusted Applications) and SPs (Secure Partitions) can communicate with each other using Inter-Partition Communication (IPC) mechanisms, which are platform-specific and depend on the underlying TEE (Trusted Execution Environment) OS or ARMv8.4-A architecture implementation.</p>
<p>When TAs and SPs need to communicate, they typically follow these steps:</p>
<ol>
<li>
<p>Establish a communication channel: Both TAs and SPs should have a well-defined communication interface, such as shared memory or message passing. The implementation details depend on the TEE OS for TAs and the platform&rsquo;s support for SPs.</p>
</li>
<li>
<p>Secure the communication channel: To ensure the confidentiality and integrity of data exchanged between TAs and SPs, use cryptographic techniques, such as encryption and authentication.</p>
</li>
<li>
<p>Exchange messages: TAs and SPs can exchange messages through the established communication channel. These messages may include requests for services, data to be processed, or responses.</p>
</li>
<li>
<p>Synchronize communication: Depending on the IPC mechanism used, it may be necessary to implement synchronization primitives, such as semaphores or mutexes, to coordinate communication between TAs and SPs.</p>
</li>
<li>
<p>Handle errors and exceptions: Implement error handling and exception mechanisms to manage communication failures, timeouts, or other unexpected events.</p>
</li>
</ol>
<p>It is essential to note that the communication between TAs and SPs requires careful implementation to ensure security and prevent potential attacks. Therefore, following best practices and guidelines for secure IPC is critical when developing communication between TAs and SPs.</p>
<hr />
<p><strong>Question:</strong> <code>[09:43]</code> Can a SP host many TAs? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A Secure Partition (SP) can host multiple Trusted Applications (TAs) in a single isolated execution environment within the secure world. The Secure Partition Manager (SPM) is responsible for managing and scheduling these TAs. Each TA can provide a specific security service, and they can all run within the same SP. By hosting multiple TAs within an SP, you can share resources among TAs, such as memory or peripherals, which can improve overall efficiency and reduce the overhead of managing individual TAs in separate SPs.</p>
<hr />
<p><strong>Question:</strong> <code>[09:44]</code> Can a TA communicate different SP? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A Trusted Application (TA) can communicate with different Secure Partitions (SPs) through a secure communication channel, which is typically established by the Secure Partition Manager (SPM) or another trusted component in the secure world. The communication between TAs and different SPs is usually facilitated by a well-defined interface using messages or function calls. This allows TAs to request services or share data with other SPs in a controlled and secure manner, without directly accessing each other&rsquo;s memory or resources. However, it is important to note that the level of isolation between TAs and SPs may vary depending on the specific implementation and platform.</p>
<hr />
<h2>Privilege Levels <code>(230329.TrustZone.txt)</code></h2>
<p><strong>Question:</strong> <code>[09:44]</code> What are EL0, EL1, EL2, S-EL0, S-EL1, S-EL2, S-EL3? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the ARMv8-A architecture, the privilege levels (EL) define different modes of operation for the processor, with each level having different access rights and capabilities. There are four Exception Levels (EL0, EL1, EL2, and EL3), and each level can operate in both Secure and Non-Secure states. Here&rsquo;s a brief explanation of each:</p>
<ol>
<li>
<p>EL0: This is the least privileged level, where user-space applications run. It has limited access to system resources and cannot execute privileged instructions.</p>
</li>
<li>
<p>EL1: This level is where the operating system kernel runs. It has more privileges than EL0, enabling it to manage system resources, configure the hardware, and isolate user-space applications from each other.</p>
</li>
<li>
<p>EL2: This level is intended for hypervisors, which manage multiple virtual machines or operating systems. It provides the necessary isolation and control to manage virtualization.</p>
</li>
<li>
<p>EL3: This is the most privileged level, typically used for low-level firmware, such as a bootloader or a Trusted Execution Environment (TEE). It is responsible for setting up the system and ensuring a secure boot process.</p>
</li>
</ol>
<p>The &ldquo;S-&rdquo; prefix indicates that the exception level is operating in the Secure state, which is part of ARM&rsquo;s TrustZone technology. TrustZone creates a separate, isolated environment for secure applications and data, ensuring that sensitive information remains protected from potential attacks or unauthorized access:</p>
<ol>
<li>S-EL0: Secure User mode, where secure user-space applications run.</li>
<li>S-EL1: Secure Kernel mode, where the secure operating system kernel runs.</li>
<li>S-EL2: Secure Hypervisor mode, where a secure hypervisor can manage secure virtual machines.</li>
<li>S-EL3: Secure Monitor mode, where low-level firmware like a secure bootloader or a TEE operates.</li>
</ol>
<p>In summary, the ARMv8-A architecture organizes the privilege levels (EL0, EL1, EL2, and EL3) and the Secure (S-EL0, S-EL1, S-EL2, and S-EL3) and Non-Secure states to create a robust and flexible environment for running a mix of secure and non-secure applications, operating systems, and hypervisors.</p>
<hr />
<h2>Basic Concepts <code>(230328.TEE.txt)</code></h2>
<p><strong>Question:</strong> <code>[10:04]</code> https://en.wikipedia.org/wiki/Trusted_execution_environment <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A Trusted Execution Environment (TEE) is a secure area within the main processor of a device that ensures the confidentiality and integrity of code and data loaded within it. TEEs are designed to provide a higher level of security compared to traditional software execution environments by protecting sensitive information and functionality from external software attacks, hardware attacks, and physical tampering.</p>
<p>The main concept behind a TEE is to provide an isolated environment for executing security-sensitive tasks that cannot be accessed by other processes running on the same device. This isolation is achieved using hardware and software mechanisms that create a secure boundary around the TEE.</p>
<p>Some of the key features of TEEs include:</p>
<ol>
<li>Isolation: TEEs provide a separate execution environment that isolates sensitive operations from the rest of the system.</li>
<li>Secure storage: TEEs provide a secure storage area for sensitive data, keys, and credentials that can only be accessed by the trusted applications running within the TEE.</li>
<li>Integrity: TEEs ensure the integrity of the code and data being executed by verifying the digital signatures of the applications before they are allowed to run within the TEE.</li>
<li>Confidentiality: TEEs protect the confidentiality of the data being processed within the environment by encrypting it.</li>
</ol>
<p>TEEs have various applications, such as secure boot, digital rights management (DRM), and mobile payments. Some examples of TEE implementations include ARM TrustZone, Intel Software Guard Extensions (SGX), and AMD Secure Encrypted Virtualization (SEV).</p>
<p>It is important to note that while TEEs offer a higher level of security, they are not immune to attacks. Researchers have discovered vulnerabilities in various TEE implementations, emphasizing the need for ongoing research and development to enhance the security of these environments.</p>
<hr />
<p><strong>Question:</strong> <code>[13:55]</code> Please summarize Intel SGX and ARM TrustZone in tables. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Here&rsquo;s a summary of Intel SGX and ARM TrustZone in table format:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Intel SGX</th>
<th>ARM TrustZone</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Name</td>
<td>Intel Software Guard Extensions</td>
<td>ARM TrustZone</td>
</tr>
<tr>
<td>Type</td>
<td>Hardware-based security feature</td>
<td>Hardware-based security feature</td>
</tr>
<tr>
<td>Purpose</td>
<td>Create secure enclaves for running trusted code &amp; data</td>
<td>Create a secure environment for running trusted code &amp; data</td>
</tr>
<tr>
<td>Architecture</td>
<td>x86-based processors</td>
<td>ARM-based processors</td>
</tr>
<tr>
<td>Isolation Method</td>
<td>Enclaves</td>
<td>Two worlds (Secure and Non-secure)</td>
</tr>
<tr>
<td>Memory Protection</td>
<td>Hardware-based encryption of enclave memory</td>
<td>Secure memory is isolated from the non-secure world</td>
</tr>
<tr>
<td>Remote Attestation</td>
<td>Supported, enables remote verification of enclave integrity</td>
<td>Supported, enables remote verification of secure world integrity</td>
</tr>
<tr>
<td>Applications</td>
<td>Secure computation, data protection, key management, etc.</td>
<td>Secure boot, DRM, mobile payments, key management, etc.</td>
</tr>
<tr>
<td>Vulnerabilities</td>
<td>Side-channel attacks, Spectre, Meltdown, etc.</td>
<td>Side-channel attacks, information leakage, etc.</td>
</tr>
</tbody>
</table>
<p>Both Intel SGX and ARM TrustZone are hardware-based security features designed to provide isolated execution environments for trusted code and data. They offer different mechanisms for isolation (enclaves vs. two worlds) and have unique implementations in their respective processor architectures (x86-based for SGX and ARM-based for TrustZone). While these technologies enhance the security of sensitive operations, they are not immune to various attacks, and ongoing research and development is required to improve their security.</p>
<hr />
<p><strong>Question:</strong> <code>[13:58]</code> What are different between ARM SMC and Intel SMI? Please also summarize in a table. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>ARM SMC (Secure Monitor Call) and Intel SMI (System Management Interrupt) are both mechanisms used in their respective processor architectures for managing secure or privileged operations. Here&rsquo;s a summary of their differences in table format:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>ARM SMC</th>
<th>Intel SMI</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Name</td>
<td>Secure Monitor Call</td>
<td>System Management Interrupt</td>
</tr>
<tr>
<td>Type</td>
<td>Instruction for switching between secure &amp; non-secure worlds</td>
<td>Interrupt for managing system-level functions</td>
</tr>
<tr>
<td>Architecture</td>
<td>ARM-based processors</td>
<td>x86-based processors</td>
</tr>
<tr>
<td>Purpose</td>
<td>Transition between secure and non-secure worlds in ARM TrustZone</td>
<td>Execute system management functions in System Management Mode (SMM)</td>
</tr>
<tr>
<td>Invocation</td>
<td>Issued by software to request a switch between worlds</td>
<td>Triggered by hardware events or software requests</td>
</tr>
<tr>
<td>Execution Context</td>
<td>Secure world in ARM TrustZone</td>
<td>System Management Mode on x86 processors</td>
</tr>
<tr>
<td>Privilege Level</td>
<td>Highest privilege level in ARM TrustZone</td>
<td>Highest privilege level in x86 processors</td>
</tr>
<tr>
<td>Applications</td>
<td>Secure boot, DRM, mobile payments, key management, etc.</td>
<td>Power management, hardware configuration, firmware updates, etc.</td>
</tr>
</tbody>
</table>
<p>ARM SMC is an instruction used in ARM-based processors to switch between the secure and non-secure worlds of ARM TrustZone, enabling the processor to execute secure operations. In contrast, Intel SMI is an interrupt mechanism used in x86-based processors to manage system-level functions, such as power management and hardware configuration, in the System Management Mode (SMM). While both mechanisms operate at the highest privilege levels of their respective architectures, they serve different purposes and are invoked under different circumstances.</p>
<hr />
<p><strong>Question:</strong> <code>[13:59]</code> Please describe TEE in Intel. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In Intel processors, the primary Trusted Execution Environment (TEE) technology is Intel Software Guard Extensions (SGX). Intel SGX provides a hardware-based TEE to securely execute sensitive code and protect data within isolated regions, known as enclaves.</p>
<p>Here&rsquo;s an overview of Intel SGX:</p>
<ol>
<li>
<p>Enclaves: Enclaves are secure, isolated regions in the processor&rsquo;s memory that cannot be accessed by other processes or privileged software, such as the operating system, hypervisors, or other system software. They provide confidentiality and integrity for the data and code being executed within the enclave.</p>
</li>
<li>
<p>Memory encryption: Intel SGX encrypts the enclave memory using hardware-based encryption, which ensures that the data within the enclave remains confidential even if the physical memory is compromised.</p>
</li>
<li>
<p>Remote attestation: Intel SGX supports remote attestation, which enables a remote party to verify the integrity and authenticity of the enclave. This process ensures that the enclave is running the expected code and has not been tampered with.</p>
</li>
<li>
<p>Sealing: Intel SGX provides sealing functionality, which allows data to be encrypted and stored outside the enclave using a key that is bound to the enclave&rsquo;s identity. This ensures that the data can only be decrypted by the same enclave or an enclave with the same identity, providing confidentiality for data at rest.</p>
</li>
<li>
<p>Application development: Developers can create applications that use Intel SGX by partitioning their code and data into trusted and untrusted components. The trusted components, which contain sensitive operations and data, are executed within enclaves, while the untrusted components are executed outside the enclave.</p>
</li>
</ol>
<p>Intel SGX is a powerful TEE solution that provides an additional layer of security for sensitive code and data execution. However, it is important to note that Intel SGX is not immune to attacks, and researchers have discovered vulnerabilities in the technology, emphasizing the need for ongoing research and development to enhance its security.</p>
<hr />
<p><strong>Question:</strong> <code>[14:00]</code> What are APIs of TEE? Please classify them. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Trusted Execution Environment (TEE) APIs are interfaces that enable developers to create applications that leverage the features of a TEE. They allow developers to interact with the secure environment and manage its resources, such as enclaves, secure storage, and cryptographic operations.</p>
<p>These APIs can be classified into several categories:</p>
<ol>
<li>
<p>TEE Management APIs:
   - Enclave or secure world creation and destruction
   - Resource management, such as memory allocation and deallocation
   - Context switching between the secure and non-secure worlds</p>
</li>
<li>
<p>Cryptographic APIs:
   - Key management, including key generation, import, export, and storage
   - Cryptographic operations, such as encryption, decryption, signing, and verification
   - Secure random number generation
   - Cryptographic hash functions and message authentication codes (MACs)</p>
</li>
<li>
<p>Secure Storage APIs:
   - Secure storage of sensitive data, keys, and credentials
   - Data integrity and confidentiality protection
   - Access control and permission management</p>
</li>
<li>
<p>Attestation APIs:
   - Enclave or secure world measurement and reporting
   - Remote attestation to verify the integrity and authenticity of a TEE
   - Sealing and unsealing of data bound to the enclave or secure world identity</p>
</li>
<li>
<p>Communication APIs:
   - Secure communication channels between the TEE and external entities
   - Secure communication between enclaves or secure worlds</p>
</li>
</ol>
<p>Examples of TEE API implementations include the GlobalPlatform TEE APIs, which provide a standardized set of APIs for TEEs, and platform-specific APIs like Intel SGX SDK for Intel Software Guard Extensions and ARM TrustZone APIs for ARM TrustZone-based TEEs.</p>
<p>It is important to note that the specific APIs available and their implementation may vary depending on the TEE technology used. However, the general categories mentioned above should apply to most TEE implementations.</p>
<hr />
<p><strong>Question:</strong> <code>[14:02]</code> Can I add a myself TEE API? <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Adding your own TEE API is possible but depends on the specific TEE implementation you are working with and the level of access and customization it allows. Some TEEs offer more flexibility for developers to extend and create their own APIs, while others may have more restrictive environments.</p>
<p>Here are a few steps to consider when adding your own TEE API:</p>
<ol>
<li>
<p>Understand the TEE platform: Gain a deep understanding of the TEE platform you are working with, its architecture, and the existing APIs it provides. Familiarize yourself with the development environment, tools, and documentation.</p>
</li>
<li>
<p>Identify the use case: Determine the specific functionality or use case you want to address with your custom TEE API. Ensure that it is not already covered by existing APIs and that it aligns with the security objectives of the TEE.</p>
</li>
<li>
<p>Design the API: Design the API interface, considering factors such as function signatures, input and output parameters, and error handling. Keep security best practices in mind during the design process.</p>
</li>
<li>
<p>Implement the API: Write the code for your custom TEE API, following the platform&rsquo;s guidelines and using the development tools provided by the TEE vendor. Be sure to adhere to secure coding practices to avoid introducing vulnerabilities in your implementation.</p>
</li>
<li>
<p>Test and validate: Thoroughly test your custom TEE API, including edge cases and potential error conditions. Validate its functionality and security in the context of the TEE platform.</p>
</li>
<li>
<p>Integrate and document: Integrate your custom TEE API with your application or system, and create documentation to help other developers understand how to use your API.</p>
</li>
</ol>
<p>Keep in mind that adding your own TEE API may introduce security risks if not done properly. It is crucial to ensure that your implementation adheres to security best practices and does not compromise the integrity and confidentiality of the TEE.</p>
<p>Before attempting to add your own TEE API, it is recommended to explore existing APIs and functionality provided by the TEE platform, as they are designed to address common use cases and have undergone extensive testing and validation.</p>
<hr />
<h2>Memory <code>(230327.OP-TEE.txt)</code></h2>
<p><strong>Question:</strong> <code>[16:19]</code> How does OP-TEE manage memory? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. Memory management in OP-TEE involves several aspects:</p>
<ol>
<li>
<p>Secure memory allocation: OP-TEE uses secure memory for storing sensitive data and code related to the secure kernel and trusted applications (TAs). It ensures that secure memory is not accessible by the normal world to maintain confidentiality and integrity. OP-TEE provides APIs for trusted applications to allocate and deallocate secure memory dynamically.</p>
</li>
<li>
<p>Trusted Application memory isolation: OP-TEE maintains memory isolation between different trusted applications, preventing them from accessing each other&rsquo;s memory regions. This ensures the confidentiality and integrity of data and code in each trusted application.</p>
</li>
<li>
<p>Shared memory management: OP-TEE manages shared memory to facilitate secure data exchange between the normal world and the secure world. The GlobalPlatform TEE Client API provides functions to allocate, register, and release shared memory. OP-TEE ensures proper access control and isolation for shared memory buffers.</p>
</li>
<li>
<p>Memory mapping: OP-TEE manages the memory mapping for the secure world, ensuring that the memory regions for the secure kernel, trusted applications, and shared memory are correctly mapped to physical memory addresses.</p>
</li>
<li>
<p>Memory protection: OP-TEE enforces memory protection policies for the secure world, including access controls, permissions, and execution restrictions. This helps prevent unauthorized access, tampering, or execution of secure memory regions.</p>
</li>
<li>
<p>Memory management for trusted applications: Trusted applications in OP-TEE can request memory from the TEE Core, which is the secure kernel, through TEE Internal API functions like TEE_Malloc, TEE_Realloc, and TEE_Free. These functions allow trusted applications to allocate and manage memory dynamically within their secure environment.</p>
</li>
</ol>
<p>In summary, OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. This includes secure memory allocation, isolation between trusted applications, shared memory management, memory mapping, memory protection, and dynamic memory management for trusted applications.</p>
<hr />
<p><strong>Question:</strong> <code>[16:27]</code> Are data in memory in secure world encrypted? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Data stored in the memory of the secure world in OP-TEE is not encrypted by default. However, the secure world memory is protected by the hardware-based isolation provided by Arm TrustZone technology. TrustZone ensures that the normal world cannot directly access or tamper with the secure world&rsquo;s memory, which includes the secure kernel, trusted applications, and their associated data.</p>
<p>Although the data in the secure world memory is not encrypted, the isolation and access controls provided by TrustZone offer a strong level of protection. If an application or use case demands an even higher level of security, it is possible for trusted applications to implement additional encryption or other security measures for sensitive data stored in memory. This would depend on the specific requirements and threat model of the application or system.</p>
<p>In summary, data in the secure world memory is not encrypted by default in OP-TEE, but it is protected by the hardware-based isolation provided by Arm TrustZone technology. Additional encryption or security measures can be implemented by trusted applications if required.</p>
<hr />
<h2>Signature <code>(230327.OP-TEE.txt)</code></h2>
<p><strong>Question:</strong> <code>[16:44]</code> Is signature required when a normal world application request a service in secure world? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. The communication between the normal world application and the trusted application is facilitated using the GlobalPlatform TEE Client API, which ensures proper access control and isolation for shared memory buffers used for data exchange.</p>
<p>However, a signature may be used in certain scenarios to enhance security. For example, if the normal world application sends sensitive data or a critical command to the trusted application, it might be useful to sign the data or command to ensure integrity and authenticity. This would help prevent tampering or replay attacks, especially in cases where the normal world might be compromised.</p>
<p>In such cases, the normal world application can sign the data or command using a private key, and the trusted application in the secure world can verify the signature using the corresponding public key. This ensures that the data or command has not been altered and that it originates from a trusted source.</p>
<p>In summary, a signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. However, signatures can be used in certain scenarios to enhance security by ensuring the integrity and authenticity of data or commands sent to the secure world.</p>
<hr />
<h2>CA &amp; TA <code>(230328.TEE.txt)</code></h2>
<p><strong>Question:</strong> <code>[16:56]</code> How does an  application in normal world request a service with shared memory of a trusted application in a secure world? Please describe the process with APIs. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In a Trusted Execution Environment (TEE), a normal world application can request a service from a trusted application in the secure world using shared memory for data exchange. The process involves allocating a memory buffer that can be accessed by both the normal world and the secure world, allowing for efficient and secure communication between the two. Here&rsquo;s an outline of the process using the GlobalPlatform TEE APIs as an example:</p>
<ol>
<li>
<p>Initialize context: The normal world application initializes a TEE context, which represents a connection to the TEE. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_InitializeContext</code> function.</p>
</li>
<li>
<p>Open session: The normal world application opens a session with the trusted application in the secure world. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_OpenSession</code> function.</p>
</li>
<li>
<p>Allocate shared memory: The normal world application allocates a shared memory buffer that can be accessed by both the normal world and the secure world. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_RegisterSharedMemory</code> function.</p>
</li>
<li>
<p>Prepare data: The normal world application writes the input data and any necessary parameters into the shared memory buffer.</p>
</li>
<li>
<p>Issue the call: The normal world application issues a call to the trusted application in the secure world to request the service, providing a reference to the shared memory buffer as part of the call. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_InvokeCommand</code> function.</p>
</li>
<li>
<p>Process the request: The trusted application in the secure world processes the request, reads the input data from the shared memory buffer, performs the required operations, and writes the response back into the shared memory buffer.</p>
</li>
<li>
<p>Return to the normal world: Once the trusted application in the secure world has completed processing the request, control is returned to the normal world application.</p>
</li>
<li>
<p>Process the response: The normal world application reads the response from the shared memory buffer and processes it accordingly.</p>
</li>
<li>
<p>Release shared memory: After the response has been processed, the normal world application releases the shared memory buffer. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_ReleaseSharedMemory</code> function.</p>
</li>
<li>
<p>Close session: The normal world application closes the session with the trusted application in the secure world. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_CloseSession</code> function.</p>
</li>
<li>
<p>Finalize context: The normal world application finalizes the TEE context, releasing any resources associated with it. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_FinalizeContext</code> function.</p>
</li>
</ol>
<p>Please note that the specific APIs and mechanisms for requesting a service using shared memory in the secure world may vary depending on the TEE implementation being used. The example provided above is based on the GlobalPlatform TEE APIs, which are widely used in the industry for TEE development. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different APIs and mechanisms for managing shared memory communication between the normal world and the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[17:10]</code> Which functions are used by TA (trusted application) in the above process? <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the process described above, the Trusted Application (TA) in the secure world is responsible for handling requests from the normal world application and performing the requested operations. To do this, the TA needs to implement certain functions to interact with the TEE and the normal world application. The specific functions depend on the TEE implementation being used. Here, we&rsquo;ll use the GlobalPlatform TEE Internal APIs as an example:</p>
<ol>
<li>
<p>TA_CreateEntryPoint: This function is called when the TA is first loaded by the TEE. It can be used to perform initial setup or resource allocation. The function is optional and may be left empty if no specific actions are required at this stage.</p>
</li>
<li>
<p>TA_DestroyEntryPoint: This function is called when the TA is unloaded by the TEE. It can be used to perform cleanup or resource deallocation. The function is optional and may be left empty if no specific actions are required at this stage.</p>
</li>
<li>
<p>TA_OpenSessionEntryPoint: This function is called when the normal world application opens a session with the TA. It can be used to perform session-specific setup, such as allocating session-specific resources or initializing session context. The function should return TEE_SUCCESS on success or an appropriate error code on failure.</p>
</li>
<li>
<p>TA_CloseSessionEntryPoint: This function is called when the normal world application closes a session with the TA. It can be used to perform session-specific cleanup, such as deallocating session-specific resources or clearing session context. The function is optional and may be left empty if no specific actions are required at this stage.</p>
</li>
<li>
<p>TA_InvokeCommandEntryPoint: This function is called when the normal world application issues a call to the TA to request a service. The function is responsible for processing the request, reading the input data from the shared memory buffer (if used), performing the required operations, and writing the response back into the shared memory buffer (if used). The function should return TEE_SUCCESS on success or an appropriate error code on failure.</p>
</li>
</ol>
<p>The specific functions and APIs used by a Trusted Application (TA) may vary depending on the TEE implementation being used. The example provided above is based on the GlobalPlatform TEE Internal APIs, which are widely used in the industry for developing TAs in a TEE. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different functions and APIs for implementing TAs in the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[17:16]</code> Could you please draw a sequence diagram of TEEC_InitializeContext, TEEC_OpenSession, TEEC_RegisterSharedMemory, TEEC_InvokeCommand, TEEC_ReleaseSharedMemory, TEEC_CloseSession, TEEC_FinalizeContext, TA_CreateEntryPoint, TA_DestroyEntryPoint, TA_OpenSessionEntryPoint, TA_CloseSessionEntryPoint, TA_InvokeCommandEntryPoint <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>As a text-based AI language model, I cannot directly draw diagrams. However, I can describe the sequence of events and interactions between the normal world application and the trusted application in the secure world using the APIs mentioned in your question. You can use this description to create your own sequence diagram.</p>
<ol>
<li>
<p>The normal world application calls <code>TEEC_InitializeContext</code> to initialize a TEE context.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_OpenSession</code> to open a session with the trusted application.
   a. The TEE loads the trusted application if not already loaded.
   b. The TEE calls <code>TA_CreateEntryPoint</code> in the trusted application for initialization.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_RegisterSharedMemory</code> to allocate a shared memory buffer.</p>
</li>
<li>
<p>The normal world application writes input data to the shared memory buffer.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_InvokeCommand</code>, passing a reference to the shared memory buffer.
   a. The TEE calls <code>TA_OpenSessionEntryPoint</code> in the trusted application to indicate a new session is opened.
   b. The TEE calls <code>TA_InvokeCommandEntryPoint</code> in the trusted application to process the request.
      i. The trusted application reads input data from the shared memory buffer.
      ii. The trusted application performs the requested operations.
      iii. The trusted application writes the response back to the shared memory buffer.</p>
</li>
<li>
<p>The normal world application reads the response from the shared memory buffer.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_ReleaseSharedMemory</code> to release the shared memory buffer.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_CloseSession</code> to close the session with the trusted application.
   a. The TEE calls <code>TA_CloseSessionEntryPoint</code> in the trusted application to indicate the session is closed.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_FinalizeContext</code> to finalize the TEE context.
   a. The TEE unloads the trusted application if no other sessions are open.
   b. The TEE calls <code>TA_DestroyEntryPoint</code> in the trusted application for cleanup.</p>
</li>
</ol>
<p>You can use this sequence of events to create a diagram illustrating the interactions between the normal world application, the TEE system, and the trusted application in the secure world using the specified APIs.</p>
<hr />
<p><strong>Question:</strong> <code>[17:25]</code> Is the above sequence described in GlobalPlatform? <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, the sequence of events and interactions between the normal world application and the trusted application in the secure world, as described in the previous response, is based on the GlobalPlatform TEE specifications. GlobalPlatform provides a set of standard APIs, including the TEE Client API (used by the normal world application) and the TEE Internal API (used by the trusted application), to facilitate secure communication and service invocation in a Trusted Execution Environment (TEE).</p>
<p>The GlobalPlatform TEE specifications can be found on the GlobalPlatform website, which provides detailed documentation on the APIs and their usage: https://www.globalplatform.org/specs-library/?search=tee</p>
<p>It&rsquo;s important to note that the specific APIs and mechanisms for requesting a service using shared memory in the secure world may vary depending on the TEE implementation being used. The example provided in the previous response is based on the GlobalPlatform TEE APIs, which are widely used in the industry for TEE development. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different APIs and mechanisms for managing shared memory communication between the normal world and the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[17:27]</code> Which document describe it? <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The sequence described in the previous responses is based on the GlobalPlatform TEE specifications, which are divided into two main documents:</p>
<ol>
<li>GlobalPlatform TEE Client API Specification: This document describes the APIs used by the normal world application to interact with the TEE, such as <code>TEEC_InitializeContext</code>, <code>TEEC_OpenSession</code>, <code>TEEC_RegisterSharedMemory</code>, <code>TEEC_InvokeCommand</code>, <code>TEEC_ReleaseSharedMemory</code>, <code>TEEC_CloseSession</code>, and <code>TEEC_FinalizeContext</code>. The latest version of this document can be found at:</li>
</ol>
<p>https://globalplatform.org/specs-library/tee-client-api-specification/</p>
<ol start="2">
<li>GlobalPlatform TEE Internal Core API Specification: This document describes the APIs used by the trusted application in the secure world, such as <code>TA_CreateEntryPoint</code>, <code>TA_DestroyEntryPoint</code>, <code>TA_OpenSessionEntryPoint</code>, <code>TA_CloseSessionEntryPoint</code>, and <code>TA_InvokeCommandEntryPoint</code>. The latest version of this document can be found at:</li>
</ol>
<p>https://globalplatform.org/specs-library/tee-internal-core-api-specification/</p>
<p>Both documents provide detailed information on the APIs and their usage, including the sequence of interactions between the normal world application and the trusted application in the secure world. By studying these documents, you can gain a deep understanding of the TEE development process based on the GlobalPlatform specifications.</p>
<hr />
<p><strong>Question:</strong> <code>[17:36]</code> Please give me two sample codes of the above sequence. One is for CA and another is for TA. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Here are two sample codes for the normal world application (Client Application, CA) and the secure world application (Trusted Application, TA) based on the GlobalPlatform TEE APIs:</p>
<p>Client Application (CA) - Normal World:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_client_api.h&gt;</span><span class="cp"></span>

<span class="cp">#define TA_UUID {0x12345678, 0x1234, 0x1234, {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF}}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Result</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Context</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Session</span><span class="w"> </span><span class="n">session</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_SharedMemory</span><span class="w"> </span><span class="n">sharedMem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Operation</span><span class="w"> </span><span class="n">operation</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">returnOrigin</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize context</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_InitializeContext</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to initialize context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Open session</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_OpenSession</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">TA_UUID</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_LOGIN_PUBLIC</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">returnOrigin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to open session</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">TEEC_FinalizeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate shared memory</span>
<span class="w">    </span><span class="n">sharedMem</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">sharedMem</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_MEM_INPUT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TEEC_MEM_OUTPUT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_RegisterSharedMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to allocate shared memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">TEEC_CloseSession</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">TEEC_FinalizeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prepare operation</span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">paramTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_PARAM_TYPES</span><span class="p">(</span><span class="n">TEEC_MEMREF_PARTIAL_INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_MEMREF_PARTIAL_OUTPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_NONE</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_NONE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">outputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">sharedMem</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Invoke command</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_InvokeCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0000</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">operation</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">returnOrigin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to invoke command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outputData</span><span class="p">,</span><span class="w"> </span><span class="n">sharedMem</span><span class="p">.</span><span class="n">buffer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Input: %d, Output: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">outputData</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Release shared memory</span>
<span class="w">    </span><span class="n">TEEC_ReleaseSharedMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Close session and finalize context</span>
<span class="w">    </span><span class="n">TEEC_CloseSession</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_FinalizeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Trusted Application (TA) - Secure World:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api_extensions.h&gt;</span><span class="cp"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_CreateEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_DestroyEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_OpenSessionEntryPoint</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">paramTypes</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">sessionContext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_CloseSessionEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="w"></span>

<span class="o">---</span><span class="w"></span>

<span class="o">**</span><span class="nl">Question</span><span class="p">:</span><span class="o">**</span><span class="w"> </span><span class="err">`</span><span class="p">[</span><span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="p">]</span><span class="err">`</span><span class="w"> </span><span class="n">Please</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">TA</span><span class="w"> </span><span class="n">again</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">complete</span><span class="p">.</span><span class="w"> </span><span class="err">`</span><span class="p">(</span><span class="n">TEE</span><span class="mf">.0328</span><span class="p">.</span><span class="n">md</span><span class="p">)</span><span class="err">`</span><span class="w"></span>

<span class="o">**</span><span class="nl">Answer</span><span class="p">:</span><span class="o">**</span><span class="w"></span>

<span class="n">Apologies</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">incomplete</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">earlier</span><span class="p">.</span><span class="w"> </span><span class="n">Here</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">complete</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Trusted</span><span class="w"> </span><span class="n">Application</span><span class="w"> </span><span class="p">(</span><span class="n">TA</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">secure</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="n">based</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GlobalPlatform</span><span class="w"> </span><span class="n">TEE</span><span class="w"> </span><span class="n">Internal</span><span class="w"> </span><span class="nl">API</span><span class="p">:</span><span class="w"></span>

<span class="err">```</span><span class="n">c</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api_extensions.h&gt;</span><span class="cp"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="n">TA_CreateEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform initialization tasks, if needed</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_DestroyEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform cleanup tasks, if needed</span>
<span class="p">}</span><span class="w"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_OpenSessionEntryPoint</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">paramTypes</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">sessionContext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform session-specific initialization tasks, if needed</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_CloseSessionEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform session-specific cleanup tasks, if needed</span>
<span class="p">}</span><span class="w"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_InvokeCommandEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">commandID</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">paramTypes</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_ERROR_NOT_SUPPORTED</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">commandID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x0000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Sample command</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">paramTypes</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEE_PARAM_TYPES</span><span class="p">(</span><span class="n">TEE_PARAM_TYPE_MEMREF_INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_PARAM_TYPE_MEMREF_OUTPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_PARAM_TYPE_NONE</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_PARAM_TYPE_NONE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_ERROR_BAD_PARAMETERS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">TEE_MemBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">inputBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">TEE_MemBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">outputBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_ERROR_BAD_PARAMETERS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">TEE_MemMove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">inputBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">outputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">TEE_MemMove</span><span class="p">(</span><span class="n">outputBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">outputData</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>This sample Trusted Application code defines the required entry points for creating, destroying, opening, and closing a session. The <code>TA_InvokeCommandEntryPoint</code> function implements a simple command that reads an integer from the input buffer, multiplies it by 2, and writes the result back to the output buffer.</p>
<hr />
<h2>TrustZone.0329.md</h2>
<p><strong>Question:</strong> <code>[09:10]</code> What are relationships between TA and SP? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Trusted Applications (TAs) and Secure Partitions (SPs) are related concepts in the context of ARM TrustZone and secure computing, but they are not the same. Both are mechanisms for running secure code within a Trusted Execution Environment (TEE) to handle sensitive data and perform security-critical operations, isolated from the normal world. However, they differ in their design, implementation, and use cases.</p>
<p>Trusted Applications (TAs):
1. TAs are secure software components running on a TEE Operating System (TEE OS) like OP-TEE or Trustonic Kinibi.
2. The TEE OS manages the TAs, providing isolation between them and offering secure services such as cryptographic operations, secure storage, and communication with the normal world.
3. TAs are typically used for specific security functions or operations like digital rights management, secure payment processing, biometric authentication, and more.</p>
<p>Secure Partitions (SPs):
1. SPs are part of the ARMv8.4-A architecture, which introduces the concept of ARM Confidential Compute Architecture (CCA).
2. SPs provide a way to partition and isolate secure software components directly at the hardware level, without the need for a TEE OS.
3. Each SP runs in its own isolated environment, with dedicated memory and resources, and can communicate with other SPs or the normal world using a defined protocol.</p>
<p>In summary, while both TAs and SPs serve the purpose of providing secure environments for handling sensitive data and operations, TAs rely on a TEE OS to manage them and provide services, while SPs are isolated directly at the hardware level without the need for a TEE OS. SPs are a newer concept introduced with ARMv8.4-A architecture, whereas TAs have been used in earlier versions of ARM TrustZone.</p>
<hr />
<p><strong>Question:</strong> <code>[09:11]</code> Can I say that an SP contain many TAs? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>It would not be accurate to say that an SP contains many TAs because they are separate concepts with different implementations and use cases. TAs are secure software components running on a TEE OS like OP-TEE or Trustonic Kinibi, while SPs are part of the ARMv8.4-A architecture and do not rely on a TEE OS. SPs provide isolation and secure execution directly at the hardware level.</p>
<p>You can think of TAs as a way to implement secure functions within a TEE OS, while SPs provide a mechanism to create isolated execution environments at the hardware level without depending on a TEE OS. They both serve the purpose of providing secure environments for handling sensitive data and operations but do so in different ways. Therefore, it would be more appropriate to view TAs and SPs as distinct, independent entities rather than one containing the other.</p>
<hr />
<p><strong>Question:</strong> <code>[09:13]</code> Can I say that a TA uses a SP? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>No, it would not be accurate to say that a TA uses a SP, as they are separate concepts with different implementations and use cases. TAs (Trusted Applications) are secure software components running within a TEE OS like OP-TEE or Trustonic Kinibi, while SPs (Secure Partitions) are part of the ARMv8.4-A architecture and do not rely on a TEE OS. SPs provide isolation and secure execution directly at the hardware level.</p>
<p>TA and SP both serve the purpose of providing secure environments for handling sensitive data and operations, but they do so in different ways and are not directly related. TAs operate within the context of a TEE OS, whereas SPs provide isolation at the hardware level, independent of any specific TEE OS.</p>
<hr />
<p><strong>Question:</strong> <code>[09:15]</code> How does TA use SP? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TA (Trusted Application) and SP (Secure Partition) are separate concepts and are not meant to be used together directly. TA is a software component that runs within a Trusted Execution Environment (TEE) OS, such as OP-TEE or Trustonic Kinibi. On the other hand, SPs are introduced in the ARMv8.4-A architecture and provide isolation and secure execution at the hardware level, without relying on a TEE OS.</p>
<p>In a system that utilizes both TAs and SPs, a TA would not directly use an SP. Instead, the TA would interact with the TEE OS or other components within the secure world to perform its functions. The SP would provide isolation and security at the hardware level, independently of the TAs and the TEE OS.</p>
<p>In summary, TAs and SPs are separate entities with different implementations and use cases. They both contribute to creating secure environments for sensitive data and operations, but they do not have a direct relationship where a TA would use an SP.</p>
<hr />
<p><strong>Question:</strong> <code>[09:22]</code> How do I leverage TAs and SPs? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>To leverage TAs (Trusted Applications) and SPs (Secure Partitions) effectively, you need to follow these steps:</p>
<ol>
<li>
<p>Understand the target platform: Determine if the target platform supports a Trusted Execution Environment (TEE) OS for TAs or ARMv8.4-A architecture for SPs. Choose the appropriate technology based on the platform&rsquo;s support and your security requirements.</p>
</li>
<li>
<p>Implement Trusted Applications (TAs):
   a. Choose a TEE OS: Select a TEE OS, such as OP-TEE, Trustonic Kinibi, or another TEE OS compatible with your platform.
   b. Develop TAs: Write the TAs that perform security-sensitive operations or handle sensitive data. TAs run within the TEE OS, providing a secure and isolated environment.
   c. Deploy TAs: Package and deploy TAs to the target platform according to the TEE OS&rsquo;s requirements and guidelines.</p>
</li>
<li>
<p>Implement Secure Partitions (SPs):
   a. Set up the environment: Ensure your platform and development tools support the ARMv8.4-A architecture with the required security extensions.
   b. Develop SPs: Write the SPs that perform security-sensitive operations or handle sensitive data. SPs provide hardware-level isolation and security, without relying on a TEE OS.
   c. Configure resources: Define the resources, such as memory regions and peripherals, accessible by each SP. Set access permissions and isolation levels according to your security requirements.
   d. Deploy SPs: Package and deploy the SPs to the target platform according to the ARMv8.4-A architecture requirements and guidelines.</p>
</li>
<li>
<p>Secure communication: Establish secure communication channels between the normal world and the secure world, which may involve TAs and SPs. Use mechanisms such as remote procedure calls (RPCs) or SMC (Secure Monitor Calls) to facilitate communication.</p>
</li>
<li>
<p>Integrate with the normal world: Develop applications and services in the normal world that interact with TAs and SPs for security-sensitive operations. Ensure the normal world applications and services adhere to best practices for security, such as proper authentication and access control.</p>
</li>
</ol>
<p>By following these steps, you can effectively leverage TAs and SPs to create a secure environment for sensitive data and operations on your ARM-based platform.</p>
<hr />
<h2>OP-TEE.0327.md</h2>
<p><strong>Question:</strong> <code>[16:32]</code> How does a normal world application request a service in secure world? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A normal world application requests a service from a trusted application in the secure world by following these steps:</p>
<ol>
<li>
<p>Establish communication: First, the normal world application needs to establish communication with the secure world. This is done using the GlobalPlatform TEE Client API, which provides a set of functions to communicate with trusted applications.</p>
</li>
<li>
<p>Open a session: The normal world application opens a session with the trusted application by calling the TEEC_OpenSession function. This function takes parameters, such as the UUID of the trusted application, which uniquely identifies the service in the secure world.</p>
</li>
<li>
<p>Allocate shared memory (optional): If the normal world application needs to exchange data with the trusted application, it can allocate shared memory using the TEEC_AllocateSharedMemory function or register pre-allocated memory using the TEEC_RegisterSharedMemory function. This shared memory buffer can be used to pass data between the normal world and the secure world.</p>
</li>
<li>
<p>Invoke command: The normal world application sends a request for the service by invoking a command in the trusted application. This is done using the TEEC_InvokeCommand function, which takes parameters such as the command ID, which identifies the specific service or operation, and a set of operation parameters, which can include shared memory buffers for data exchange.</p>
</li>
<li>
<p>Process the response: After the trusted application in the secure world has executed the requested service, the normal world application can process the response, which may include data returned in shared memory buffers or an updated operation state.</p>
</li>
<li>
<p>Close the session: Once the normal world application has completed its interaction with the trusted application, it should close the session using the TEEC_CloseSession function. This will release resources associated with the session.</p>
</li>
<li>
<p>Release shared memory (optional): If shared memory was allocated or registered, the normal world application should release it using the TEEC_ReleaseSharedMemory function.</p>
</li>
</ol>
<p>By following these steps, a normal world application can request a service from a trusted application in the secure world, securely exchange data, and process the response while maintaining the security and isolation provided by OP-TEE and Arm TrustZone technology.</p>
<hr />
<p><strong>Question:</strong> <code>[16:35]</code> Could you please draw a sequence diagram? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>As an AI language model, I&rsquo;m unable to draw diagrams directly. However, I can describe the sequence of steps in a textual format that you can use to create your own sequence diagram:</p>
<ol>
<li>Normal World Application -&gt; TEEC_InitializeContext: Initialize the TEE Client API context.</li>
<li>Normal World Application -&gt; TEEC_OpenSession: Open a session with the Trusted Application using its UUID.</li>
<li>Normal World Application -&gt; TEEC_AllocateSharedMemory / TEEC_RegisterSharedMemory (Optional): Allocate or register shared memory for data exchange.</li>
<li>Normal World Application -&gt; TEEC_InvokeCommand: Invoke a command in the Trusted Application by providing the command ID and operation parameters (which may include shared memory references).</li>
<li>Trusted Application -&gt; Command Execution: The Trusted Application executes the requested command and processes the input data.</li>
<li>Trusted Application -&gt; TEEC_InvokeCommand: The Trusted Application returns the result of the command execution, which may include output data in shared memory buffers.</li>
<li>Normal World Application -&gt; Process Response: The normal world application processes the response and any data returned in shared memory.</li>
<li>Normal World Application -&gt; TEEC_CloseSession: Close the session with the Trusted Application.</li>
<li>Normal World Application -&gt; TEEC_ReleaseSharedMemory (Optional): Release the allocated or registered shared memory.</li>
<li>Normal World Application -&gt; TEEC_FinalizeContext: Finalize the TEE Client API context.</li>
</ol>
<p>You can use these steps to create a sequence diagram using any diagramming tool or by drawing it manually. The interactions in the sequence will help you visualize the flow of communication between the normal world application and the trusted application in the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[16:40]</code> Thank you for your response. You are smart. <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Thank you for your kind words! I&rsquo;m here to help and provide you with any information you need. If you have any more questions or need further clarification, please don&rsquo;t hesitate to ask.</p>
<hr />
<p><strong>Question:</strong> <code>[17:01]</code> How does an  application in normal world request a service with shared memory of a trusted application in a secure world? Please describe the process in OP-TEE with API and functions. <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>When a normal world application requests a service from a trusted application in the secure world using shared memory, the process involves the following steps with the GlobalPlatform TEE Client API functions:</p>
<ol>
<li>
<p>Initialize context: The normal world application initializes the TEE Client API context by calling the <code>TEEC_InitializeContext</code> function. This sets up the communication channel between the normal world application and the secure world.</p>
</li>
<li>
<p>Open a session: The normal world application opens a session with the trusted application by calling the <code>TEEC_OpenSession</code> function. This function requires the UUID of the trusted application, which uniquely identifies the service in the secure world.</p>
</li>
<li>
<p>Allocate or register shared memory: The normal world application allocates or registers shared memory to exchange data with the trusted application. This can be done using the <code>TEEC_AllocateSharedMemory</code> function, which allocates a new shared memory buffer, or the <code>TEEC_RegisterSharedMemory</code> function, which registers a pre-allocated memory buffer as shared memory.</p>
</li>
<li>
<p>Set shared memory parameters: Before invoking the command, the normal world application sets up the <code>TEEC_Operation</code> structure, which includes the parameters for the command. When using shared memory, one or more of the parameters should be of type <code>TEEC_MEMREF_*</code>, with a reference to the shared memory buffer allocated or registered in the previous step.</p>
</li>
<li>
<p>Invoke command: The normal world application sends the request for the service by invoking a command in the trusted application using the <code>TEEC_InvokeCommand</code> function. This function takes the command ID, which identifies the specific service or operation, and the <code>TEEC_Operation</code> structure, which includes the shared memory reference(s) and other parameters.</p>
</li>
<li>
<p>Process the response: After the trusted application in the secure world has executed the requested service, the normal world application processes the response, which may include data returned in the shared memory buffer(s) or an updated operation state.</p>
</li>
<li>
<p>Close the session: Once the normal world application has completed its interaction with the trusted application, it should close the session using the <code>TEEC_CloseSession</code> function. This releases resources associated with the session.</p>
</li>
<li>
<p>Release shared memory: After closing the session, the normal world application should release the allocated or registered shared memory using the <code>TEEC_ReleaseSharedMemory</code> function.</p>
</li>
<li>
<p>Finalize context: Finally, the normal world application should finalize the TEE Client API context using the <code>TEEC_FinalizeContext</code> function.</p>
</li>
</ol>
<p>By following these steps, a normal world application can request a service from a trusted application in the secure world using shared memory to exchange data, while maintaining the security and isolation provided by OP-TEE and Arm TrustZone technology.</p>
<hr />
<p><strong>Question:</strong> <code>[17:04]</code> Which functions are used by TA (trusted application) in the above process? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the process described above, the Trusted Application (TA) running in the secure world uses the following functions from the TEE Internal API to interact with the normal world application:</p>
<ol>
<li>
<p>TA_CreateEntryPoint: This function is called when the TA is loaded. It is used to perform initialization tasks specific to the TA, such as setting up initial resources or state.</p>
</li>
<li>
<p>TA_OpenSessionEntryPoint: This function is called when a new session is opened with the TA. It can be used to perform session-specific initialization tasks or to allocate session-specific resources.</p>
</li>
<li>
<p>TA_InvokeCommandEntryPoint: This function is called when the normal world application invokes a command in the TA using the TEEC_InvokeCommand function. The TA should implement this function to handle the specific command, process the input parameters (which may include shared memory references), and perform the requested operation.</p>
</li>
<li>
<p>TA_CloseSessionEntryPoint: This function is called when the session with the TA is closed. It can be used to perform session-specific cleanup tasks or to release session-specific resources.</p>
</li>
<li>
<p>TA_DestroyEntryPoint: This function is called when the TA is unloaded. It is used to perform cleanup tasks specific to the TA, such as releasing global resources or state.</p>
</li>
</ol>
<p>In addition to these entry point functions, the TA can use several other TEE Internal API functions to interact with shared memory and manage its resources:</p>
<ol>
<li>
<p>TEE_GetSharedMem: This function is used to get a pointer to the shared memory buffer in the TA&rsquo;s virtual address space, given a shared memory reference from the normal world.</p>
</li>
<li>
<p>TEE_CheckMemoryAccessRights: This function is used to check the access rights of a memory buffer, including shared memory, to ensure that the TA has the required permissions to read or write the buffer.</p>
</li>
<li>
<p>TEE_Malloc, TEE_Realloc, and TEE_Free: These functions are used to allocate, reallocate, and free memory within the TA&rsquo;s secure environment.</p>
</li>
</ol>
<p>By using these functions, the Trusted Application can interact with the normal world application, process the input parameters and shared memory buffers, and perform the requested operations while maintaining the security and isolation provided by OP-TEE and Arm TrustZone technology.</p>
<hr />
<p><strong>Question:</strong> <code>[17:06]</code> Are above functions defined in TEE standard? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, the functions mentioned above are defined in the GlobalPlatform TEE (Trusted Execution Environment) specifications, which provide standardized APIs for normal world applications and trusted applications to interact securely. These specifications aim to ensure compatibility and interoperability between different TEE implementations.</p>
<p>The functions for the normal world application, such as TEEC_InitializeContext, TEEC_OpenSession, and TEEC_InvokeCommand, are part of the GlobalPlatform TEE Client API, which is defined in the &ldquo;GlobalPlatform TEE Client API Specification.&rdquo;</p>
<p>The entry point functions for trusted applications, such as TA_CreateEntryPoint, TA_OpenSessionEntryPoint, and TA_InvokeCommandEntryPoint, as well as other TEE Internal API functions like TEE_Malloc and TEE_CheckMemoryAccessRights, are defined in the &ldquo;GlobalPlatform TEE Internal Core API Specification.&rdquo;</p>
<p>These standardized APIs allow developers to create secure applications that can run on different TEE implementations, including OP-TEE, while maintaining a consistent and secure interface between the normal world and the secure world.</p>
<p>You can find the GlobalPlatform TEE specifications on their website:</p>
<ol>
<li>TEE Client API Specification: https://globalplatform.org/specs-library/tee-client-api-specification/</li>
<li>TEE Internal Core API Specification: https://globalplatform.org/specs-library/tee-internal-core-api-specification/</li>
</ol>
<p>These documents provide detailed information on the functions, their parameters, and their expected behavior, which can be helpful for developers working with TEEs and trusted applications.</p>
<hr />
<h2>TEE.0328.md</h2>
<p><strong>Question:</strong> <code>[16:47]</code> How does a normal world application request a service in secure world? <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A normal world application can request a service in the secure world through a process called secure monitor call (SMC) or a similar mechanism, depending on the specific TEE implementation. The secure monitor call is used to transition from the normal world to the secure world, allowing the secure world to execute the requested service. The process typically involves several steps:</p>
<ol>
<li>
<p>Prepare data: The normal world application prepares the data to be sent to the secure world. This may include input parameters, context information, and the type of service being requested.</p>
</li>
<li>
<p>Issue the call: The normal world application issues a secure monitor call (SMC) or an equivalent mechanism to request the service from the secure world. This call typically includes information about the requested service and any necessary parameters.</p>
</li>
<li>
<p>Context switch: The processor switches from the normal world to the secure world, saving the current normal world context and transitioning to the secure world&rsquo;s execution environment.</p>
</li>
<li>
<p>Process the request: The secure world processes the request, performs the required operations, and generates a response. This may involve executing secure functions, accessing protected resources, or performing cryptographic operations.</p>
</li>
<li>
<p>Return to the normal world: Once the secure world has completed processing the request, it prepares the response and initiates a context switch back to the normal world. This involves restoring the saved normal world context and resuming normal world execution.</p>
</li>
<li>
<p>Process the response: The normal world application receives the response from the secure world and processes it accordingly. Depending on the requested service, this may involve updating application state, displaying information to the user, or initiating further actions.</p>
</li>
</ol>
<p>It is important to note that the specific mechanisms and steps for requesting a service in the secure world may vary depending on the TEE implementation being used. Some TEEs, such as ARM TrustZone, use the secure monitor call (SMC) as described above, while others, like Intel SGX, rely on specific instructions or APIs to interact with enclaves in the secure world. Regardless of the implementation, the general process involves preparing data, issuing a call, switching execution context, processing the request, and returning the response.</p>
<hr />
<p><strong>Question:</strong> <code>[16:49]</code> How does a normal world application request a service with shared memory in secure world? Please describe the process and give APIs of TEE. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In a Trusted Execution Environment (TEE), a normal world application may request a service in the secure world using shared memory for data exchange. The process involves allocating a memory buffer that can be accessed by both the normal world and the secure world, allowing for efficient and secure communication between the two. Here&rsquo;s an outline of the process:</p>
<ol>
<li>
<p>Allocate shared memory: The normal world application allocates a shared memory buffer that can be accessed by both the normal world and the secure world. In the GlobalPlatform TEE APIs, this can be done using the <code>TEEC_RegisterSharedMemory</code> function, which registers a memory buffer as shared memory.</p>
</li>
<li>
<p>Prepare data: The normal world application writes the input data and any necessary parameters into the shared memory buffer.</p>
</li>
<li>
<p>Issue the call: The normal world application issues a call to the secure world to request the service, providing a reference to the shared memory buffer as part of the call. In the GlobalPlatform TEE APIs, this can be done using the <code>TEEC_InvokeCommand</code> function, which sends a command to the secure world, along with any input parameters and shared memory references.</p>
</li>
<li>
<p>Context switch: The processor switches from the normal world to the secure world, saving the current normal world context and transitioning to the secure world&rsquo;s execution environment.</p>
</li>
<li>
<p>Process the request: The secure world processes the request, reads the input data from the shared memory buffer, performs the required operations, and writes the response back into the shared memory buffer.</p>
</li>
<li>
<p>Return to the normal world: Once the secure world has completed processing the request, it initiates a context switch back to the normal world. This involves restoring the saved normal world context and resuming normal world execution.</p>
</li>
<li>
<p>Process the response: The normal world application reads the response from the shared memory buffer and processes it accordingly.</p>
</li>
<li>
<p>Release shared memory: After the response has been processed, the normal world application releases the shared memory buffer. In the GlobalPlatform TEE APIs, this can be done using the <code>TEEC_ReleaseSharedMemory</code> function, which deregisters the shared memory buffer.</p>
</li>
</ol>
<p>It is important to note that the specific mechanisms, APIs, and steps for requesting a service using shared memory in the secure world may vary depending on the TEE implementation being used. The example provided above is based on the GlobalPlatform TEE APIs, which are widely used in the industry for TEE development. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different APIs and mechanisms for managing shared memory communication between the normal world and the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[16:51]</code> How does a normal world application request a service with shared memory in secure world? Please describe the process and give APIs of both worlds. <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>When a normal world application requests a service in the secure world using shared memory, the process typically involves allocating a memory buffer accessible by both worlds, transferring data between the two, and invoking the secure world service. Here&rsquo;s an outline of the process, including APIs for both worlds:</p>
<ol>
<li>
<p>Allocate shared memory: The normal world application allocates a shared memory buffer that can be accessed by both the normal world and the secure world. The specific API depends on the TEE implementation. For instance, in the GlobalPlatform TEE APIs, the normal world application would use the <code>TEEC_RegisterSharedMemory</code> function.</p>
</li>
<li>
<p>Prepare data: The normal world application writes the input data and any necessary parameters into the shared memory buffer.</p>
</li>
<li>
<p>Issue the call: The normal world application issues a call to the secure world to request the service, providing a reference to the shared memory buffer as part of the call. In the GlobalPlatform TEE APIs, the normal world application would use the <code>TEEC_InvokeCommand</code> function.</p>
</li>
<li>
<p>Secure world handler: The secure world should have a handler registered to process requests from the normal world. This handler is responsible for parsing the shared memory buffer, performing the required operations, and writing the response back into the shared memory buffer. The specific API for registering the handler depends on the TEE implementation. In ARM TrustZone, for example, this might involve registering a secure world function with the SMC handler.</p>
</li>
<li>
<p>Context switch: The processor switches from the normal world to the secure world, saving the current normal world context and transitioning to the secure world&rsquo;s execution environment.</p>
</li>
<li>
<p>Process the request: The secure world processes the request, reads the input data from the shared memory buffer, performs the required operations, and writes the response back into the shared memory buffer.</p>
</li>
<li>
<p>Return to the normal world: Once the secure world has completed processing the request, it initiates a context switch back to the normal world. This involves restoring the saved normal world context and resuming normal world execution.</p>
</li>
<li>
<p>Process the response: The normal world application reads the response from the shared memory buffer and processes it accordingly.</p>
</li>
<li>
<p>Release shared memory: After the response has been processed, the normal world application releases the shared memory buffer. In the GlobalPlatform TEE APIs, the normal world application would use the <code>TEEC_ReleaseSharedMemory</code> function.</p>
</li>
</ol>
<p>It&rsquo;s essential to note that the specific mechanisms, APIs, and steps for requesting a service using shared memory in the secure world may vary depending on the TEE implementation being used. The examples provided above are based on the GlobalPlatform TEE APIs, which are widely used in the industry for TEE development. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different APIs and mechanisms for managing shared memory communication between the normal world and the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[17:12]</code> Could you please draw a sequence diagram for my above two questions? <code>(TEE.0328.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Unfortunately, as a text-based AI language model, I am unable to draw diagrams directly. However, I can describe the sequence of events and interactions between the normal world application and the trusted application in the secure world, which you can use to create your own sequence diagram.</p>
<ol>
<li>The normal world application initializes a TEE context (<code>TEEC_InitializeContext</code>).</li>
<li>The normal world application opens a session with the trusted application (<code>TEEC_OpenSession</code>).</li>
<li>The normal world application allocates a shared memory buffer (<code>TEEC_RegisterSharedMemory</code>).</li>
<li>The normal world application writes input data to the shared memory buffer.</li>
<li>The normal world application invokes a command in the trusted application, passing a reference to the shared memory buffer (<code>TEEC_InvokeCommand</code>).</li>
</ol>
<p>At this point, the processor switches to the secure world:</p>
<ol start="6">
<li>The trusted application processes the request (<code>TA_InvokeCommandEntryPoint</code>).
   a. The trusted application reads input data from the shared memory buffer.
   b. The trusted application performs the requested operations.
   c. The trusted application writes the response back to the shared memory buffer.</li>
</ol>
<p>The processor then switches back to the normal world:</p>
<ol start="7">
<li>The normal world application reads the response from the shared memory buffer.</li>
<li>The normal world application releases the shared memory buffer (<code>TEEC_ReleaseSharedMemory</code>).</li>
<li>The normal world application closes the session with the trusted application (<code>TEEC_CloseSession</code>).</li>
<li>The normal world application finalizes the TEE context (<code>TEEC_FinalizeContext</code>).</li>
</ol>
<p>You can use this sequence of events to create a diagram illustrating the interactions between the normal world application, the TEE system, and the trusted application in the secure world.</p>
<hr />
    </article>
  </body>
</html>
