<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
    color:#333;
    background:#fff;
}

body .markdown-body {
    padding: 45px;
    word-wrap: break-word;
}

.markdown-body .octicon-link:before {
  font: normal normal normal 16px/1 octicons-link;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  content: '\f05c';
  vertical-align: middle;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
</style><title>2023-04-11</title></head><body><article class="markdown-body"><h1 id="user-content-2023-04-11"><a class="heading-link" href="#2023-04-11">2023-04-11<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<p>Created: 2023-11-08 12:49:09</p>
<h1 id="user-content-questions"><a class="heading-link" href="#questions">Questions<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<ul>
<li>DRM <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[08:58]</code> How is SMAF used in DRM? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[10:00]</code> What is Clear Key? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Memory <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[08:59]</code> Is SMAF of OP-TEE? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>TrustZone &amp; HSM <code>(230329.TrustZone.yaml)</code>
<ul>
<li>
<code>[14:23]</code> Is HSM cost than TrustZone? <code>(TrustZone.0329.md)</code>
</li>
<li>
<code>[14:25]</code> Is HSM more performance than ARM TrustZone in crypto operations? <code>(TrustZone.0329.md)</code>
</li>
<li>
<code>[14:27]</code> What are security certifications of TrustZone? <code>(TrustZone.0329.md)</code>
</li>
</ul>
</li>
<li>Static TA and Dynamic TA <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[18:46]</code> Which privilege levels do static TA and dynamic TA run in? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Multi-Thread &amp; Multi-Process <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[18:49]</code> Is a TA assigned to only one thread? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Boot <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[21:07]</code> Can I reset OP-TEE at run-time? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[21:19]</code> Where does OP-TEE initialize secondary cores? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[21:23]</code> Below code comes from part 1 of entry_a64.S of OP-TEE <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[21:24]</code> Below code comes from part 2 of entry_a64.S of OP-TEE <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[21:25]</code> Where to set up secondary cores in the given code? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[21:48]</code> Where to reset primary core in the given code? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[21:58]</code> When to enable secondary cores in OP-TEE? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:11]</code> Please list functions and macros in entry_a64.S that I give you before. <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:18]</code> Please list functions called in entry_a64.S that I give you before. <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:37]</code> What is psci? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:40]</code> Who to call vector_cpu_on_entry? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:46]</code> What does vector_cpu_on_entry do with respect to OP-TEE? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[23:10]</code> What are difference boot of OP-TEE between AArch64 and AArch32? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>FF-A, TF-A, and TrustZone <code>(230409.FF-A.yaml)</code>
<ul>
<li>
<code>[21:56]</code> When to enable secondary cores? <code>(FF-A.0409.md)</code>
</li>
</ul>
</li>
<li>TF-A <code>(230410.Arm.yaml)</code>
<ul>
<li>
<code>[22:59]</code> Which types of ARM cores is supported by TF-A? <code>(FF-A.0409.md)</code>
</li>
<li>
<code>[23:05]</code> Must AArch64 have TF-A? <code>(FF-A.0409.md)</code>
</li>
</ul>
</li>
<li>Types of ARM CPU <code>(230410.Arm.yaml)</code>
<ul>
<li>
<code>[23:15]</code> What are types of ARM CPU? Please also describe them in a table with 32 bits and 64 bits. <code>(Arm.0410.md)</code>
</li>
<li>
<code>[23:18]</code> Does Armv8-A has 32 bits? <code>(Arm.0410.md)</code>
</li>
<li>
<code>[23:19]</code> Does Armv7-A has 64 bits? <code>(Arm.0410.md)</code>
</li>
</ul>
</li>
<li>Ch 2 - Introduction <code>(230409.FF-A.yaml)</code>
<ul>
<li>
<code>[23:23]</code> What is "Arm A-profile"? <code>(FF-A.0409.md)</code>
</li>
<li>
<code>[23:24]</code> Does "Arm Firmware Framework for Arm A-profile" document is only about Cortex-A? <code>(FF-A.0409.md)</code>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="user-content-chats"><a class="heading-link" href="#chats">Chats<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<ul>
<li>OP-TEE.0327.md
<ul>
<li>
<code>[21:51]</code> What is the set_sp macro? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:08]</code> Please list functions and macros in entry_a64.S <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:10]</code> Please list functions and macros in entry_a64.S that I sent you before. <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[22:42]</code> Who to call vector_cpu_on_entry with OP-TEE? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>FF-A.0409.md
<ul>
<li>
<code>[22:58]</code> Does TF-A support Arm32 or Arm64? <code>(FF-A.0409.md)</code>
</li>
<li>
<code>[23:01]</code> Does Armv7-A has 64 bits? <code>(FF-A.0409.md)</code>
</li>
<li>
<code>[23:13]</code> Does Armv8-A has 32 bits? <code>(FF-A.0409.md)</code>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="user-content-q--a"><a class="heading-link" href="#q--a">Q &amp; A<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<h2 id="user-content-drm-230327op-teeyaml"><a class="heading-link" href="#drm-230327op-teeyaml">DRM <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[08:58]</code> How is SMAF used in DRM? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The Secure Memory Allocator Framework (SMAF) is a framework that can be used in conjunction with Digital Rights Management (DRM) systems to provide an additional layer of security for handling sensitive data. In a DRM context, sensitive data can include encryption keys, decrypted content, or any other data that must be protected from unauthorized access.</p>
<p>SMAF is designed to provide secure memory allocation and management in a system. It allocates memory from a secure memory pool that is reserved for trusted applications, such as DRM systems, and is inaccessible to the normal world or untrusted applications. This helps prevent unauthorized access, tampering, or copying of the sensitive data, ensuring that the content remains protected.</p>
<p>In a typical DRM implementation using SMAF:</p>
<ol>
<li>A trusted application, such as a DRM module, requests secure memory allocation from the SMAF.</li>
<li>The SMAF allocates memory from the secure memory pool and provides a handle or reference to the trusted application.</li>
<li>The trusted application uses the allocated secure memory to store sensitive data, such as decryption keys or decrypted content.</li>
<li>The sensitive data remains protected within the secure memory, preventing unauthorized access from the normal world or untrusted applications.</li>
</ol>
<p>By using SMAF, DRM systems can ensure that sensitive data is securely stored and managed, reducing the risk of unauthorized access, tampering, or copying of protected content.</p>
<hr>
<p><strong>Question:</strong> <code>[10:00]</code> What is Clear Key? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Clear Key is a simple, non-proprietary DRM (Digital Rights Management) system defined by the W3C (World Wide Web Consortium) as part of the Encrypted Media Extensions (EME) specification. EME is a standard interface for using DRM within web browsers to protect copyrighted content during streaming.</p>
<p>Clear Key is essentially a key management system that allows for the decryption of media content using clear-text (unencrypted) cryptographic keys. The primary purpose of Clear Key is to serve as a reference implementation for testing and development purposes. It is not meant to be a robust DRM solution for commercial use, as it lacks the sophisticated security features offered by other DRM systems, such as Google's Widevine or Microsoft's PlayReady.</p>
<p>In summary, Clear Key is a simple and open DRM system used mainly for testing and development of EME-supported web browsers and applications.</p>
<hr>
<h2 id="user-content-memory-230327op-teeyaml"><a class="heading-link" href="#memory-230327op-teeyaml">Memory <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[08:59]</code> Is SMAF of OP-TEE? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, SMAF is a part of the OP-TEE (Open Portable Trusted Execution Environment) framework. OP-TEE is an open-source implementation of the TEE (Trusted Execution Environment) for ARM processors, which provides a secure environment for running trusted applications.</p>
<p>SMAF, or Secure Memory Allocator Framework, is a component within the OP-TEE framework that enables the secure allocation and management of memory for trusted applications. It helps protect sensitive data, such as encryption keys and decrypted content, from unauthorized access in the normal world or by untrusted applications.</p>
<p>By integrating SMAF into OP-TEE, the framework can provide a higher level of security for applications, such as DRM systems, that require secure memory management for their sensitive data.</p>
<hr>
<h2 id="user-content-trustzone--hsm-230329trustzoneyaml"><a class="heading-link" href="#trustzone--hsm-230329trustzoneyaml">TrustZone &amp; HSM <code>(230329.TrustZone.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[14:23]</code> Is HSM cost than TrustZone? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>It's difficult to make a direct comparison between the cost of a hardware security module (HSM) and TrustZone, as they serve different purposes and have different implementations. Here are some points to consider:</p>
<ol>
<li>
<p>HSM: A standalone, tamper-resistant hardware device that provides secure key storage, cryptographic processing, and other security functions. HSMs are typically used in high-security environments, like financial institutions, where the protection of sensitive information is crucial. They can be relatively expensive due to their robust security features and the fact that they are dedicated hardware devices.</p>
</li>
<li>
<p>TrustZone: A hardware-based security feature in Arm processors that provides isolation between the Secure World and the Normal World. TrustZone is integrated into Arm processors, so the cost is essentially built into the processor itself. TrustZone may provide a lower level of security compared to an HSM, but it's generally more cost-effective since it's already a part of the processor.</p>
</li>
</ol>
<p>In summary, HSMs tend to be more expensive than TrustZone because they are dedicated, standalone hardware devices with more robust security features. TrustZone, on the other hand, is a built-in security feature in Arm processors and is generally more cost-effective. However, the level of security provided by TrustZone may not be as high as that of an HSM. The choice between the two will depend on the specific security requirements and budget of a given project or organization.</p>
<hr>
<p><strong>Question:</strong> <code>[14:25]</code> Is HSM more performance than ARM TrustZone in crypto operations? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In general, hardware security modules (HSMs) are designed to be more performant in cryptographic operations compared to ARM TrustZone. This is due to several reasons:</p>
<ol>
<li>
<p>Dedicated hardware: HSMs are standalone devices specifically designed for cryptographic operations, including secure key storage, encryption, decryption, and signing. They have dedicated cryptographic accelerators and coprocessors optimized for these tasks, leading to better performance.</p>
</li>
<li>
<p>Reduced overhead: TrustZone, while providing a secure environment for cryptographic operations, still shares the same processor with the normal world. This sharing can lead to resource contention and increased overhead, potentially affecting performance.</p>
</li>
<li>
<p>Tamper resistance: HSMs are designed with robust tamper resistance in mind, including active measures to prevent unauthorized access or tampering. TrustZone, while providing a level of isolation between the secure and normal worlds, may not offer the same level of physical tamper resistance.</p>
</li>
<li>
<p>Scalability: HSMs can be used in a cluster or load-balanced configuration to handle large-scale cryptographic operations, providing better performance and throughput.</p>
</li>
</ol>
<p>However, it's important to note that the specific performance difference between HSMs and TrustZone in cryptographic operations will depend on the implementation details, workload, and hardware configuration. For some use cases, TrustZone may provide sufficient performance, while in other scenarios, an HSM may be necessary to meet strict performance and security requirements.</p>
<hr>
<p><strong>Question:</strong> <code>[14:27]</code> What are security certifications of TrustZone? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>ARM TrustZone technology provides a foundation for building secure systems, but the security certifications depend on the specific implementations and products built on top of it. Different implementations may undergo different security evaluation processes and achieve various certifications based on their design, features, and target markets.</p>
<p>Some common security certifications that TrustZone-based products can achieve include:</p>
<ol>
<li>
<p>Common Criteria (CC): TrustZone-based implementations can be certified under Common Criteria, an international standard (ISO/IEC 15408) for computer security certification. The level of assurance for a specific product is determined by its Evaluation Assurance Level (EAL), ranging from EAL1 (lowest) to EAL7 (highest).</p>
</li>
<li>
<p>FIPS 140-2/140-3: TrustZone-based products can also be certified under the Federal Information Processing Standards (FIPS) 140-2 or 140-3, which are U.S. government security standards for cryptographic modules. These standards have various security levels, with Level 1 providing the lowest security and Level 4 providing the highest security.</p>
</li>
<li>
<p>GlobalPlatform: Some TrustZone implementations, particularly those involving secure elements or Trusted Execution Environments (TEEs) such as OP-TEE, can be certified by GlobalPlatform. GlobalPlatform sets security requirements and evaluates products for secure elements, TEEs, and other secure components.</p>
</li>
<li>
<p>Payment Card Industry (PCI): TrustZone-based implementations targeting payment systems may achieve PCI compliance, ensuring that the product meets the security standards for processing, storing, or transmitting credit card information.</p>
</li>
</ol>
<p>Note that achieving these certifications depends on the specific product, its implementation, and the security features provided. It's essential to verify the certifications of a TrustZone-based product depending on the use case and the required security level.</p>
<hr>
<h2 id="user-content-static-ta-and-dynamic-ta-230327op-teeyaml"><a class="heading-link" href="#static-ta-and-dynamic-ta-230327op-teeyaml">Static TA and Dynamic TA <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[18:46]</code> Which privilege levels do static TA and dynamic TA run in? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the context of ARM TrustZone and OP-TEE, there are two types of Trusted Applications (TAs): static and dynamic.</p>
<p>Static TAs are part of the OP-TEE OS itself, meaning they are compiled and linked together with the OP-TEE OS, and run at the same privilege level as the OP-TEE OS, which is Secure EL1 (Secure Exception Level 1) in the ARMv8 architecture.</p>
<p>Dynamic TAs, on the other hand, are standalone binaries that are loaded and executed by the OP-TEE OS on-demand. They run at a lower privilege level compared to the OP-TEE OS. In the ARMv8 architecture, dynamic TAs run at Secure EL0 (Secure Exception Level 0).</p>
<p>By running dynamic TAs at a lower privilege level, the system can provide better isolation between the TAs themselves and the OP-TEE OS, thereby improving security.</p>
<hr>
<h2 id="user-content-multi-thread--multi-process-230327op-teeyaml"><a class="heading-link" href="#multi-thread--multi-process-230327op-teeyaml">Multi-Thread &amp; Multi-Process <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[18:49]</code> Is a TA assigned to only one thread? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE, a Trusted Application (TA) can be single or multi-threaded, depending on its design and implementation. However, OP-TEE employs a single-threaded model by default, which means that each TA instance is typically associated with one thread, and there is no concurrency within a single instance of the TA.</p>
<p>If an application requires concurrent access to the TA, multiple instances of the TA can be created. Each instance runs in a separate thread, and the TA developer must take care of synchronization and shared resources within the TA code.</p>
<p>In summary, a TA is not inherently limited to a single thread, but the default behavior in OP-TEE is to use one thread per TA instance. If the TA is designed to support multiple threads, it can be done, but the developer must handle synchronization and shared resources carefully.</p>
<hr>
<h2 id="user-content-boot-230327op-teeyaml"><a class="heading-link" href="#boot-230327op-teeyaml">Boot <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[21:07]</code> Can I reset OP-TEE at run-time? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>There isn't a direct mechanism to reset only the OP-TEE (Trusted Execution Environment) at runtime without affecting the rest of the system. OP-TEE runs alongside the Normal World operating system, and both share the same hardware resources.</p>
<p>Resetting the OP-TEE runtime would essentially require resetting the entire system, which would include the Normal World operating system (such as Linux). This is because OP-TEE interacts with the Normal World through shared memory and interrupt handling, and resetting OP-TEE without restarting the entire system may lead to undefined behavior or security vulnerabilities.</p>
<p>If you need to reset the state of a Trusted Application running within OP-TEE, you can unload the TA and reload it, essentially resetting the TA's state. However, this approach only resets the specific TA and not the entire OP-TEE environment.</p>
<hr>
<p><strong>Question:</strong> <code>[21:19]</code> Where does OP-TEE initialize secondary cores? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE initializes secondary cores during its boot process. The initialization happens in the <code>optee_os</code> codebase, which is the core component of OP-TEE. Specifically, the initialization can be found in the <code>core/arch/arm/kernel/</code> directory.</p>
<p>For ARM platforms, the file <code>core/arch/arm/kernel/entry_a32.S</code> (for 32-bit systems) or <code>core/arch/arm/kernel/entry_a64.S</code> (for 64-bit systems) contains the assembly code responsible for the secondary core initialization.</p>
<p>Secondary core initialization consists of the following steps:</p>
<ol>
<li>Setup the core's stack pointer.</li>
<li>Enable the core's caches and MMU.</li>
<li>Initialize the core's GIC (Generic Interrupt Controller) interface.</li>
<li>Jump to the C function <code>__thread_std_smc_entry()</code> which handles the core's SMC (Secure Monitor Call) entry.</li>
</ol>
<p>The actual boot process of the secondary cores is platform-specific and depends on the hardware and the bootloader used. In general, when the primary core starts the OP-TEE, it initializes the secondary cores, and they are put into a waiting state until they receive a wake-up event. The primary core is responsible for configuring and releasing the secondary cores from their waiting state.</p>
<hr>
<p><strong>Question:</strong> <code>[21:23]</code> Below code comes from part 1 of entry_a64.S of OP-TEE <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> <code>[21:24]</code> Below code comes from part 2 of entry_a64.S of OP-TEE <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> <code>[21:25]</code> Where to set up secondary cores in the given code? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the given code, the secondary cores setup is handled by the <code>cpu_on_handler</code> function. This function is responsible for preparing the secondary core when it is powered on. Here's an overview of the <code>cpu_on_handler</code> function:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">FUNC cpu_on_handler </span><span class="pl-s1">,</span><span class="pl-en"> :</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x19</span><span class="pl-s1">,</span><span class="pl-en"> x0</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x20</span><span class="pl-s1">,</span><span class="pl-en"> x1</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x21</span><span class="pl-s1">,</span><span class="pl-en"> x30</span>

<span class="pl-en">    adr	x0</span><span class="pl-s1">,</span><span class="pl-en"> reset_vect_table</span>
<span class="pl-en">    msr	vbar_el1</span><span class="pl-s1">,</span><span class="pl-en"> x0</span>
<span class="pl-en">    isb</span>

<span class="pl-en">    set_sctlr_el1</span>
<span class="pl-en">    isb</span>

<span class="pl-en">    /</span><span class="pl-s1">*</span><span class="pl-en"> Enable aborts now th</span><span class="pl-c1">at</span> <span class="pl-en">we can receive exceptions </span><span class="pl-s1">*</span><span class="pl-en">/</span>
<span class="pl-en">    msr	daifclr</span><span class="pl-s1">,</span><span class="pl-en"> #DAIFBIT_ABT</span>

<span class="pl-en">    </span><span class="pl-v">bl</span><span class="pl-en">	__get_core_pos</span>
<span class="pl-en">    </span><span class="pl-v">bl</span><span class="pl-en">	enable_mmu</span>

<span class="pl-en">    /</span><span class="pl-s1">*</span><span class="pl-en"> Setup SP_EL0 </span><span class="pl-k">and</span><span class="pl-en"> SP_EL1</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">SP</span><span class="pl-en"> will be set to SP_EL0 </span><span class="pl-s1">*</span><span class="pl-en">/</span>
<span class="pl-en">    set_sp</span>

<span class="pl-en">#ifdef CFG_MEMTAG</span>
<span class="pl-en">    init_memtag_per_</span><span class="pl-c1">cpu</span>
<span class="pl-en">#endif</span>
<span class="pl-en">#ifdef CFG_CORE_PAUTH</span>
<span class="pl-en">    init_pauth_per_</span><span class="pl-c1">cpu</span>
<span class="pl-en">#endif</span>

<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x0</span><span class="pl-s1">,</span><span class="pl-en"> x19</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x1</span><span class="pl-s1">,</span><span class="pl-en"> x20</span>
<span class="pl-en">#ifdef CFG_CORE_FFA</span>
<span class="pl-en">    </span><span class="pl-v">bl</span><span class="pl-en">	boot_cpu_on_handler</span>
<span class="pl-en">    b	thread_ffa_msg_wait</span>
<span class="pl-en">#else</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x30</span><span class="pl-s1">,</span><span class="pl-en"> x21</span>
<span class="pl-en">    b	boot_cpu_on_handler</span>
<span class="pl-en">#endif</span>
<span class="pl-en">END_FUNC cpu_on_handler</span></pre></div>
<p>The <code>cpu_on_handler</code> function does the following:</p>
<ol>
<li>Sets up the exception vector table by loading the address of <code>reset_vect_table</code> into the <code>vbar_el1</code> register.</li>
<li>Configures the System Control Register (<code>sctlr_el1</code>) and enables aborts to receive exceptions.</li>
<li>Gets the core position and enables the MMU.</li>
<li>Sets up the stack pointers for the current Exception Level (EL) by calling <code>set_sp</code>.</li>
<li>Initializes per-core features like memory tagging and pointer authentication if they are enabled (CFG_MEMTAG, CFG_CORE_PAUTH).</li>
<li>Calls the <code>boot_cpu_on_handler</code> function to complete the setup for the secondary core.</li>
</ol>
<p>After the setup is complete, the secondary core will either wait for a Fast Function call (in case of CFG_CORE_FFA) or continue with the execution of the <code>boot_cpu_on_handler</code> function.</p>
<hr>
<p><strong>Question:</strong> <code>[21:48]</code> Where to reset primary core in the given code? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the given code, there's no specific mention of a function or a code block that explicitly resets the primary core. However, if you need to reset the primary core, you can create a custom function that will perform the necessary actions, such as disabling interrupts and performing a soft reset.</p>
<p>You could create a function like this:</p>
<div class="highlight highlight-source-c"><pre><span class="pl-smi">void</span> <span class="pl-en">reset_primary_core</span>(<span class="pl-smi">void</span>)
{
    <span class="pl-c">// Disable interrupts</span>
    <span class="pl-en">local_irq_disable</span>();
    <span class="pl-en">local_fiq_disable</span>();

    <span class="pl-c">// Perform a soft reset</span>
    <span class="pl-smi">uintptr_t</span> <span class="pl-s1">reset_address</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-c">// Replace 0 with the address of the reset handler for your system</span>
    <span class="pl-smi">void</span> (<span class="pl-c1">*</span><span class="pl-s1">reset_handler</span>)(<span class="pl-smi">void</span>) <span class="pl-c1">=</span> (<span class="pl-smi">void</span> (<span class="pl-c1">*</span>)(<span class="pl-smi">void</span>))<span class="pl-s1">reset_address</span>;
    <span class="pl-en">reset_handler</span>();
}</pre></div>
<p>Keep in mind that the exact process for resetting the primary core depends on your system's architecture and hardware. The example above is just a basic idea of how you could approach resetting the primary core. You will need to consult your system's documentation and adapt the code accordingly.</p>
<hr>
<p><strong>Question:</strong> <code>[21:58]</code> When to enable secondary cores in OP-TEE? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE (Open Portable Trusted Execution Environment), secondary cores are typically enabled during the boot process, after the primary core has completed initialization tasks, including setting up secure memory, initializing OP-TEE, and launching the Rich Execution Environment (REE).</p>
<p>To enable secondary cores in OP-TEE, follow these steps:</p>
<ol>
<li>
<p>Primary core initialization: The primary core initializes OP-TEE and other necessary system components. It sets up the secure memory, initializes the OP-TEE OS, and starts the REE (e.g., Linux kernel).</p>
</li>
<li>
<p>Secondary core synchronization: The primary core waits for secondary cores to reach a synchronization point, usually through a spin loop. Secondary cores wait for a signal from the primary core to continue the boot process.</p>
</li>
<li>
<p>Signal secondary cores: Once the primary core finishes the initialization process, it signals the secondary cores to continue the boot process. This can be done by writing a value to a shared memory location or using hardware-specific mechanisms.</p>
</li>
<li>
<p>Secondary core initialization: Secondary cores initialize their local data structures and set up their own exception handlers. They also initialize their stack pointers and register with the OP-TEE OS.</p>
</li>
<li>
<p>Secondary cores enter OP-TEE: Secondary cores enter the OP-TEE OS and start executing secure tasks.</p>
</li>
</ol>
<p>The exact implementation details of enabling secondary cores may vary depending on the platform, hardware, and OP-TEE version. The steps mentioned above provide a general guideline for the process. To understand the specifics for your platform, refer to the platform-specific documentation and code available in the OP-TEE source tree.</p>
<hr>
<p><strong>Question:</strong> <code>[22:11]</code> Please list functions and macros in entry_a64.S that I give you before. <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Based on the code you provided earlier, here is a list of functions and macros in entry_a64.S:</p>
<p>Functions:</p>
<ol>
<li>_start</li>
<li>relocate (if CFG_CORE_ASLR is defined)</li>
<li>enable_mmu</li>
<li>cpu_on_handler</li>
<li>unhandled_cpu</li>
<li>reset_vect_table</li>
</ol>
<p>Macros:</p>
<ol>
<li>check_vector_size</li>
<li>BTI (if defined)</li>
</ol>
<p>If you have any questions or need further information about these functions or macros, please let me know!</p>
<hr>
<p><strong>Question:</strong> <code>[22:18]</code> Please list functions called in entry_a64.S that I give you before. <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Here is a list of functions called in the entry_a64.S code you provided earlier:</p>
<ol>
<li>boot_init_memtag (if CFG_MEMTAG is defined)</li>
<li>get_aslr_seed (if CFG_CORE_ASLR is defined)</li>
<li>core_init_mmu_map</li>
<li>__get_core_pos</li>
<li>enable_mmu</li>
<li>console_init (if CFG_CORE_ASLR is defined)</li>
<li>core_mmu_set_default_prtn_tbl (if CFG_NS_VIRTUALIZATION is defined)</li>
<li>boot_init_primary_early</li>
<li>init_memtag_per_cpu (if CFG_MEMTAG is defined)</li>
<li>thread_get_core_local</li>
<li>boot_init_primary_late</li>
<li>init_pauth_per_cpu (if CFG_CORE_PAUTH is defined)</li>
<li>plat_get_random_stack_canary (if _CFG_CORE_STACK_PROTECTOR is defined)</li>
<li>dcache_cleaninv_range</li>
<li>thread_clr_boot_thread (if CFG_NS_VIRTUALIZATION is not defined)</li>
<li>thread_spmc_register_secondary_ep (if CFG_CORE_FFA is defined)</li>
<li>thread_ffa_msg_wait (if CFG_CORE_FFA is defined)</li>
<li>boot_cpu_on_handler (if CFG_CORE_FFA is not defined)</li>
<li>panic_at_smc_return (if CFG_CORE_FFA is not defined)</li>
</ol>
<p>These are the functions called in the provided entry_a64.S file.</p>
<hr>
<p><strong>Question:</strong> <code>[22:37]</code> What is psci? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>PSCI (Power State Coordination Interface) is a standardized interface for power management in ARM-based systems, specifically targeting multicore and multiprocessor SoCs (System on a Chip). The PSCI specification is developed and maintained by ARM and provides a common API for software running on ARM-based systems to control power states of CPUs and the system as a whole.</p>
<p>PSCI enables software layers, such as operating systems and hypervisors, to manage the power state of individual CPU cores and clusters of cores, as well as to perform system-level power management tasks, such as system suspend and resume. The PSCI interface is typically implemented in firmware and is accessible to the software layers through a defined set of SMC (Secure Monitor Call) instructions.</p>
<p>Some common PSCI functions include:</p>
<ol>
<li>CPU_ON: Used to power on a specific CPU core.</li>
<li>CPU_OFF: Powers off the calling CPU core.</li>
<li>CPU_SUSPEND: Suspends the calling CPU core.</li>
<li>CPU_RESUME: Resumes a suspended CPU core.</li>
<li>SYSTEM_SUSPEND: Suspends the entire system.</li>
<li>SYSTEM_RESET: Performs a system reset.</li>
<li>SYSTEM_OFF: Powers off the entire system.</li>
</ol>
<p>PSCI allows for better coordination of power management across different cores and system components, which is essential for efficient energy usage and optimized performance in modern ARM-based systems.</p>
<hr>
<p><strong>Question:</strong> <code>[22:40]</code> Who to call vector_cpu_on_entry? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>vector_cpu_on_entry</code> is a function that is typically called when a CPU core is powered on in the context of an ARM-based system using PSCI for power management. The function is usually defined in the low-level firmware, such as ARM Trusted Firmware (ATF) or U-Boot.</p>
<p>To call <code>vector_cpu_on_entry</code>, you will need to use the PSCI interface. The <code>CPU_ON</code> PSCI function is used to power on a specific CPU core, and it's usually called by the operating system or another higher-level software component that manages power states of the CPU cores.</p>
<p>Here's an example of how you might call the <code>CPU_ON</code> function using PSCI:</p>
<ol>
<li>Prepare the necessary arguments, such as the target CPU's MPIDR (Multiprocessor Affinity Register) and the entry point address of the <code>vector_cpu_on_entry</code> function.</li>
<li>Issue an SMC (Secure Monitor Call) instruction with the appropriate PSCI function ID for <code>CPU_ON</code> and the prepared arguments.</li>
</ol>
<p>Please note that the actual implementation details will depend on your specific system configuration and the software components you are using. The operating system, hypervisor, or other system software components usually take care of calling the PSCI <code>CPU_ON</code> function and setting up the necessary entry points. As a developer, you typically don't need to call the <code>vector_cpu_on_entry</code> function directly.</p>
<hr>
<p><strong>Question:</strong> <code>[22:46]</code> What does vector_cpu_on_entry do with respect to OP-TEE? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>vector_cpu_on_entry</code> is not a specific function in OP-TEE. However, I believe you are referring to a generic concept of an entry point for secondary cores in a multi-core system.</p>
<p>In OP-TEE, the entry point for secondary cores is defined in <code>core/arch/arm/kernel/entry_a64.S</code> (for ARMv8-A) or <code>core/arch/arm/kernel/entry_a32.S</code> (for ARMv7-A) depending on the architecture. The entry point function is named <code>__secondary_init</code> for both ARMv8-A and ARMv7-A architectures.</p>
<p>When a secondary core is powered on in a multi-core system, the ATF (ARM Trusted Firmware) handles the process and sets up the appropriate entry points for both the non-secure world (e.g., the operating system) and the secure world (e.g., OP-TEE). The secondary core then starts executing the OP-TEE code at the <code>__secondary_init</code> entry point in the secure world.</p>
<p>The <code>__secondary_init</code> function performs the following tasks:</p>
<ol>
<li>Initialize the secondary core's CPU registers.</li>
<li>Set up the MMU and configure the memory map.</li>
<li>Call <code>generic_entry_a64</code> (for ARMv8-A) or <code>generic_entry_a32</code> (for ARMv7-A) to perform generic initialization, such as setting up the stack, enabling interrupts, and initializing the core's private GIC (Generic Interrupt Controller) interface.</li>
<li>Call <code>thread_init_per_cpu</code> to initialize the per-CPU data structures.</li>
<li>Enter the main scheduler loop by calling <code>thread_std_smc_entry</code> (for ARMv8-A) or <code>thread_std_svc_entry</code> (for ARMv7-A).</li>
</ol>
<p>After these steps, the secondary core is ready to execute secure tasks in OP-TEE along with the primary core.</p>
<hr>
<p><strong>Question:</strong> <code>[23:10]</code> What are difference boot of OP-TEE between AArch64 and AArch32? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE supports both AArch64 (ARMv8-A) and AArch32 (ARMv7-A) architectures. While the overall boot process is similar for both, there are some differences due to the architectural distinctions. Here are the main differences in the boot process of OP-TEE between AArch64 and AArch32:</p>
<ol>
<li>
<p><strong>Entry point</strong>: The entry point for the primary core is different for AArch64 and AArch32. In AArch64, it's defined in <code>core/arch/arm/kernel/entry_a64.S</code>, while in AArch32, it's defined in <code>core/arch/arm/kernel/entry_a32.S</code>.</p>
</li>
<li>
<p><strong>Register usage</strong>: AArch64 and AArch32 have different register usage conventions. AArch64 has 31 general-purpose registers (X0-X30), while AArch32 has 16 general-purpose registers (R0-R15). The register naming and usage in the assembly code for these architectures will differ.</p>
</li>
<li>
<p><strong>MMU setup</strong>: AArch64 uses a different memory translation scheme compared to AArch32. Consequently, the MMU configuration code in <code>core/arch/arm/mm/core_mmu_lpae.c</code> (for AArch64) and <code>core/arch/arm/mm/core_mmu_v7.c</code> (for AArch32) differ in setting up the translation tables and configuring the memory attributes.</p>
</li>
<li>
<p><strong>Exception levels</strong>: AArch64 introduces Exception Levels (EL0-EL3) that define different privilege levels for software execution. AArch32 uses the traditional ARM privilege levels (User, FIQ, IRQ, Supervisor, Abort, and Undefined) instead. The exception handling and context switching code will differ between the two architectures due to this distinction.</p>
</li>
<li>
<p><strong>Interrupt handling</strong>: AArch64 uses the GICv3 interrupt controller, while AArch32 typically uses the GICv2 interrupt controller. The initialization and handling of interrupts will differ between the two architectures due to the differences in GIC versions.</p>
</li>
<li>
<p><strong>Function calling convention</strong>: AArch64 and AArch32 have different function calling conventions. For example, AArch64 passes the first eight arguments in registers X0-X7, while AArch32 passes arguments using registers R0-R3 and the stack. The assembly code for function calls and stack frame setup will differ between the two architectures.</p>
</li>
</ol>
<p>Despite these differences, the high-level boot process and functionality of OP-TEE remain consistent between AArch64 and AArch32. The architectural differences are primarily reflected in the low-level implementation details, such as register usage, memory management, and exception handling.</p>
<hr>
<h2 id="user-content-ff-a-tf-a-and-trustzone-230409ff-ayaml"><a class="heading-link" href="#ff-a-tf-a-and-trustzone-230409ff-ayaml">FF-A, TF-A, and TrustZone <code>(230409.FF-A.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[21:56]</code> When to enable secondary cores? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Secondary cores are typically enabled after the primary core has successfully initialized the system and started the operating system. The exact process for enabling secondary cores can vary depending on the hardware and operating system being used. Here is a general outline of when secondary cores are enabled:</p>
<ol>
<li>
<p>Power on the system, and the primary core initializes hardware components and executes the bootloader (e.g., Trusted Firmware-A for Arm-based systems).</p>
</li>
<li>
<p>The bootloader loads and starts the operating system on the primary core.</p>
</li>
<li>
<p>The operating system initializes its kernel, essential components, and device drivers on the primary core.</p>
</li>
<li>
<p>After the primary core has completed its initialization, the operating system enables the secondary cores. This process is often referred to as "core bring-up" or "CPU hotplug."</p>
</li>
<li>
<p>The operating system assigns tasks or processes to the secondary cores, allowing them to participate in executing applications and system processes.</p>
</li>
</ol>
<p>It is important to note that the specific process for enabling secondary cores depends on the hardware platform, firmware, bootloader, and operating system in use. Some systems may require additional configuration or software support to enable secondary cores.</p>
<hr>
<h2 id="user-content-tf-a-230410armyaml"><a class="heading-link" href="#tf-a-230410armyaml">TF-A <code>(230410.Arm.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[22:59]</code> Which types of ARM cores is supported by TF-A? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Trusted Firmware-A (TF-A) supports Armv8-A and Armv7-A processors. The Armv8-A architecture encompasses both the 64-bit (AArch64) and the 32-bit (AArch32) execution states, while the Armv7-A architecture is a 32-bit (AArch32) execution state. TF-A provides a reference implementation of Secure World software for a variety of Arm Cortex-A cores within these architectures, including Cortex-A53, Cortex-A57, Cortex-A72, Cortex-A75, and Cortex-A76, among others.</p>
<hr>
<p><strong>Question:</strong> <code>[23:05]</code> Must AArch64 have TF-A? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p>No, AArch64 does not require TF-A (Arm Trusted Firmware-A). TF-A is an open-source project that provides a reference implementation of the software components needed for the secure boot and runtime firmware on Armv8-A platforms. While it is commonly used and recommended for secure firmware development on Armv8-A platforms, it is not mandatory. You can use other firmware solutions or develop custom secure firmware for AArch64 platforms, depending on your requirements and platform constraints.</p>
<hr>
<h2 id="user-content-types-of-arm-cpu-230410armyaml"><a class="heading-link" href="#types-of-arm-cpu-230410armyaml">Types of ARM CPU <code>(230410.Arm.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[23:15]</code> What are types of ARM CPU? Please also describe them in a table with 32 bits and 64 bits. <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>ARM CPUs come in a variety of architectures and designs, each tailored to specific needs and applications. Some common types of ARM CPUs are Cortex-A, Cortex-R, and Cortex-M series. Here's a table describing these three series along with their support for 32-bit and 64-bit execution states:</p>
<table>
<thead>
<tr>
<th>Series</th>
<th>Target Applications</th>
<th>Description</th>
<th>32-bit</th>
<th>64-bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cortex-A</td>
<td>High-performance systems</td>
<td>Designed for high-performance devices like smartphones, tablets, and other consumer electronics, as well as servers. These processors provide high performance and power efficiency, suitable for running complex operating systems like Linux, Android, and iOS.</td>
<td>Yes (Armv7-A)</td>
<td>Yes (Armv8-A)</td>
</tr>
<tr>
<td>Cortex-R</td>
<td>Real-time systems</td>
<td>Targeted towards real-time systems that require fast, deterministic response times like automotive electronics, industrial control systems, and medical devices. These processors prioritize reliability, fault tolerance, and real-time performance.</td>
<td>Yes (Armv7-R)</td>
<td>No*</td>
</tr>
<tr>
<td>Cortex-M</td>
<td>Low-power microcontrollers</td>
<td>Optimized for low-power, cost-sensitive applications like IoT devices, wearables, and other embedded systems. These processors are designed to offer low-latency response times, energy efficiency, and ease of use.</td>
<td>Yes (Armv6-M, Armv7-M, Armv8-M Baseline)</td>
<td>Yes (Armv8-M Mainline)</td>
</tr>
</tbody>
</table>
<p>Please note that within each series, there are multiple specific processor models with different performance levels, features, and target applications. The examples provided above are not exhaustive.</p>
<p>*As of my knowledge cutoff in September 2021, Cortex-R series does not have 64-bit variants. However, it's essential to check ARM's official resources for any updates or new additions to the Cortex-R series.</p>
<hr>
<p><strong>Question:</strong> <code>[23:18]</code> Does Armv8-A has 32 bits? <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, Armv8-A architecture includes both 64-bit (AArch64) and 32-bit (AArch32) execution states. The 32-bit execution state in Armv8-A is largely compatible with the Armv7-A architecture, which allows for backward compatibility with existing 32-bit software.</p>
<p>In AArch32 state, Armv8-A processors support the ARM and Thumb instruction sets, which are commonly used in previous 32-bit Arm architectures. This dual execution state design allows Armv8-A based systems to run a mix of 32-bit and 64-bit applications and operating systems, providing flexibility and a smooth transition for software ecosystems.</p>
<hr>
<p><strong>Question:</strong> <code>[23:19]</code> Does Armv7-A has 64 bits? <code>(Arm.0410.md)</code></p>
<p><strong>Answer:</strong></p>
<p>No, Armv7-A architecture does not have 64-bit support. Armv7-A is a 32-bit architecture that was used in many smartphones, tablets, and other devices before the introduction of Armv8-A. Armv7-A supports the ARM and Thumb instruction sets and includes features like NEON SIMD (Single Instruction, Multiple Data) and hardware floating-point support.</p>
<p>Armv8-A is the successor to Armv7-A and introduced the 64-bit execution state (AArch64) alongside the 32-bit execution state (AArch32) for backward compatibility with Armv7-A software. The 64-bit support in Armv8-A allows for improved performance, larger addressable memory, and additional architectural enhancements compared to Armv7-A.</p>
<hr>
<h2 id="user-content-ch-2---introduction-230409ff-ayaml"><a class="heading-link" href="#ch-2---introduction-230409ff-ayaml">Ch 2 - Introduction <code>(230409.FF-A.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[23:23]</code> What is "Arm A-profile"? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The Arm A-profile is a family of Arm CPU architectures that are designed for high-performance and power-efficient applications, including mobile devices, consumer electronics, servers, and networking infrastructure. The A-profile CPUs are based on the Armv7-A and Armv8-A architectures, which support both 32-bit (AArch32) and 64-bit (AArch64) execution states. The A-profile processors provide a wide range of performance and power options to suit various use cases and include popular cores like Cortex-A series (e.g., Cortex-A72, Cortex-A57, Cortex-A53, etc.).</p>
<hr>
<p><strong>Question:</strong> <code>[23:24]</code> Does "Arm Firmware Framework for Arm A-profile" document is only about Cortex-A? <code>(FF-A.0409.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The "Arm Firmware Framework for Arm A-profile" document is focused on the Arm A-profile architecture, which includes Cortex-A series processors. However, it is not limited to Cortex-A processors only. The document provides guidelines and specifications for developing firmware for Arm A-profile processors in general, including Cortex-A series processors and potentially other A-profile processors developed by Arm or its partners. It aims to ensure a consistent approach to firmware development, security, and functionality across different Arm A-profile implementations.</p>
<hr>
<h2 id="user-content-op-tee0327md"><a class="heading-link" href="#op-tee0327md">OP-TEE.0327.md<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> What is the set_sp macro?</p>
<p><strong>Answer:</strong></p>
<p>In the provided code, <code>set_sp</code> is a macro mentioned in the comments, but it is not defined in the given code. It is likely that the macro is used to set up the stack pointers for different Exception Levels (EL) in the ARM architecture. Setting up the stack pointers is an essential step during the initialization of a processor core.</p>
<p>In ARMv8, there are separate stack pointers for different ELs, and they have different names depending on the current EL:</p>
<ul>
<li>SP_EL0: Stack pointer for Exception Level 0</li>
<li>SP_EL1: Stack pointer for Exception Level 1</li>
<li>SP_EL2: Stack pointer for Exception Level 2</li>
<li>SP_EL3: Stack pointer for Exception Level 3</li>
</ul>
<p>The <code>set_sp</code> macro would be responsible for initializing these stack pointers for the current core. Depending on the implementation, it might involve:</p>
<ol>
<li>Setting up stack pointer for the current EL (e.g., SP_EL1)</li>
<li>Setting up stack pointer for EL0 (SP_EL0)</li>
</ol>
<p>Here's an example of what the <code>set_sp</code> macro might look like:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">.macro set_sp</span>
<span class="pl-en">    // Set up the stack pointer for the current EL</span>
<span class="pl-en">    ldr x0</span><span class="pl-s1">,</span><span class="pl-en"> =__stack_start</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">sp</span><span class="pl-s1">,</span><span class="pl-en"> x0</span>

<span class="pl-en">    // Set up the stack pointer for EL0 (SP_EL0)</span>
<span class="pl-en">    ldr x0</span><span class="pl-s1">,</span><span class="pl-en"> =__stack_el0_start</span>
<span class="pl-en">    msr sp_el0</span><span class="pl-s1">,</span><span class="pl-en"> x0</span>
<span class="pl-en">.endm</span></pre></div>
<p>In this example, <code>__stack_start</code> and <code>__stack_el0_start</code> are symbols representing the starting addresses of the stack memory regions for the current EL and EL0, respectively. The macro initializes the stack pointers using these addresses.</p>
<p>Keep in mind that this is just a simple example of what <code>set_sp</code> macro might look like, and the actual implementation may differ based on your system requirements and the specific ARMv8-A processor variant used.</p>
<hr>
<p><strong>Question:</strong> Please list functions and macros in entry_a64.S</p>
<p><strong>Answer:</strong></p>
<p><code>entry_a64.S</code> is an assembly file that provides low-level entry points for the AArch64 architecture in the OP-TEE OS. Here's a list of functions and macros typically found in the <code>entry_a64.S</code> file:</p>
<p>Functions:</p>
<ol>
<li>
<code>reset_primary_core</code>: Handles the primary core's reset and initialization.</li>
<li>
<code>reset_secondary_core</code>: Handles the secondary core's reset and initialization.</li>
<li>
<code>ns_entry</code>: Handles transitions from the Normal World to the Secure World.</li>
<li>
<code>smc_handler</code>: Handles SMC (Secure Monitor Call) instructions.</li>
<li>
<code>fiq_handler</code>: Handles FIQ (Fast Interrupt Request) exceptions.</li>
<li>
<code>irq_handler</code>: Handles IRQ (Interrupt Request) exceptions.</li>
<li>
<code>sync_abort_handler</code>: Handles synchronous abort exceptions.</li>
<li>
<code>prefetch_abort_handler</code>: Handles prefetch abort exceptions.</li>
<li>
<code>data_abort_handler</code>: Handles data abort exceptions.</li>
<li>
<code>undef_handler</code>: Handles undefined instruction exceptions.</li>
<li>
<code>svc_handler</code>: Handles SVC (Supervisor Call) exceptions.</li>
</ol>
<p>Macros:</p>
<ol>
<li>
<code>SAVE_GP_REGS</code>: Saves general-purpose registers to the stack.</li>
<li>
<code>RESTORE_GP_REGS</code>: Restores general-purpose registers from the stack.</li>
<li>
<code>SAVE_SP_REGS</code>: Saves stack pointer registers to the stack.</li>
<li>
<code>RESTORE_SP_REGS</code>: Restores stack pointer registers from the stack.</li>
<li>
<code>SAVE_SYS_REGS</code>: Saves system registers to the stack.</li>
<li>
<code>RESTORE_SYS_REGS</code>: Restores system registers from the stack.</li>
<li>
<code>SAVE_FPU_REGS</code>: Saves floating-point registers to the stack.</li>
<li>
<code>RESTORE_FPU_REGS</code>: Restores floating-point registers from the stack.</li>
</ol>
<p>Please note that the actual functions and macros in your specific version of the OP-TEE OS might differ. Make sure to consult the source code of the version you're working with for an accurate list.</p>
<hr>
<p><strong>Question:</strong> Please list functions and macros in entry_a64.S that I sent you before.</p>
<p><strong>Answer:</strong></p>
<p>My apologies for the confusion earlier, as I am an AI language model, I am unable to access external files or content that you've sent. Please share the relevant parts of the code, and I'd be happy to help with your question.</p>
<hr>
<p><strong>Question:</strong> Who to call vector_cpu_on_entry with OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>In the context of OP-TEE, the <code>vector_cpu_on_entry</code> function is not used directly. OP-TEE relies on ARM Trusted Firmware (ATF) for power management, which handles calling the appropriate entry points when powering on CPU cores.</p>
<p>When using OP-TEE and ATF, the ATF will handle the PSCI calls, such as <code>CPU_ON</code>, and call the appropriate entry points for the non-secure world (e.g., the operating system) and the secure world (e.g., OP-TEE). In this case, you do not call <code>vector_cpu_on_entry</code> directly.</p>
<p>If you need to bring up secondary CPU cores and start executing OP-TEE on them, you should follow these steps:</p>
<ol>
<li>
<p>Make sure OP-TEE is built with secondary core support enabled. This is usually done by defining <code>CFG_TEE_CORE_NB_CORE</code> with the number of cores you want to support.</p>
</li>
<li>
<p>In the non-secure world (e.g., Linux kernel), use the PSCI interface to power on the secondary cores. You can do this by calling <code>cpu_up()</code> or similar functions depending on your kernel configuration.</p>
</li>
</ol>
<p>When the secondary core is powered on, the ATF will handle the rest, setting up the appropriate entry points for both non-secure and secure worlds. The secondary core will then start executing OP-TEE in the secure world, and the non-secure world operating system on the other side.</p>
<hr>
<h2 id="user-content-ff-a0409md"><a class="heading-link" href="#ff-a0409md">FF-A.0409.md<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Does TF-A support Arm32 or Arm64?</p>
<p><strong>Answer:</strong></p>
<p>Trusted Firmware-A (TF-A) supports both Arm32 (AArch32) and Arm64 (AArch64) architectures. It is designed to provide a reference implementation of Secure World software for Armv8-A and Armv7-A processors. TF-A aims to cater to various security and non-security use cases, and it is built to be adaptable and portable across different Arm architectures.</p>
<hr>
<p><strong>Question:</strong> Does Armv7-A has 64 bits?</p>
<p><strong>Answer:</strong></p>
<p>No, Armv7-A architecture does not have 64 bits. Armv7-A is a 32-bit (AArch32) execution state architecture. Armv8-A is the architecture that introduces both 64-bit (AArch64) and 32-bit (AArch32) execution states.</p>
<hr>
<p><strong>Question:</strong> Does Armv8-A has 32 bits?</p>
<p><strong>Answer:</strong></p>
<p>Yes, Armv8-A architecture supports both 64-bit (AArch64) and 32-bit (AArch32) execution states. While the primary focus of Armv8-A is the introduction of the AArch64 execution state, it also includes enhancements to the AArch32 state, which is compatible with the Armv7-A architecture. This allows for flexibility and backwards compatibility in systems implementing Armv8-A architecture.</p>
<hr>
</article></body></html>