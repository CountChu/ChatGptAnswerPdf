<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
    color:#333;
    background:#fff;
}

body .markdown-body {
    padding: 45px;
    word-wrap: break-word;
}

.markdown-body .octicon-link:before {
  font: normal normal normal 16px/1 octicons-link;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  content: '\f05c';
  vertical-align: middle;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
</style><title>2023-04-04</title></head><body><article class="markdown-body"><h1 id="user-content-2023-04-04"><a class="heading-link" href="#2023-04-04">2023-04-04<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<p>Created: 2023-11-08 12:49:09</p>
<h1 id="user-content-questions"><a class="heading-link" href="#questions">Questions<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<ul>
<li>CPU <code>(230329.TrustZone.yaml)</code>
<ul>
<li>
<code>[09:25]</code> What are SCP and AP? <code>(TrustZone.0329.md)</code>
</li>
<li>
<code>[09:26]</code> Do SCP and AP in ARM share memory? <code>(TrustZone.0329.md)</code>
</li>
<li>
<code>[14:20]</code> What is differenct between Armv8-A and Armv8-M? Please summarize as a table. <code>(TrustZone.0329.md)</code>
</li>
</ul>
</li>
<li>Boot <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[09:29]</code> Why does OP-TEE initialize secondary cores when reset? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Recover OP-TEE <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[09:37]</code> How to detect OP-TEE dead? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[09:39]</code> How to automatically recovery the crashed OP-TEE? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[09:42]</code> Can I develop a dual OP-TEE so that if one is crashed, run another. <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[10:24]</code> How to detect if OP-TEE is tamperred at run-time? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Static TA and Dynamic TA <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[10:08]</code> How to recover a crashed static TA? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[10:10]</code> How to recover a crashed dynamic TA? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>TrustZone &amp; HSM <code>(230329.TrustZone.yaml)</code>
<ul>
<li>
<code>[10:18]</code> What is difference between TrustZone and HSM? Please also summarize in a table. <code>(TrustZone.0329.md)</code>
</li>
<li>
<code>[10:19]</code> What are relationships between TrustZone and HSM? <code>(TrustZone.0329.md)</code>
</li>
<li>
<code>[10:20]</code> Can TrustZone totally replace HSM? <code>(TrustZone.0329.md)</code>
</li>
</ul>
</li>
<li>Attack <code>(230327.OP-TEE.yaml)</code>
<ul>
<li>
<code>[14:49]</code> Whare are kinds of methods to attack OP-TEE? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="user-content-chats"><a class="heading-link" href="#chats">Chats<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<ul>
<li>OP-TEE.0327.md
<ul>
<li>
<code>[09:38]</code> How to recovery the dead OP-TEE? <code>(OP-TEE.0327.md)</code>
</li>
<li>
<code>[10:23]</code> Hot to detect if OP-TEE is tamperred at run-time? <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>TrustZone.0329.md
<ul>
<li>
<code>[14:19]</code> What is differenct between Armv8-A and Armv8-M <code>(TrustZone.0329.md)</code>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="user-content-q--a"><a class="heading-link" href="#q--a">Q &amp; A<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<h2 id="user-content-cpu-230329trustzoneyaml"><a class="heading-link" href="#cpu-230329trustzoneyaml">CPU <code>(230329.TrustZone.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[09:25]</code> What are SCP and AP? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>SCP (System Control Processor) and AP (Application Processor) are two different types of processors often found in a system-on-chip (SoC) or embedded systems.</p>
<ol>
<li>
<p>SCP (System Control Processor):
The SCP is a low-power, dedicated processor responsible for managing system-level functions such as power management, thermal management, and other low-level tasks. The SCP typically runs a simple firmware, often referred to as the system control firmware (SCFW), which is in charge of controlling and monitoring various system components. The SCP usually runs at a lower frequency and consumes less power compared to the AP, as it is designed to handle background tasks and ensure efficient operation of the overall system.</p>
</li>
<li>
<p>AP (Application Processor):
The AP, on the other hand, is a more powerful processor responsible for running the operating system (OS) and executing user applications. In a typical SoC, the AP will consist of one or more CPU cores, often accompanied by GPU, memory controllers, and other peripherals required for running the OS and applications. The AP manages more complex and compute-intensive tasks, making it the primary processing unit in the system.</p>
</li>
</ol>
<p>In summary, the SCP is responsible for managing low-level system functions, while the AP is responsible for running the OS and executing user applications. Together, they enable efficient and seamless operation of the system.</p>
<hr>
<p><strong>Question:</strong> <code>[09:26]</code> Do SCP and AP in ARM share memory? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In an ARM-based system-on-chip (SoC), the System Control Processor (SCP) and Application Processor (AP) may share memory, depending on the specific SoC design and implementation. Shared memory is often used as a means of communication and data exchange between the two processors.</p>
<p>In many cases, the SCP and AP will have access to a region of shared memory, typically implemented as SRAM, DRAM, or on-chip memory. This shared memory space allows the SCP and AP to exchange information, synchronize operations, or pass messages between them. The shared memory region can be protected by appropriate access control mechanisms, such as TrustZone or memory protection units (MPUs), to prevent unauthorized access or data corruption.</p>
<p>However, it is essential to note that the exact memory architecture and sharing mechanism depend on the specific SoC design and implementation. In some cases, the SCP and AP may have separate memory spaces, with communication occurring through dedicated hardware channels or interfaces.</p>
<p>In summary, SCP and AP in ARM-based SoCs can share memory depending on the specific design and implementation, enabling efficient communication and data exchange between the two processors.</p>
<hr>
<p><strong>Question:</strong> <code>[14:20]</code> What is differenct between Armv8-A and Armv8-M? Please summarize as a table. <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Here is a summary of the differences between Armv8-A and Armv8-M in a table format:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Armv8-A</th>
<th>Armv8-M</th>
</tr>
</thead>
<tbody>
<tr>
<td>Target Applications</td>
<td>High-performance systems (smartphones, tablets, servers, networking equipment)</td>
<td>Low-power, resource-constrained embedded systems (microcontrollers, IoT devices, wearables)</td>
</tr>
<tr>
<td>Instruction Set</td>
<td>AArch64 (64-bit) and AArch32 (32-bit)</td>
<td>AArch32 (32-bit)</td>
</tr>
<tr>
<td>TrustZone Support</td>
<td>Yes, for secure environment in complex systems</td>
<td>Yes, adapted for microcontrollers</td>
</tr>
<tr>
<td>Memory Management</td>
<td>Memory Management Unit (MMU) with virtual memory support</td>
<td>Memory Protection Unit (MPU) without virtual memory support</td>
</tr>
<tr>
<td>Exception Levels and Privilege Modes</td>
<td>Multiple levels (EL0-EL3) and privilege modes</td>
<td>Simpler model with fewer privilege modes</td>
</tr>
</tbody>
</table>
<p>Armv8-A is designed for high-performance systems and supports both 32-bit and 64-bit instruction sets, while Armv8-M is targeted at low-power microcontrollers and supports only the 32-bit instruction set. The memory management, TrustZone implementation, and exception handling mechanisms are also tailored to the specific needs of their target applications.</p>
<hr>
<h2 id="user-content-boot-230327op-teeyaml"><a class="heading-link" href="#boot-230327op-teeyaml">Boot <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[09:29]</code> Why does OP-TEE initialize secondary cores when reset? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE initializes secondary cores during the reset process to properly configure and synchronize them with the primary core. This is important for maintaining a consistent and secure execution environment across all cores.</p>
<p>When the system is reset, the primary core (core 0) is responsible for initializing the OP-TEE OS, including the secure world and shared resources. Once the primary core has completed the initialization process, it sends a signal to secondary cores to begin their own initialization process. Each secondary core then initializes its own secure world environment and sets up necessary data structures and configurations in alignment with the primary core.</p>
<p>This process ensures that all cores have a consistent view of the secure world, enabling the execution of Trusted Applications (TAs) across multiple cores while maintaining security and isolation.</p>
<hr>
<h2 id="user-content-recover-op-tee-230327op-teeyaml"><a class="heading-link" href="#recover-op-tee-230327op-teeyaml">Recover OP-TEE <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[09:37]</code> How to detect OP-TEE dead? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Detecting if OP-TEE is dead or non-responsive can be done through various mechanisms. Here are some approaches:</p>
<ol>
<li>
<p>Timeouts: Set a timeout for the normal world when waiting for a response from OP-TEE. If the timeout expires and no response has been received, consider OP-TEE non-responsive or dead.</p>
</li>
<li>
<p>Heartbeat mechanism: Implement a periodic "heartbeat" or "ping" mechanism between the normal world and OP-TEE. If the normal world does not receive a response within a predefined time interval, consider OP-TEE non-responsive or dead.</p>
</li>
<li>
<p>Error checking: Monitor the normal world's interactions with OP-TEE for unexpected errors or responses. If such errors occur, it may indicate a problem with OP-TEE's operation.</p>
</li>
<li>
<p>System logs: Analyze system logs and debug messages to identify any unexpected behaviors or error messages from OP-TEE.</p>
</li>
<li>
<p>External monitoring: Use an external hardware or software monitoring solution to detect any anomalies in the operation of the device or the secure world.</p>
</li>
</ol>
<p>In case OP-TEE is determined to be non-responsive or dead, a proper recovery or debugging mechanism should be in place to handle such situations. This might include resetting the device, collecting debug information, or triggering a fail-safe mechanism.</p>
<hr>
<p><strong>Question:</strong> <code>[09:39]</code> How to automatically recovery the crashed OP-TEE? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Automatically recovering a crashed OP-TEE can be challenging, as the recovery process depends on the root cause of the crash and the available recovery mechanisms. However, you can implement a watchdog mechanism to detect and attempt to recover from a crash automatically. Here are some general steps to consider:</p>
<ol>
<li>
<p>Implement a watchdog timer: Utilize a hardware or software watchdog timer to monitor OP-TEE's operation. The timer should be periodically reset by the OP-TEE under normal operation. If OP-TEE crashes, the timer will not be reset, and the watchdog mechanism will trigger a recovery action after a predefined timeout.</p>
</li>
<li>
<p>Monitor normal world and secure world communication: Regularly check the communication between the normal world and the secure world. If the communication stalls or encounters unexpected errors, trigger a recovery action.</p>
</li>
<li>
<p>Define recovery actions: Design recovery actions to take when a crash is detected. Possible actions include:
a. Reset the device.
b. Reset the secure world or restart OP-TEE without affecting the normal world.
c. Switch to a failsafe mechanism or an alternative trusted execution environment.</p>
</li>
<li>
<p>Test and validate: Thoroughly test and validate the automatic recovery mechanism to ensure it works as intended and does not introduce additional security risks or undesired side effects.</p>
</li>
<li>
<p>Implement error reporting: After a crash and recovery, collect and report relevant logs, error messages, or diagnostic information to aid in future debugging and analysis.</p>
</li>
</ol>
<p>Please note that the specific implementation of an automatic recovery mechanism will depend on your device, its hardware and software stack, and the nature of the crash. Implementing such a mechanism can be complex and requires careful consideration of security implications and system behavior. It is essential to have a well-defined recovery plan and debugging mechanism in place for such situations.</p>
<hr>
<p><strong>Question:</strong> <code>[09:42]</code> Can I develop a dual OP-TEE so that if one is crashed, run another. <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Developing a dual OP-TEE setup to provide redundancy in case one crashes is an interesting idea. Although it might not be straightforward, you can consider the following approach:</p>
<ol>
<li>
<p>Run two instances of OP-TEE: Modify the bootloader and memory layout to accommodate two separate OP-TEE instances running on different cores or partitions of the device. Each OP-TEE instance should have its own secure memory space, and they should not interfere with each other.</p>
</li>
<li>
<p>Synchronize states: Implement a mechanism to synchronize the state and configuration between the two OP-TEE instances. This will ensure that if one instance crashes, the other can take over seamlessly.</p>
</li>
<li>
<p>Monitor OP-TEE health: Develop a health monitoring system that continuously checks the status of both OP-TEE instances. If an issue is detected with one instance, the monitoring system should automatically switch to the other instance.</p>
</li>
<li>
<p>Coordinate normal world communication: Modify the normal world OS and the secure world communication layer to support communicating with multiple OP-TEE instances. This may involve load balancing and failover mechanisms to distribute requests and handle failures.</p>
</li>
<li>
<p>Handle failover: Implement a failover mechanism that quickly switches between OP-TEE instances in case of a crash. This could include redirecting pending requests to the other instance, transferring the state, and ensuring secure storage continuity.</p>
</li>
</ol>
<p>Please note that implementing a dual OP-TEE setup can be complex and may introduce additional security risks and performance overhead. It is essential to carefully analyze the system design, security implications, and potential trade-offs before implementing such a solution. Additionally, thorough testing and validation will be required to ensure the dual OP-TEE setup functions as intended without introducing new vulnerabilities or unexpected side effects.</p>
<hr>
<p><strong>Question:</strong> <code>[10:24]</code> How to detect if OP-TEE is tamperred at run-time? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Detecting if OP-TEE has been tampered with at runtime is a challenging task, as an attacker who successfully infiltrates the TEE environment could attempt to hide their activities. However, you can implement some techniques to help identify potential tampering:</p>
<ol>
<li>
<p>Runtime integrity checks: Perform periodic integrity checks of the OP-TEE code and data segments while the system is running. This can be achieved by calculating a hash or checksum of these memory regions and comparing them with their expected values.</p>
</li>
<li>
<p>Hardware-based security features: Leverage hardware security features like ARM TrustZone's secure memory, which can prevent unauthorized access to sensitive memory regions. Secure memory can protect critical OP-TEE data structures and code from being tampered with by external entities.</p>
</li>
<li>
<p>Secure boot: Ensure that the system uses secure boot, which verifies the integrity of the bootloader, kernel, and OP-TEE components during the boot process. A secure boot chain can minimize the chances of tampering with OP-TEE before it starts running.</p>
</li>
<li>
<p>Hardware security modules (HSMs): HSMs can provide additional protection against tampering by securely storing cryptographic keys and performing sensitive operations within the secure hardware environment.</p>
</li>
<li>
<p>Monitor system behavior: Keep an eye on the system's behavior and resource utilization. Unusual patterns or unexpected resource usage may be indicative of tampering or an ongoing attack.</p>
</li>
<li>
<p>Logging and auditing: Maintain detailed logs of activities within the OP-TEE environment and perform regular audits to identify potential anomalies or unauthorized actions.</p>
</li>
<li>
<p>Use of external monitoring tools: Employ external runtime monitoring tools that can analyze the runtime behavior of the system to detect anomalies or signs of tampering.</p>
</li>
</ol>
<p>Keep in mind that no single technique can provide complete protection against tampering. It is crucial to use a combination of methods and maintain a strong security posture through continuous monitoring, testing, and updating of your system's security mechanisms.</p>
<hr>
<h2 id="user-content-static-ta-and-dynamic-ta-230327op-teeyaml"><a class="heading-link" href="#static-ta-and-dynamic-ta-230327op-teeyaml">Static TA and Dynamic TA <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[10:08]</code> How to recover a crashed static TA? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Recovering a crashed static TA in OP-TEE may not be a straightforward process, as static TAs are linked with the OP-TEE OS binary and run in the same context as the OS. However, you can try the following steps to recover from a crashed static TA:</p>
<ol>
<li>
<p>Detect the crash: Set up a monitoring mechanism to detect when a static TA crashes or becomes unresponsive. This can be done by monitoring the return values of the TA's entry points, observing timeouts or abnormal behavior, and checking for signs of memory corruption.</p>
</li>
<li>
<p>Terminate the TA session: In case of a detected crash, terminate the session with the affected static TA. Inform the client application (CA) in the normal world about the issue, and potentially return an error code to signify the crash.</p>
</li>
<li>
<p>Clean up resources: Release any resources held by the crashed static TA, such as memory allocations, file handles, or cryptographic keys.</p>
</li>
<li>
<p>Reinitialize the TA: As static TAs are linked with the OP-TEE OS binary, the only way to reinitialize the TA is by resetting the entire secure world. This can be done by rebooting the system or triggering a system reset. Note that this approach may also affect other TAs and the OP-TEE OS itself, so it should be used with caution.</p>
</li>
<li>
<p>Restore the state (optional): If the static TA maintains a persistent state in secure storage, you might need to restore the state after reinitialization. This can be done by reading the state from secure storage and passing it back to the TA when it starts.</p>
</li>
<li>
<p>Resume operation: Once the static TA is reinitialized and its state is restored (if applicable), you can resume the normal operation by relaunching the client application and re-establishing the session with the TA.</p>
</li>
</ol>
<p>Please note that the recovery process for a crashed static TA is not ideal, as it may involve resetting the entire secure world. It is essential to design and implement the static TA with robust error handling and recovery mechanisms to minimize the risk of crashes. Additionally, you might consider using dynamic TAs instead of static TAs, as dynamic TAs offer better isolation and can be loaded and unloaded independently, making recovery easier in case of crashes.</p>
<hr>
<p><strong>Question:</strong> <code>[10:10]</code> How to recover a crashed dynamic TA? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Recovering a crashed dynamic TA in OP-TEE is generally more manageable than recovering a static TA since dynamic TAs run in separate contexts and can be loaded and unloaded independently. Here's a suggested process to recover a crashed dynamic TA:</p>
<ol>
<li>
<p>Detect the crash: Set up a monitoring mechanism to detect when a dynamic TA crashes or becomes unresponsive. This can be done by monitoring the return values of the TA's entry points, observing timeouts, or abnormal behavior.</p>
</li>
<li>
<p>Terminate the TA session: In case of a detected crash, terminate the session with the affected dynamic TA. Inform the client application (CA) in the normal world about the issue, and potentially return an error code to signify the crash.</p>
</li>
<li>
<p>Clean up resources: Release any resources held by the crashed dynamic TA, such as memory allocations, file handles, or cryptographic keys.</p>
</li>
<li>
<p>Unload the TA: Unload the crashed dynamic TA from the OP-TEE OS by closing the session associated with the TA. This should release the resources held by the TA and remove it from memory.</p>
</li>
<li>
<p>Reload the TA: Load a new instance of the dynamic TA using the same TA UUID. This can be done by requesting a new session with the TA from the client application.</p>
</li>
<li>
<p>Restore the state (optional): If the dynamic TA maintains a persistent state in secure storage, you might need to restore the state after reloading the TA. This can be done by reading the state from secure storage and passing it back to the TA when it starts.</p>
</li>
<li>
<p>Resume operation: Once the dynamic TA is reloaded and its state is restored (if applicable), you can resume normal operation by relaunching the client application and re-establishing the session with the TA.</p>
</li>
</ol>
<p>Please note that it's essential to design and implement the dynamic TA with robust error handling and recovery mechanisms to minimize the risk of crashes. Be sure to thoroughly test and validate the TA to ensure its stability and reliability.</p>
<hr>
<h2 id="user-content-trustzone--hsm-230329trustzoneyaml"><a class="heading-link" href="#trustzone--hsm-230329trustzoneyaml">TrustZone &amp; HSM <code>(230329.TrustZone.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[10:18]</code> What is difference between TrustZone and HSM? Please also summarize in a table. <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TrustZone and HSM (Hardware Security Module) are both technologies that provide security features, but they are designed for different purposes and have distinct characteristics. Here is a comparison of the two:</p>
<p>TrustZone:</p>
<ul>
<li>A security extension of ARM architecture.</li>
<li>Creates two separate worlds: Secure and Normal worlds.</li>
<li>Provides isolation and protection for sensitive operations and data.</li>
<li>Can be implemented on a general-purpose CPU.</li>
<li>Usually lower cost than HSM.</li>
<li>Lower performance for cryptographic operations compared to HSM.</li>
<li>Suitable for a wide range of applications, including mobile devices, IoT, and embedded systems.</li>
</ul>
<p>HSM:</p>
<ul>
<li>A dedicated hardware device for secure cryptographic operations and key management.</li>
<li>Designed specifically for high-level security.</li>
<li>Offers higher performance for cryptographic operations compared to TrustZone.</li>
<li>Physically tamper-resistant.</li>
<li>FIPS 140-2 and other security certifications.</li>
<li>Higher cost than TrustZone.</li>
<li>Suitable for high-security applications like banking, government, and critical infrastructure.</li>
</ul>
<p>Here is a summary table:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>TrustZone</th>
<th>HSM</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>ARM architecture extension</td>
<td>Dedicated hardware device</td>
</tr>
<tr>
<td>Purpose</td>
<td>Isolation and protection</td>
<td>Cryptographic operations &amp; key management</td>
</tr>
<tr>
<td>Implementation</td>
<td>General-purpose CPU</td>
<td>Specialized hardware</td>
</tr>
<tr>
<td>Cost</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr>
<td>Performance</td>
<td>Lower for crypto operations</td>
<td>Higher for crypto operations</td>
</tr>
<tr>
<td>Tamper-resistance</td>
<td>Limited</td>
<td>High (physically tamper-resistant)</td>
</tr>
<tr>
<td>Security certifications</td>
<td>Varies</td>
<td>FIPS 140-2 and others</td>
</tr>
<tr>
<td>Use cases</td>
<td>Mobile, IoT, embedded systems</td>
<td>Banking, government, critical infrastructure</td>
</tr>
</tbody>
</table>
<p>Please note that the comparison above is a generalization, and specific implementations of TrustZone and HSMs may have different features and performance characteristics.</p>
<hr>
<p><strong>Question:</strong> <code>[10:19]</code> What are relationships between TrustZone and HSM? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TrustZone and HSM (Hardware Security Module) can be used together or independently to provide security features in a system. They are not mutually exclusive and can complement each other in various ways. Here are some relationships between TrustZone and HSM:</p>
<ol>
<li>
<p>Complementary Technologies: TrustZone can be used to create a secure environment for running sensitive software, while HSM can be used for secure cryptographic operations and key management. Both technologies can work together in a system to provide a higher level of security.</p>
</li>
<li>
<p>TrustZone as a lightweight alternative: In some cases, TrustZone can be used as a lightweight alternative to HSM for less critical applications or where the cost and complexity of HSM are not justifiable. TrustZone provides a good balance between security and cost in such cases.</p>
</li>
<li>
<p>HSM inside TrustZone: HSM can be used within the secure world of TrustZone to provide high-performance cryptographic operations and secure key storage. In this setup, TrustZone isolates the HSM and its operations from the normal world, while HSM performs its dedicated security functions.</p>
</li>
<li>
<p>Communication: TrustZone and HSM can be used together to establish secure communication channels between different components of a system. TrustZone can ensure the confidentiality and integrity of the data exchanged between the secure and normal worlds, while HSM can be used for cryptographic operations like encryption, decryption, and digital signatures.</p>
</li>
</ol>
<p>In summary, TrustZone and HSM can be seen as complementary technologies that can work together to provide a comprehensive security solution. TrustZone provides isolation and protection for sensitive operations and data, while HSM delivers high-performance cryptographic operations and secure key management. Depending on the application and security requirements, they can be used together or independently.</p>
<hr>
<p><strong>Question:</strong> <code>[10:20]</code> Can TrustZone totally replace HSM? <code>(TrustZone.0329.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TrustZone cannot entirely replace an HSM because they serve different purposes and have different strengths and limitations. While TrustZone can provide a secure execution environment for sensitive applications, it does not offer the same level of security, performance, and tamper-resistance as a dedicated HSM.</p>
<p>Here are some reasons why TrustZone cannot fully replace an HSM:</p>
<ol>
<li>
<p>Hardware-level Security: HSMs are designed with specialized hardware to provide a high level of tamper-resistance, secure key storage, and cryptographic performance. TrustZone, on the other hand, relies on the processor's hardware features and provides software-based isolation. It is not designed to offer the same level of hardware-level security as an HSM.</p>
</li>
<li>
<p>Cryptographic Performance: HSMs are optimized for cryptographic operations and can provide better performance for encryption, decryption, and other cryptographic functions compared to TrustZone, which relies on the processor's general-purpose hardware.</p>
</li>
<li>
<p>Secure Key Storage: HSMs are designed to store cryptographic keys securely and protect them from unauthorized access, even in the presence of physical attacks. TrustZone can provide some level of secure key storage, but it may not be as robust as the key storage in an HSM.</p>
</li>
<li>
<p>Certification: HSMs often come with certifications, such as FIPS 140-2 or Common Criteria, that guarantee a certain level of security and assurance. TrustZone, being a part of a general-purpose processor, may not have the same certifications, making it less suitable for highly regulated industries or applications with strict security requirements.</p>
</li>
</ol>
<p>In summary, while TrustZone can provide a secure environment for sensitive applications, it cannot fully replace an HSM in terms of security, performance, and tamper-resistance. Both technologies have their use cases, and depending on the security requirements, one or both can be employed in a system.</p>
<hr>
<h2 id="user-content-attack-230327op-teeyaml"><a class="heading-link" href="#attack-230327op-teeyaml">Attack <code>(230327.OP-TEE.yaml)</code>
<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <code>[14:49]</code> Whare are kinds of methods to attack OP-TEE? <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>There are various methods an attacker might use to target OP-TEE. Some of the common attack vectors include:</p>
<ol>
<li>
<p>Exploiting software vulnerabilities: Attackers can exploit bugs or vulnerabilities in the OP-TEE code, such as buffer overflows, use-after-free, or format string vulnerabilities, to gain unauthorized access or escalate privileges within the TEE.</p>
</li>
<li>
<p>Side-channel attacks: These attacks focus on extracting sensitive information by observing the physical characteristics of the system, such as power consumption, electromagnetic emissions, or timing information. Examples include cache-timing attacks, power analysis attacks, and differential fault analysis.</p>
</li>
<li>
<p>Reverse engineering: Attackers can reverse-engineer the OP-TEE firmware to discover vulnerabilities, understand internal structures, or extract sensitive information such as cryptographic keys.</p>
</li>
<li>
<p>Bypassing secure boot: If an attacker can compromise the secure boot process, they can potentially tamper with or replace the OP-TEE components before they are loaded into memory, undermining the entire TEE's security.</p>
</li>
<li>
<p>Physical attacks: Sophisticated attackers may attempt to directly manipulate the hardware, for example, by probing the memory bus or tampering with the hardware security modules (HSMs).</p>
</li>
<li>
<p>Social engineering: Attackers can use social engineering techniques to trick developers or users into disclosing sensitive information or installing malicious software that compromises the TEE environment.</p>
</li>
<li>
<p>Compromising the rich execution environment (REE): If an attacker gains control over the REE, they might attempt to exploit the communication channel between the REE and the TEE to manipulate or intercept sensitive data.</p>
</li>
<li>
<p>Fault injection attacks: By inducing faults in the hardware, an attacker can cause the system to behave unexpectedly, potentially revealing sensitive information or bypassing security mechanisms. Examples include voltage glitching, clock glitching, and laser fault injection.</p>
</li>
<li>
<p>Rollback attacks: An attacker might attempt to revert the TEE to a previous, vulnerable state, allowing them to exploit known vulnerabilities or bypass security patches.</p>
</li>
</ol>
<p>To mitigate these risks, it's essential to maintain a strong security posture, implement secure coding practices, and regularly update OP-TEE to the latest version. Additionally, employ hardware-based security features and perform regular security audits to identify potential vulnerabilities.</p>
<hr>
<h2 id="user-content-op-tee0327md"><a class="heading-link" href="#op-tee0327md">OP-TEE.0327.md<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> How to recovery the dead OP-TEE?</p>
<p><strong>Answer:</strong></p>
<p>Recovering from a dead or non-responsive OP-TEE depends on the root cause of the issue and the available recovery mechanisms. Here are some general steps to consider for recovery:</p>
<ol>
<li>
<p>Reset the device: If the device can be safely reset, try doing so. A full system reset may resolve the issue causing OP-TEE to become non-responsive. However, this should be done with caution, as it may also cause data loss or other unintended consequences.</p>
</li>
<li>
<p>Debug and diagnose: If the issue persists or if a reset is not feasible, collect debug information, logs, and analyze the issue to determine the root cause. This may involve using JTAG debugging, analyzing logs from the normal world and secure world, or other debugging techniques.</p>
</li>
<li>
<p>Apply fixes or workarounds: Once the root cause is identified, apply the appropriate fixes or workarounds to resolve the issue. This may involve patching the OP-TEE code, updating configurations, or applying other remediation measures.</p>
</li>
<li>
<p>Update firmware or software: If the issue is caused by a bug or a known vulnerability in the OP-TEE or other system components, update the relevant firmware or software to the latest version that includes the necessary fixes.</p>
</li>
<li>
<p>Failsafe mechanism: If the device is equipped with a failsafe mechanism or fallback to an alternative trusted execution environment, trigger that mechanism to maintain the security and functionality of the system.</p>
</li>
<li>
<p>Contact support or escalate: If none of the above steps resolves the issue, contact the device manufacturer, OP-TEE developers, or other relevant support channels for further assistance.</p>
</li>
</ol>
<p>Keep in mind that the specific recovery steps will depend on your device, its hardware and software stack, and the specific issue encountered. It is essential to have a well-defined recovery plan and debugging mechanism in place for such situations.</p>
<hr>
<p><strong>Question:</strong> Hot to detect if OP-TEE is tamperred at run-time?</p>
<p><strong>Answer:</strong></p>
<p>Detecting if OP-TEE has been tampered with at runtime is a challenging task, as an attacker who successfully infiltrates the TEE environment could attempt to hide their activities. However, you can implement some techniques to help identify potential tampering:</p>
<ol>
<li>
<p>Runtime integrity checks: Perform periodic integrity checks of the OP-TEE code and data segments while the system is running. This can be achieved by calculating a hash or checksum of these memory regions and comparing them with their expected values.</p>
</li>
<li>
<p>Hardware-based security features: Leverage hardware security features like ARM TrustZone's secure memory, which can prevent unauthorized access to sensitive memory regions. Secure memory can protect critical OP-TEE data structures and code from being tampered with by external entities.</p>
</li>
<li>
<p>Secure boot: Ensure that the system uses secure boot, which verifies the integrity of the bootloader, kernel, and OP-TEE components during the boot process. A secure boot chain can minimize the chances of tampering with OP-TEE before it starts running.</p>
</li>
<li>
<p>Hardware security modules (HSMs): HSMs can provide additional protection against tampering by securely storing cryptographic keys and performing sensitive operations within the secure hardware environment.</p>
</li>
<li>
<p>Monitor system behavior: Keep an eye on the system's behavior and resource utilization. Unusual patterns or unexpected resource usage may be indicative of tampering or an ongoing attack.</p>
</li>
<li>
<p>Logging and auditing: Maintain detailed logs of activities within the OP-TEE environment and perform regular audits to identify potential anomalies or unauthorized actions.</p>
</li>
<li>
<p>Use of external monitoring tools: Employ external runtime monitoring tools that can analyze the runtime behavior of the system to detect anomalies or signs of tampering.</p>
</li>
</ol>
<p>Keep in mind that no single technique can provide complete protection against tampering. It is crucial to use a combination of methods and maintain a strong security posture through continuous monitoring, testing, and updating of your system's security mechanisms.</p>
<hr>
<h2 id="user-content-trustzone0329md"><a class="heading-link" href="#trustzone0329md">TrustZone.0329.md<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> What is differenct between Armv8-A and Armv8-M</p>
<p><strong>Answer:</strong></p>
<p>Armv8-A and Armv8-M are two different profiles within the ARMv8 architecture, each targeting different types of systems and applications. Here are the main differences between Armv8-A and Armv8-M:</p>
<ol>
<li>
<p>Target Applications:</p>
<ul>
<li>Armv8-A: This profile is primarily designed for high-performance systems, such as smartphones, tablets, servers, and networking equipment. It is used in applications that require complex processing tasks and powerful performance.</li>
<li>Armv8-M: This profile is specifically designed for microcontrollers (MCUs) and is aimed at low-power, resource-constrained embedded systems, such as IoT devices, wearables, and sensor nodes.</li>
</ul>
</li>
<li>
<p>Instruction Set:</p>
<ul>
<li>Armv8-A: It supports both the AArch64 (64-bit) and AArch32 (32-bit) instruction sets. AArch64 provides a larger address space, more general-purpose registers, and improved performance for certain workloads.</li>
<li>Armv8-M: It supports only the AArch32 (32-bit) instruction set, which is more suitable for low-power and resource-constrained applications.</li>
</ul>
</li>
<li>
<p>TrustZone Support:</p>
<ul>
<li>Armv8-A: TrustZone is supported in the Armv8-A profile, providing a secure environment for sensitive applications and secure data processing.</li>
<li>Armv8-M: TrustZone is also supported in the Armv8-M profile, but it has been adapted for microcontrollers with a more straightforward implementation suitable for resource-constrained systems.</li>
</ul>
</li>
<li>
<p>Memory Management:</p>
<ul>
<li>Armv8-A: This profile supports a Memory Management Unit (MMU), which allows for virtual memory and advanced memory protection features, suitable for complex systems like smartphones and servers.</li>
<li>Armv8-M: It supports a Memory Protection Unit (MPU) instead of an MMU, providing basic memory protection and segmentation without virtual memory support. This is more appropriate for simple, low-power systems.</li>
</ul>
</li>
<li>
<p>Exception Levels and Privilege Modes:</p>
<ul>
<li>Armv8-A: It supports multiple exception levels (EL0-EL3) and privilege modes, providing a flexible and sophisticated mechanism for handling exceptions and managing system resources.</li>
<li>Armv8-M: It has a simpler exception model with fewer privilege modes, which is more suitable for microcontrollers and low-power systems.</li>
</ul>
</li>
</ol>
<p>In summary, Armv8-A is designed for high-performance systems and supports both 32-bit and 64-bit instruction sets, while Armv8-M is targeted at low-power microcontrollers and supports only the 32-bit instruction set. The memory management, TrustZone implementation, and exception handling mechanisms are also tailored to the specific needs of their target applications.</p>
<hr>
</article></body></html>