<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
    color:#333;
    background:#fff;
}

body .markdown-body {
    padding: 45px;
    word-wrap: break-word;
}

.markdown-body .octicon-link:before {
  font: normal normal normal 16px/1 octicons-link;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  content: '\f05c';
  vertical-align: middle;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
</style><title>230327.OP-TEE</title></head><body><article class="markdown-body"><h1 id="user-content-230327op-tee"><a class="heading-link" href="#230327op-tee">230327.OP-TEE<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<p>Created: 2023-11-08 14:15:23</p>
<h1 id="user-content-questions"><a class="heading-link" href="#questions">Questions<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<ul>
<li>Basic Concepts
<ul>
<li>
<a href="https://github.com/OP-TEE">https://github.com/OP-TEE</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is thre prefix OP of OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Are there alternative technologies of OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does OP-TEE a software or a hardware solution? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Is OP-TEE a firmware? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does OP-TEE only exist in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Are there successfull cases of OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What are different between ARM OP-TEE and Intel SMM? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is OP-TEE Dispatcher? <span><code>[title]</code></span> <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Boot
<ul>
<li>Does OP-TEE OS exist in a single core or multiple cores at run-time? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Why does OP-TEE's reset function have two branches reset_primary and reset_secondary? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Why does OP-TEE initialize secondary cores when reset? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Can I reset OP-TEE at run-time? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Where does OP-TEE initialize secondary cores? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Below code comes from part 1 of entry_a64.S of OP-TEE <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Below code comes from part 2 of entry_a64.S of OP-TEE <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Where to set up secondary cores in the given code? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Where to reset primary core in the given code? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>When to enable secondary cores in OP-TEE? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Please list functions and macros in entry_a64.S that I give you before. <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Please list functions called in entry_a64.S that I give you before. <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is psci? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Who to call vector_cpu_on_entry? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What does vector_cpu_on_entry do with respect to OP-TEE? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What are difference boot of OP-TEE between AArch64 and AArch32? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Multi-Thread &amp; Multi-Process
<ul>
<li>Can secure kernel and trusted applications in OP-TEE can be multi-thread? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is secure context switching in TrustZone? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does OP-TEE support multi-process? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does OP-TEE support IPC? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Is a TA assigned to only one thread? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Memory
<ul>
<li>Does OP-TEE support shared memory? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Can secure world can access memory in normal world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Can normal world access memory in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How does OP-TEE manage memory? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Are data in memory in secure world encrypted? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is SMAF? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Is SMAF of OP-TEE? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Who can allocate SMAF memory? TA or CA <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is CMA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Network
<ul>
<li>Does OP-TEE support network communication in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Signature
<ul>
<li>Is signature required when a normal world application request a service in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does OP-TEE support to verify a signature of a TA in X.509 certificate? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Development
<ul>
<li>Which languages do I use to develop apps in OP-TEE or to customize OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Can I use other langauges? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does OP-TEE have a shell? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is about size of tee.bin? <code>(2023-04-12)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is libteec.so? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does libteec.so run in EL0 or EL1? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does optee.ko run in EL1? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is TEE supplicant? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Static TA and Dynamic TA
<ul>
<li>What are Static TA and Dynamic TA? Please also summarize them in a table. <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does TEE define Static TA and Dynamic TA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Can I create a TA at run-time? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>But what is TEECI_LoadSecureModule() <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How to recover a crashed static TA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How to recover a crashed dynamic TA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Which privilege levels do static TA and dynamic TA run in? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Qualcomm
<ul>
<li>Does Qualcomm support OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Is QTEE open source? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>DRM
<ul>
<li>How do I implement DRM of content decryption with OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>So the content is decrypted in TA in secure world. Right? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>But does it slow down the playback speed because of switching between normal world and secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Can I use multi cores to solve the problem? For example, one core decrypts content and another core play content at the same time. <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How do I implement a DRM solution using ClearKey in OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Below text comes from "BKK16-201 - PlayReady OPTEE Integration with Secure Video Path" <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is secure data path? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>So the video is played in secure world. Right? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How do we protect the video that displays in normal world? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is "EME with OP-TEE on Hikey"? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is AES OCDMI? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How is SMAF used in DRM? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is OCDM? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is Clear Key? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Secure Storage
<ul>
<li>Does OP-TEE support file system? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How does OP-TEE generate SSK from HUK in tee_fs_init_key_manager()? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>In the function, can I read the content of the HUK? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How do I protect HUK from reading in OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Is SSK defined in GlobalPlatform? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Recover OP-TEE
<ul>
<li>How to detect OP-TEE dead? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How to automatically recovery the crashed OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Can I develop a dual OP-TEE so that if one is crashed, run another. <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How to detect if OP-TEE is tamperred at run-time? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Attack
<ul>
<li>Whare are kinds of methods to attack OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>Virtualization
<ul>
<li>The following article are from the website <a href="https://optee.readthedocs.io/en/latest/architecture/virtualization.html" rel="nofollow">https://optee.readthedocs.io/en/latest/architecture/virtualization.html</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does the hypervisor relied on OP-TEE run in normal world or secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does OP-TEE support VMs? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Is the technology of OP-TEE supporting VMs mature? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>Does a TA run in a VM described in the article? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
<li>PKCS#11
<ul>
<li>The following text are from <a href="https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html" rel="nofollow">https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>The following continued text are from <a href="https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html" rel="nofollow">https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What is HUK? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>How does OP-TEE work with HUK? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>What are common device that store HUK in ARM platform with OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code>
</li>
<li>So what is TSK? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="user-content-q--a"><a class="heading-link" href="#q--a">Q &amp; A<span aria-hidden="true" class="octicon octicon-link"></span></a></h1>
<h2 id="user-content-basic-concepts"><a class="heading-link" href="#basic-concepts">Basic Concepts<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> <a href="https://github.com/OP-TEE">https://github.com/OP-TEE</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> What is OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> What is thre prefix OP of OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The prefix "OP" in OP-TEE stands for "Open Portable." It signifies that the project is an open-source implementation of a Trusted Execution Environment (TEE) that can be portably used across various platforms, mainly built around Arm TrustZone technology. The name highlights the goals of providing both transparency and flexibility to developers and users who want to create secure applications and services on a wide range of devices.</p>
<hr>
<p><strong>Question:</strong> Are there alternative technologies of OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, there are alternative technologies to OP-TEE that provide trusted execution environments or similar security features. Some of them include:</p>
<ol>
<li>
<p>Intel SGX (Software Guard Extensions): Intel SGX is a set of security-related instruction codes that are built into some Intel CPUs. It allows developers to create secure enclaves, which are isolated memory regions that protect sensitive data and code from unauthorized access, even from the host operating system or a hypervisor.</p>
</li>
<li>
<p>AMD SEV (Secure Encrypted Virtualization): AMD SEV is a hardware feature found in some AMD processors that encrypts the memory of virtual machines to protect data from unauthorized access. It aims to provide a secure execution environment for applications running in virtualized environments.</p>
</li>
<li>
<p>ARM TrustZone-M: TrustZone-M is a security extension for ARM Cortex-M processors, targeting microcontroller devices used in IoT, industrial control, and other embedded systems. While OP-TEE targets TrustZone technology in application processors, TrustZone-M is tailored for microcontrollers.</p>
</li>
<li>
<p>Google Titan M: Titan M is a custom security chip developed by Google to provide a secure environment for storing sensitive data and performing cryptographic operations on its Pixel smartphones. It is designed to protect the integrity of the bootloader, verify the operating system, and secure user data.</p>
</li>
<li>
<p>Apple Secure Enclave: The Secure Enclave is a coprocessor found in Apple devices, such as iPhones and iPads, that provides a secure environment for cryptographic operations and storage of sensitive data like encryption keys, biometric information, and device passcodes.</p>
</li>
</ol>
<p>These technologies may have different implementations, features, and target applications, but they all aim to enhance security by providing isolated execution environments and protecting sensitive data from unauthorized access.</p>
<hr>
<p><strong>Question:</strong> Does OP-TEE a software or a hardware solution? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE is primarily a software solution that leverages underlying hardware capabilities, specifically Arm TrustZone technology, to provide a secure and trusted execution environment for software applications on devices.</p>
<p>OP-TEE includes a secure kernel, trusted applications, and APIs that enable secure communication between the normal and secure worlds. While OP-TEE is a software implementation, it relies on the hardware-based security features provided by Arm TrustZone to create a separate, secure area for sensitive data and code execution.</p>
<p>In summary, OP-TEE is a software solution that takes advantage of hardware-based security technologies to achieve its goals of providing a secure environment for running trusted applications.</p>
<hr>
<p><strong>Question:</strong> Is OP-TEE a firmware? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE can be considered a firmware component, as it is a low-level software that interacts directly with the hardware and provides security services to the system. It serves as the trusted execution environment for devices using Arm TrustZone technology.</p>
<p>Firmware is a type of software that is typically stored in non-volatile memory and provides basic functionality or services to a device's hardware. In the case of OP-TEE, it provides the secure kernel, trusted applications, and APIs for managing and interacting with the secure environment.</p>
<p>OP-TEE is often integrated into the boot process of a device, alongside other firmware components like the bootloader, and it initializes the secure environment before the main operating system starts. This ensures that the secure services and trusted applications provided by OP-TEE are available to the system throughout its operation.</p>
<hr>
<p><strong>Question:</strong> Does OP-TEE only exist in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE is a Trusted Execution Environment (TEE) that leverages Arm TrustZone technology, which provides hardware-based isolation between the normal world and the secure world. OP-TEE consists of components that exist in both the normal world and the secure world.</p>
<ol>
<li>Secure world components:</li>
</ol>
<ul>
<li>Secure kernel: The OP-TEE secure kernel resides in the secure world and manages trusted applications, secure memory, and communication between the normal world and the secure world.</li>
<li>Trusted applications: These are secure services or applications that run in the secure world and provide functionality that requires a higher level of security and isolation.</li>
</ul>
<ol start="2">
<li>Normal world components:</li>
</ol>
<ul>
<li>TEE Client API: This is a library that normal world applications use to communicate with the secure world. It provides an interface for opening sessions, invoking commands, and managing shared memory with trusted applications.</li>
<li>TEE supplicant: The TEE supplicant is a user-space daemon in the normal world that handles certain requests from the secure world, such as loading trusted applications, filesystem operations, and cryptographic operations that involve the normal world's resources.</li>
</ul>
<p>Both the secure world and normal world components of OP-TEE work together to provide a secure and isolated environment for trusted applications, as well as a communication channel between normal world applications and the secure world.</p>
<p>In summary, OP-TEE does not only exist in the secure world. It consists of components in both the normal world and the secure world to create a comprehensive TEE solution that leverages Arm TrustZone technology.</p>
<hr>
<p><strong>Question:</strong> Are there successfull cases of OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, there have been successful use cases of OP-TEE across various industries and applications that require a secure and trusted execution environment. Some of these include:</p>
<ol>
<li>
<p>Mobile devices: OP-TEE is used in mobile devices like smartphones and tablets to provide a secure environment for handling sensitive data, such as biometric information, cryptographic keys, and DRM (Digital Rights Management) protection.</p>
</li>
<li>
<p>IoT devices: Internet of Things (IoT) devices, such as smart home appliances, wearables, and industrial sensors, benefit from the security provided by OP-TEE. It enables these devices to handle sensitive data securely, execute cryptographic operations, and maintain the confidentiality and integrity of the data being transmitted.</p>
</li>
<li>
<p>Automotive systems: OP-TEE can be used in automotive systems to secure in-vehicle communication, protect sensitive data, and enable secure over-the-air updates.</p>
</li>
<li>
<p>Payment systems: OP-TEE can provide a secure environment for payment applications, ensuring the confidentiality and integrity of financial transactions and sensitive user data.</p>
</li>
<li>
<p>Healthcare devices: Medical devices and healthcare systems can utilize OP-TEE to securely store and process patient data, protecting it from unauthorized access and tampering.</p>
</li>
</ol>
<p>While specific implementations may vary, these examples demonstrate the versatility and effectiveness of OP-TEE in providing a secure and trusted environment for a wide range of applications. The open-source nature of OP-TEE also makes it possible for developers and organizations to customize and adapt the software to fit their unique security requirements.</p>
<hr>
<p><strong>Question:</strong> What are different between ARM OP-TEE and Intel SMM? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>ARM OP-TEE and Intel SMM are different security technologies that provide secure and isolated execution environments for sensitive operations. Here's a comparison of the two:</p>
<ol>
<li>ARM OP-TEE:</li>
</ol>
<ul>
<li>Primarily designed for ARM-based platforms using TrustZone technology.</li>
<li>Open-source implementation, maintained by Linaro.</li>
<li>Provides a secure kernel, trusted applications, and APIs for communication between the normal and secure worlds.</li>
<li>Focuses on creating a Trusted Execution Environment (TEE) for secure application execution.</li>
<li>Targets a variety of industries, including mobile devices, IoT, automotive systems, and more.</li>
</ul>
<ol start="2">
<li>Intel SMM (System Management Mode):</li>
</ol>
<ul>
<li>Designed for Intel x86 processors.</li>
<li>A proprietary implementation by Intel.</li>
<li>Provides a separate CPU mode (SMM) with its own address space and execution environment.</li>
<li>Focuses on handling low-level system management tasks, such as power management, hardware monitoring, and firmware updates.</li>
<li>Primarily used for system management tasks on PCs, servers, and other x86-based systems.</li>
</ul>
<p>Summary in a table:</p>
<table>
<thead>
<tr>
<th>Feature/Aspect</th>
<th>ARM OP-TEE</th>
<th>Intel SMM</th>
</tr>
</thead>
<tbody>
<tr>
<td>Platform</td>
<td>ARM-based systems</td>
<td>Intel x86 processors</td>
</tr>
<tr>
<td>Implementation</td>
<td>Open-source</td>
<td>Proprietary</td>
</tr>
<tr>
<td>Primary Focus</td>
<td>Trusted Execution Environment (TEE)</td>
<td>System Management Tasks</td>
</tr>
<tr>
<td>Typical Applications</td>
<td>Mobile, IoT, automotive, etc.</td>
<td>PCs, servers, x86-based systems</td>
</tr>
<tr>
<td>Architecture</td>
<td>ARM TrustZone</td>
<td>System Management Mode</td>
</tr>
</tbody>
</table>
<p>Please note that while both technologies provide a secure and isolated execution environment, they serve different purposes and target different platforms. ARM OP-TEE is designed to enable secure applications on ARM-based devices, while Intel SMM is used for low-level system management tasks on Intel x86-based systems.</p>
<hr>
<p><strong>Question:</strong> What is OP-TEE Dispatcher? <span><code>[title]</code></span> <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The OP-TEE dispatcher, sometimes referred to as the "Secure Monitor Call (SMC) dispatcher" or simply "dispatcher," is a component within the OP-TEE Trusted Execution Environment that handles communication between the normal world (non-secure) and the secure world (OP-TEE environment).</p>
<p>When a client application (CA) in the normal world wants to communicate with a trusted application (TA) in the secure world, it sends a request through the OP-TEE driver (opteed) in the form of an SMC call. The SMC call is then intercepted by the OP-TEE dispatcher, which is responsible for processing the call, routing it to the appropriate TA, and returning the results back to the caller.</p>
<p>The dispatcher is responsible for managing the communication and ensuring the security and isolation of the TAs from the normal world, as well as handling secure world tasks such as opening and closing sessions, invoking commands, and managing shared memory.</p>
<p>In summary, the OP-TEE dispatcher is a crucial component that bridges the gap between the normal world and the secure world, ensuring secure communication and execution of trusted applications within the OP-TEE environment.</p>
<hr>
<h2 id="user-content-boot"><a class="heading-link" href="#boot">Boot<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Does OP-TEE OS exist in a single core or multiple cores at run-time? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>At runtime, the OP-TEE OS exists in a single core. It is designed to run on one core at a time in the secure world. However, OP-TEE supports concurrent execution of Trusted Applications (TAs) on different CPU cores. Although the OS itself runs on a single core, it can manage and schedule TAs running on separate cores, ensuring proper execution and isolation.</p>
<hr>
<p><strong>Question:</strong> Why does OP-TEE's reset function have two branches reset_primary and reset_secondary? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE, the reset function has two branches, <code>reset_primary</code> and <code>reset_secondary</code>, to handle the initialization process for multi-core systems. These branches are responsible for initializing the primary and secondary CPU cores, respectively, within the OP-TEE secure world.</p>
<ol>
<li>
<p><code>reset_primary</code>: This branch handles the initialization of the primary CPU core (core 0). The primary core is responsible for setting up the secure environment, initializing the secure kernel, and starting the other secondary cores. The primary core performs tasks such as configuring the MMU (Memory Management Unit), initializing the secure memory, setting up the interrupt controller, and more. Once the primary core has completed its initialization tasks, it starts executing the secure kernel.</p>
</li>
<li>
<p><code>reset_secondary</code>: This branch handles the initialization of secondary CPU cores (core 1, core 2, etc.). The secondary cores also need to set up their own environment, such as configuring their local MMU and enabling their local interrupts, before they can start executing the secure kernel. The primary core signals the secondary cores to begin their initialization process after it has completed its own initialization.</p>
</li>
</ol>
<p>The distinction between <code>reset_primary</code> and <code>reset_secondary</code> branches ensures that the primary core properly initializes the secure environment before the secondary cores start executing the secure kernel. This separation helps maintain a correct and secure boot process in multi-core systems, where multiple CPU cores need to work together within the secure world.</p>
<p>In summary, OP-TEE's reset function has two branches, <code>reset_primary</code> and <code>reset_secondary</code>, to handle the initialization process for multi-core systems, ensuring that the primary core sets up the secure environment correctly before the secondary cores start executing the secure kernel.</p>
<hr>
<p><strong>Question:</strong> Why does OP-TEE initialize secondary cores when reset? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE initializes secondary cores during the reset process to properly configure and synchronize them with the primary core. This is important for maintaining a consistent and secure execution environment across all cores.</p>
<p>When the system is reset, the primary core (core 0) is responsible for initializing the OP-TEE OS, including the secure world and shared resources. Once the primary core has completed the initialization process, it sends a signal to secondary cores to begin their own initialization process. Each secondary core then initializes its own secure world environment and sets up necessary data structures and configurations in alignment with the primary core.</p>
<p>This process ensures that all cores have a consistent view of the secure world, enabling the execution of Trusted Applications (TAs) across multiple cores while maintaining security and isolation.</p>
<hr>
<p><strong>Question:</strong> Can I reset OP-TEE at run-time? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>There isn't a direct mechanism to reset only the OP-TEE (Trusted Execution Environment) at runtime without affecting the rest of the system. OP-TEE runs alongside the Normal World operating system, and both share the same hardware resources.</p>
<p>Resetting the OP-TEE runtime would essentially require resetting the entire system, which would include the Normal World operating system (such as Linux). This is because OP-TEE interacts with the Normal World through shared memory and interrupt handling, and resetting OP-TEE without restarting the entire system may lead to undefined behavior or security vulnerabilities.</p>
<p>If you need to reset the state of a Trusted Application running within OP-TEE, you can unload the TA and reload it, essentially resetting the TA's state. However, this approach only resets the specific TA and not the entire OP-TEE environment.</p>
<hr>
<p><strong>Question:</strong> Where does OP-TEE initialize secondary cores? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE initializes secondary cores during its boot process. The initialization happens in the <code>optee_os</code> codebase, which is the core component of OP-TEE. Specifically, the initialization can be found in the <code>core/arch/arm/kernel/</code> directory.</p>
<p>For ARM platforms, the file <code>core/arch/arm/kernel/entry_a32.S</code> (for 32-bit systems) or <code>core/arch/arm/kernel/entry_a64.S</code> (for 64-bit systems) contains the assembly code responsible for the secondary core initialization.</p>
<p>Secondary core initialization consists of the following steps:</p>
<ol>
<li>Setup the core's stack pointer.</li>
<li>Enable the core's caches and MMU.</li>
<li>Initialize the core's GIC (Generic Interrupt Controller) interface.</li>
<li>Jump to the C function <code>__thread_std_smc_entry()</code> which handles the core's SMC (Secure Monitor Call) entry.</li>
</ol>
<p>The actual boot process of the secondary cores is platform-specific and depends on the hardware and the bootloader used. In general, when the primary core starts the OP-TEE, it initializes the secondary cores, and they are put into a waiting state until they receive a wake-up event. The primary core is responsible for configuring and releasing the secondary cores from their waiting state.</p>
<hr>
<p><strong>Question:</strong> Below code comes from part 1 of entry_a64.S of OP-TEE <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> Below code comes from part 2 of entry_a64.S of OP-TEE <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> Where to set up secondary cores in the given code? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the given code, the secondary cores setup is handled by the <code>cpu_on_handler</code> function. This function is responsible for preparing the secondary core when it is powered on. Here's an overview of the <code>cpu_on_handler</code> function:</p>
<div class="highlight highlight-source-assembly"><pre><span class="pl-en">FUNC cpu_on_handler </span><span class="pl-s1">,</span><span class="pl-en"> :</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x19</span><span class="pl-s1">,</span><span class="pl-en"> x0</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x20</span><span class="pl-s1">,</span><span class="pl-en"> x1</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x21</span><span class="pl-s1">,</span><span class="pl-en"> x30</span>

<span class="pl-en">    adr	x0</span><span class="pl-s1">,</span><span class="pl-en"> reset_vect_table</span>
<span class="pl-en">    msr	vbar_el1</span><span class="pl-s1">,</span><span class="pl-en"> x0</span>
<span class="pl-en">    isb</span>

<span class="pl-en">    set_sctlr_el1</span>
<span class="pl-en">    isb</span>

<span class="pl-en">    /</span><span class="pl-s1">*</span><span class="pl-en"> Enable aborts now th</span><span class="pl-c1">at</span> <span class="pl-en">we can receive exceptions </span><span class="pl-s1">*</span><span class="pl-en">/</span>
<span class="pl-en">    msr	daifclr</span><span class="pl-s1">,</span><span class="pl-en"> #DAIFBIT_ABT</span>

<span class="pl-en">    </span><span class="pl-v">bl</span><span class="pl-en">	__get_core_pos</span>
<span class="pl-en">    </span><span class="pl-v">bl</span><span class="pl-en">	enable_mmu</span>

<span class="pl-en">    /</span><span class="pl-s1">*</span><span class="pl-en"> Setup SP_EL0 </span><span class="pl-k">and</span><span class="pl-en"> SP_EL1</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">SP</span><span class="pl-en"> will be set to SP_EL0 </span><span class="pl-s1">*</span><span class="pl-en">/</span>
<span class="pl-en">    set_sp</span>

<span class="pl-en">#ifdef CFG_MEMTAG</span>
<span class="pl-en">    init_memtag_per_</span><span class="pl-c1">cpu</span>
<span class="pl-en">#endif</span>
<span class="pl-en">#ifdef CFG_CORE_PAUTH</span>
<span class="pl-en">    init_pauth_per_</span><span class="pl-c1">cpu</span>
<span class="pl-en">#endif</span>

<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x0</span><span class="pl-s1">,</span><span class="pl-en"> x19</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x1</span><span class="pl-s1">,</span><span class="pl-en"> x20</span>
<span class="pl-en">#ifdef CFG_CORE_FFA</span>
<span class="pl-en">    </span><span class="pl-v">bl</span><span class="pl-en">	boot_cpu_on_handler</span>
<span class="pl-en">    b	thread_ffa_msg_wait</span>
<span class="pl-en">#else</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en">	x30</span><span class="pl-s1">,</span><span class="pl-en"> x21</span>
<span class="pl-en">    b	boot_cpu_on_handler</span>
<span class="pl-en">#endif</span>
<span class="pl-en">END_FUNC cpu_on_handler</span></pre></div>
<p>The <code>cpu_on_handler</code> function does the following:</p>
<ol>
<li>Sets up the exception vector table by loading the address of <code>reset_vect_table</code> into the <code>vbar_el1</code> register.</li>
<li>Configures the System Control Register (<code>sctlr_el1</code>) and enables aborts to receive exceptions.</li>
<li>Gets the core position and enables the MMU.</li>
<li>Sets up the stack pointers for the current Exception Level (EL) by calling <code>set_sp</code>.</li>
<li>Initializes per-core features like memory tagging and pointer authentication if they are enabled (CFG_MEMTAG, CFG_CORE_PAUTH).</li>
<li>Calls the <code>boot_cpu_on_handler</code> function to complete the setup for the secondary core.</li>
</ol>
<p>After the setup is complete, the secondary core will either wait for a Fast Function call (in case of CFG_CORE_FFA) or continue with the execution of the <code>boot_cpu_on_handler</code> function.</p>
<hr>
<p><strong>Question:</strong> Where to reset primary core in the given code? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the given code, there's no specific mention of a function or a code block that explicitly resets the primary core. However, if you need to reset the primary core, you can create a custom function that will perform the necessary actions, such as disabling interrupts and performing a soft reset.</p>
<p>You could create a function like this:</p>
<div class="highlight highlight-source-c"><pre><span class="pl-smi">void</span> <span class="pl-en">reset_primary_core</span>(<span class="pl-smi">void</span>)
{
    <span class="pl-c">// Disable interrupts</span>
    <span class="pl-en">local_irq_disable</span>();
    <span class="pl-en">local_fiq_disable</span>();

    <span class="pl-c">// Perform a soft reset</span>
    <span class="pl-smi">uintptr_t</span> <span class="pl-s1">reset_address</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-c">// Replace 0 with the address of the reset handler for your system</span>
    <span class="pl-smi">void</span> (<span class="pl-c1">*</span><span class="pl-s1">reset_handler</span>)(<span class="pl-smi">void</span>) <span class="pl-c1">=</span> (<span class="pl-smi">void</span> (<span class="pl-c1">*</span>)(<span class="pl-smi">void</span>))<span class="pl-s1">reset_address</span>;
    <span class="pl-en">reset_handler</span>();
}</pre></div>
<p>Keep in mind that the exact process for resetting the primary core depends on your system's architecture and hardware. The example above is just a basic idea of how you could approach resetting the primary core. You will need to consult your system's documentation and adapt the code accordingly.</p>
<hr>
<p><strong>Question:</strong> When to enable secondary cores in OP-TEE? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE (Open Portable Trusted Execution Environment), secondary cores are typically enabled during the boot process, after the primary core has completed initialization tasks, including setting up secure memory, initializing OP-TEE, and launching the Rich Execution Environment (REE).</p>
<p>To enable secondary cores in OP-TEE, follow these steps:</p>
<ol>
<li>
<p>Primary core initialization: The primary core initializes OP-TEE and other necessary system components. It sets up the secure memory, initializes the OP-TEE OS, and starts the REE (e.g., Linux kernel).</p>
</li>
<li>
<p>Secondary core synchronization: The primary core waits for secondary cores to reach a synchronization point, usually through a spin loop. Secondary cores wait for a signal from the primary core to continue the boot process.</p>
</li>
<li>
<p>Signal secondary cores: Once the primary core finishes the initialization process, it signals the secondary cores to continue the boot process. This can be done by writing a value to a shared memory location or using hardware-specific mechanisms.</p>
</li>
<li>
<p>Secondary core initialization: Secondary cores initialize their local data structures and set up their own exception handlers. They also initialize their stack pointers and register with the OP-TEE OS.</p>
</li>
<li>
<p>Secondary cores enter OP-TEE: Secondary cores enter the OP-TEE OS and start executing secure tasks.</p>
</li>
</ol>
<p>The exact implementation details of enabling secondary cores may vary depending on the platform, hardware, and OP-TEE version. The steps mentioned above provide a general guideline for the process. To understand the specifics for your platform, refer to the platform-specific documentation and code available in the OP-TEE source tree.</p>
<hr>
<p><strong>Question:</strong> Please list functions and macros in entry_a64.S that I give you before. <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Based on the code you provided earlier, here is a list of functions and macros in entry_a64.S:</p>
<p>Functions:</p>
<ol>
<li>_start</li>
<li>relocate (if CFG_CORE_ASLR is defined)</li>
<li>enable_mmu</li>
<li>cpu_on_handler</li>
<li>unhandled_cpu</li>
<li>reset_vect_table</li>
</ol>
<p>Macros:</p>
<ol>
<li>check_vector_size</li>
<li>BTI (if defined)</li>
</ol>
<p>If you have any questions or need further information about these functions or macros, please let me know!</p>
<hr>
<p><strong>Question:</strong> Please list functions called in entry_a64.S that I give you before. <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Here is a list of functions called in the entry_a64.S code you provided earlier:</p>
<ol>
<li>boot_init_memtag (if CFG_MEMTAG is defined)</li>
<li>get_aslr_seed (if CFG_CORE_ASLR is defined)</li>
<li>core_init_mmu_map</li>
<li>__get_core_pos</li>
<li>enable_mmu</li>
<li>console_init (if CFG_CORE_ASLR is defined)</li>
<li>core_mmu_set_default_prtn_tbl (if CFG_NS_VIRTUALIZATION is defined)</li>
<li>boot_init_primary_early</li>
<li>init_memtag_per_cpu (if CFG_MEMTAG is defined)</li>
<li>thread_get_core_local</li>
<li>boot_init_primary_late</li>
<li>init_pauth_per_cpu (if CFG_CORE_PAUTH is defined)</li>
<li>plat_get_random_stack_canary (if _CFG_CORE_STACK_PROTECTOR is defined)</li>
<li>dcache_cleaninv_range</li>
<li>thread_clr_boot_thread (if CFG_NS_VIRTUALIZATION is not defined)</li>
<li>thread_spmc_register_secondary_ep (if CFG_CORE_FFA is defined)</li>
<li>thread_ffa_msg_wait (if CFG_CORE_FFA is defined)</li>
<li>boot_cpu_on_handler (if CFG_CORE_FFA is not defined)</li>
<li>panic_at_smc_return (if CFG_CORE_FFA is not defined)</li>
</ol>
<p>These are the functions called in the provided entry_a64.S file.</p>
<hr>
<p><strong>Question:</strong> What is psci? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>PSCI (Power State Coordination Interface) is a standardized interface for power management in ARM-based systems, specifically targeting multicore and multiprocessor SoCs (System on a Chip). The PSCI specification is developed and maintained by ARM and provides a common API for software running on ARM-based systems to control power states of CPUs and the system as a whole.</p>
<p>PSCI enables software layers, such as operating systems and hypervisors, to manage the power state of individual CPU cores and clusters of cores, as well as to perform system-level power management tasks, such as system suspend and resume. The PSCI interface is typically implemented in firmware and is accessible to the software layers through a defined set of SMC (Secure Monitor Call) instructions.</p>
<p>Some common PSCI functions include:</p>
<ol>
<li>CPU_ON: Used to power on a specific CPU core.</li>
<li>CPU_OFF: Powers off the calling CPU core.</li>
<li>CPU_SUSPEND: Suspends the calling CPU core.</li>
<li>CPU_RESUME: Resumes a suspended CPU core.</li>
<li>SYSTEM_SUSPEND: Suspends the entire system.</li>
<li>SYSTEM_RESET: Performs a system reset.</li>
<li>SYSTEM_OFF: Powers off the entire system.</li>
</ol>
<p>PSCI allows for better coordination of power management across different cores and system components, which is essential for efficient energy usage and optimized performance in modern ARM-based systems.</p>
<hr>
<p><strong>Question:</strong> Who to call vector_cpu_on_entry? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>vector_cpu_on_entry</code> is a function that is typically called when a CPU core is powered on in the context of an ARM-based system using PSCI for power management. The function is usually defined in the low-level firmware, such as ARM Trusted Firmware (ATF) or U-Boot.</p>
<p>To call <code>vector_cpu_on_entry</code>, you will need to use the PSCI interface. The <code>CPU_ON</code> PSCI function is used to power on a specific CPU core, and it's usually called by the operating system or another higher-level software component that manages power states of the CPU cores.</p>
<p>Here's an example of how you might call the <code>CPU_ON</code> function using PSCI:</p>
<ol>
<li>Prepare the necessary arguments, such as the target CPU's MPIDR (Multiprocessor Affinity Register) and the entry point address of the <code>vector_cpu_on_entry</code> function.</li>
<li>Issue an SMC (Secure Monitor Call) instruction with the appropriate PSCI function ID for <code>CPU_ON</code> and the prepared arguments.</li>
</ol>
<p>Please note that the actual implementation details will depend on your specific system configuration and the software components you are using. The operating system, hypervisor, or other system software components usually take care of calling the PSCI <code>CPU_ON</code> function and setting up the necessary entry points. As a developer, you typically don't need to call the <code>vector_cpu_on_entry</code> function directly.</p>
<hr>
<p><strong>Question:</strong> What does vector_cpu_on_entry do with respect to OP-TEE? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>vector_cpu_on_entry</code> is not a specific function in OP-TEE. However, I believe you are referring to a generic concept of an entry point for secondary cores in a multi-core system.</p>
<p>In OP-TEE, the entry point for secondary cores is defined in <code>core/arch/arm/kernel/entry_a64.S</code> (for ARMv8-A) or <code>core/arch/arm/kernel/entry_a32.S</code> (for ARMv7-A) depending on the architecture. The entry point function is named <code>__secondary_init</code> for both ARMv8-A and ARMv7-A architectures.</p>
<p>When a secondary core is powered on in a multi-core system, the ATF (ARM Trusted Firmware) handles the process and sets up the appropriate entry points for both the non-secure world (e.g., the operating system) and the secure world (e.g., OP-TEE). The secondary core then starts executing the OP-TEE code at the <code>__secondary_init</code> entry point in the secure world.</p>
<p>The <code>__secondary_init</code> function performs the following tasks:</p>
<ol>
<li>Initialize the secondary core's CPU registers.</li>
<li>Set up the MMU and configure the memory map.</li>
<li>Call <code>generic_entry_a64</code> (for ARMv8-A) or <code>generic_entry_a32</code> (for ARMv7-A) to perform generic initialization, such as setting up the stack, enabling interrupts, and initializing the core's private GIC (Generic Interrupt Controller) interface.</li>
<li>Call <code>thread_init_per_cpu</code> to initialize the per-CPU data structures.</li>
<li>Enter the main scheduler loop by calling <code>thread_std_smc_entry</code> (for ARMv8-A) or <code>thread_std_svc_entry</code> (for ARMv7-A).</li>
</ol>
<p>After these steps, the secondary core is ready to execute secure tasks in OP-TEE along with the primary core.</p>
<hr>
<p><strong>Question:</strong> What are difference boot of OP-TEE between AArch64 and AArch32? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE supports both AArch64 (ARMv8-A) and AArch32 (ARMv7-A) architectures. While the overall boot process is similar for both, there are some differences due to the architectural distinctions. Here are the main differences in the boot process of OP-TEE between AArch64 and AArch32:</p>
<ol>
<li>
<p><strong>Entry point</strong>: The entry point for the primary core is different for AArch64 and AArch32. In AArch64, it's defined in <code>core/arch/arm/kernel/entry_a64.S</code>, while in AArch32, it's defined in <code>core/arch/arm/kernel/entry_a32.S</code>.</p>
</li>
<li>
<p><strong>Register usage</strong>: AArch64 and AArch32 have different register usage conventions. AArch64 has 31 general-purpose registers (X0-X30), while AArch32 has 16 general-purpose registers (R0-R15). The register naming and usage in the assembly code for these architectures will differ.</p>
</li>
<li>
<p><strong>MMU setup</strong>: AArch64 uses a different memory translation scheme compared to AArch32. Consequently, the MMU configuration code in <code>core/arch/arm/mm/core_mmu_lpae.c</code> (for AArch64) and <code>core/arch/arm/mm/core_mmu_v7.c</code> (for AArch32) differ in setting up the translation tables and configuring the memory attributes.</p>
</li>
<li>
<p><strong>Exception levels</strong>: AArch64 introduces Exception Levels (EL0-EL3) that define different privilege levels for software execution. AArch32 uses the traditional ARM privilege levels (User, FIQ, IRQ, Supervisor, Abort, and Undefined) instead. The exception handling and context switching code will differ between the two architectures due to this distinction.</p>
</li>
<li>
<p><strong>Interrupt handling</strong>: AArch64 uses the GICv3 interrupt controller, while AArch32 typically uses the GICv2 interrupt controller. The initialization and handling of interrupts will differ between the two architectures due to the differences in GIC versions.</p>
</li>
<li>
<p><strong>Function calling convention</strong>: AArch64 and AArch32 have different function calling conventions. For example, AArch64 passes the first eight arguments in registers X0-X7, while AArch32 passes arguments using registers R0-R3 and the stack. The assembly code for function calls and stack frame setup will differ between the two architectures.</p>
</li>
</ol>
<p>Despite these differences, the high-level boot process and functionality of OP-TEE remain consistent between AArch64 and AArch32. The architectural differences are primarily reflected in the low-level implementation details, such as register usage, memory management, and exception handling.</p>
<hr>
<h2 id="user-content-multi-thread--multi-process"><a class="heading-link" href="#multi-thread--multi-process">Multi-Thread &amp; Multi-Process<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Can secure kernel and trusted applications in OP-TEE can be multi-thread? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>As of now, the secure kernel and trusted applications in OP-TEE are primarily single-threaded. The secure world in OP-TEE does not support multi-threading within a single trusted application, meaning each trusted application can only execute one thread at a time.</p>
<p>However, OP-TEE does support parallelism in the sense that it allows multiple trusted applications to be loaded and executed concurrently. This is achieved through the use of secure context switching between different trusted applications, ensuring that only one trusted application is active at a time.</p>
<p>Although the secure environment itself is single-threaded, OP-TEE still enables concurrent communication with normal world applications. Multiple normal world applications can communicate with different trusted applications simultaneously, and OP-TEE will manage the context switching between them.</p>
<p>In summary, the secure kernel and trusted applications in OP-TEE are primarily single-threaded, but parallelism is achieved through secure context switching between multiple trusted applications and concurrent communication with normal world applications.</p>
<hr>
<p><strong>Question:</strong> What is secure context switching in TrustZone? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Secure context switching in TrustZone refers to the process of transitioning between different secure contexts (trusted applications) within the secure world while maintaining isolation and security. ARM TrustZone technology provides a hardware-based separation between the normal world and the secure world, allowing both to run independently and securely.</p>
<p>In the context of OP-TEE and TrustZone, when multiple trusted applications are running or when a normal world application requests a service from a trusted application, the secure kernel manages the execution of these trusted applications by performing secure context switching. This involves:</p>
<ol>
<li>
<p>Saving the current context: The secure kernel saves the current state of the active trusted application, including its register values and memory, in a secure location.</p>
</li>
<li>
<p>Restoring the new context: The secure kernel restores the state of the trusted application that is being switched to by loading its previously saved register values and memory.</p>
</li>
<li>
<p>Switching execution: The secure kernel transfers control to the new trusted application, allowing it to continue executing where it left off.</p>
</li>
</ol>
<p>Secure context switching ensures that each trusted application's state is kept separate and secure from others, maintaining isolation and preventing unauthorized access or tampering. Additionally, it allows the secure kernel to manage the concurrent execution of multiple trusted applications and handle requests from normal world applications efficiently.</p>
<p>In summary, secure context switching in TrustZone is the process of managing and transitioning between different trusted applications within the secure world while maintaining isolation, security, and efficient execution.</p>
<hr>
<p><strong>Question:</strong> Does OP-TEE support multi-process? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE supports multiple trusted applications (TAs) running concurrently within the secure environment provided by the Arm TrustZone. While the secure world in OP-TEE is primarily single-threaded, it can handle multiple processes in the form of trusted applications.</p>
<p>When multiple trusted applications are loaded and running, OP-TEE manages their execution using secure context switching. This ensures that only one trusted application is active at a time, while maintaining isolation and security between different trusted applications. The secure kernel in OP-TEE is responsible for managing resources, handling requests from the normal world, and switching between the trusted applications as needed.</p>
<p>On the normal world side, multiple processes can communicate with different trusted applications simultaneously, and OP-TEE will manage the context switching between them.</p>
<p>In summary, OP-TEE supports multi-process execution in the form of multiple trusted applications running concurrently within the secure environment, while also allowing multiple normal world processes to communicate with these trusted applications.</p>
<hr>
<p><strong>Question:</strong> Does OP-TEE support IPC? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, OP-TEE supports Inter-Process Communication (IPC) between trusted applications (TAs) within the secure world and between normal world applications and trusted applications.</p>
<ol>
<li>
<p>IPC between trusted applications: Trusted applications in OP-TEE can share data and communicate with each other by invoking other trusted applications. However, the secure kernel must intermediate such communication to ensure isolation and maintain security. Trusted applications use the TEE_InvokeTACommand function to invoke another trusted application and pass data as parameters.</p>
</li>
<li>
<p>IPC between normal world applications and trusted applications: OP-TEE supports communication between normal world applications and trusted applications through the GlobalPlatform TEE Client API. Normal world applications can open a session with a trusted application, invoke commands, and share data with the trusted application while maintaining security.</p>
</li>
</ol>
<p>In both cases, OP-TEE manages the IPC to ensure isolation between different trusted applications and maintain the security of the secure environment. While the communication mechanisms may vary, OP-TEE provides the necessary APIs and infrastructure to support IPC between trusted applications and between normal world applications and trusted applications.</p>
<hr>
<p><strong>Question:</strong> Is a TA assigned to only one thread? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE, a Trusted Application (TA) can be single or multi-threaded, depending on its design and implementation. However, OP-TEE employs a single-threaded model by default, which means that each TA instance is typically associated with one thread, and there is no concurrency within a single instance of the TA.</p>
<p>If an application requires concurrent access to the TA, multiple instances of the TA can be created. Each instance runs in a separate thread, and the TA developer must take care of synchronization and shared resources within the TA code.</p>
<p>In summary, a TA is not inherently limited to a single thread, but the default behavior in OP-TEE is to use one thread per TA instance. If the TA is designed to support multiple threads, it can be done, but the developer must handle synchronization and shared resources carefully.</p>
<hr>
<h2 id="user-content-memory"><a class="heading-link" href="#memory">Memory<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Does OP-TEE support shared memory? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, OP-TEE supports shared memory, which allows normal world applications to share data with trusted applications (TAs) within the secure environment. Shared memory is used for exchanging data between the normal world and the secure world while maintaining security and isolation.</p>
<p>In OP-TEE, shared memory is managed by the GlobalPlatform TEE Client API, which provides functions for allocating, registering, and releasing shared memory. When a normal world application wants to share data with a trusted application, it creates a shared memory buffer using these API functions. The shared memory buffer is then passed as a parameter to the trusted application when invoking a command.</p>
<p>The secure kernel in OP-TEE ensures that the shared memory buffer is accessible by both the normal world application and the trusted application while preventing unauthorized access or tampering. The secure kernel also maintains the isolation between different trusted applications by limiting access to the shared memory buffers associated with each trusted application.</p>
<p>Please note that shared memory in OP-TEE is primarily used for communication between normal world applications and trusted applications. Sharing memory directly between different trusted applications is generally not supported, as it can compromise the isolation and security provided by the secure environment. Instead, trusted applications communicate with each other using the TEE_InvokeTACommand function, as mentioned in a previous answer regarding IPC support.</p>
<p>In summary, OP-TEE supports shared memory for exchanging data between normal world applications and trusted applications while maintaining security and isolation within the secure environment.</p>
<hr>
<p><strong>Question:</strong> Can secure world can access memory in normal world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In general, the secure world in OP-TEE can access memory in the normal world, but it must do so with caution. The secure world has a higher level of privilege, allowing it to access both secure and normal world memory. However, accessing normal world memory from the secure world can introduce potential security risks, such as data leaks or manipulation of sensitive information.</p>
<p>To minimize such risks, OP-TEE employs a set of precautions and guidelines:</p>
<ol>
<li>
<p>Use shared memory: When secure world applications need to access data from the normal world, it is recommended to use shared memory, which is explicitly allocated and managed by the GlobalPlatform TEE Client API. This ensures proper isolation and access control for the shared data.</p>
</li>
<li>
<p>Validate memory addresses: If the secure world must access normal world memory directly, it should first validate the memory address range to ensure it doesn't overlap with secure memory or any other protected memory region.</p>
</li>
<li>
<p>Be cautious of data manipulation: The secure world should be aware that normal world memory can be manipulated or tampered with by potentially malicious software running in the normal world. Sensitive operations should not rely solely on data stored in normal world memory without additional validation or protection.</p>
</li>
<li>
<p>Minimize normal world memory access: The secure world should minimize direct access to normal world memory whenever possible and instead rely on secure memory or shared memory buffers for data exchange.</p>
</li>
</ol>
<p>While the secure world in OP-TEE can access normal world memory, it should be done with caution and following proper guidelines to maintain the security and isolation provided by the ARM TrustZone technology.</p>
<hr>
<p><strong>Question:</strong> Can normal world access memory in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the context of OP-TEE and Arm TrustZone technology, the normal world cannot directly access the memory in the secure world. The TrustZone technology enforces hardware-based isolation between the normal and secure worlds, which prevents normal world software from accessing or tampering with secure world memory.</p>
<p>The secure world memory, which includes the secure kernel, trusted applications, and their associated data, is protected from unauthorized access by the normal world. This ensures that sensitive data and operations within the secure world remain confidential and secure.</p>
<p>If a normal world application needs to exchange data with a trusted application in the secure world, it must use shared memory, which is explicitly allocated and managed by the GlobalPlatform TEE Client API. This provides a controlled mechanism for data exchange between the normal and secure worlds, maintaining security and isolation.</p>
<p>In summary, the normal world cannot directly access memory in the secure world, thanks to the hardware-based isolation provided by Arm TrustZone technology. Data exchange between the two worlds is facilitated through shared memory, which is managed by the GlobalPlatform TEE Client API.</p>
<hr>
<p><strong>Question:</strong> How does OP-TEE manage memory? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. Memory management in OP-TEE involves several aspects:</p>
<ol>
<li>
<p>Secure memory allocation: OP-TEE uses secure memory for storing sensitive data and code related to the secure kernel and trusted applications (TAs). It ensures that secure memory is not accessible by the normal world to maintain confidentiality and integrity. OP-TEE provides APIs for trusted applications to allocate and deallocate secure memory dynamically.</p>
</li>
<li>
<p>Trusted Application memory isolation: OP-TEE maintains memory isolation between different trusted applications, preventing them from accessing each other's memory regions. This ensures the confidentiality and integrity of data and code in each trusted application.</p>
</li>
<li>
<p>Shared memory management: OP-TEE manages shared memory to facilitate secure data exchange between the normal world and the secure world. The GlobalPlatform TEE Client API provides functions to allocate, register, and release shared memory. OP-TEE ensures proper access control and isolation for shared memory buffers.</p>
</li>
<li>
<p>Memory mapping: OP-TEE manages the memory mapping for the secure world, ensuring that the memory regions for the secure kernel, trusted applications, and shared memory are correctly mapped to physical memory addresses.</p>
</li>
<li>
<p>Memory protection: OP-TEE enforces memory protection policies for the secure world, including access controls, permissions, and execution restrictions. This helps prevent unauthorized access, tampering, or execution of secure memory regions.</p>
</li>
<li>
<p>Memory management for trusted applications: Trusted applications in OP-TEE can request memory from the TEE Core, which is the secure kernel, through TEE Internal API functions like TEE_Malloc, TEE_Realloc, and TEE_Free. These functions allow trusted applications to allocate and manage memory dynamically within their secure environment.</p>
</li>
</ol>
<p>In summary, OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. This includes secure memory allocation, isolation between trusted applications, shared memory management, memory mapping, memory protection, and dynamic memory management for trusted applications.</p>
<hr>
<p><strong>Question:</strong> Are data in memory in secure world encrypted? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Data stored in the memory of the secure world in OP-TEE is not encrypted by default. However, the secure world memory is protected by the hardware-based isolation provided by Arm TrustZone technology. TrustZone ensures that the normal world cannot directly access or tamper with the secure world's memory, which includes the secure kernel, trusted applications, and their associated data.</p>
<p>Although the data in the secure world memory is not encrypted, the isolation and access controls provided by TrustZone offer a strong level of protection. If an application or use case demands an even higher level of security, it is possible for trusted applications to implement additional encryption or other security measures for sensitive data stored in memory. This would depend on the specific requirements and threat model of the application or system.</p>
<p>In summary, data in the secure world memory is not encrypted by default in OP-TEE, but it is protected by the hardware-based isolation provided by Arm TrustZone technology. Additional encryption or security measures can be implemented by trusted applications if required.</p>
<hr>
<p><strong>Question:</strong> What is SMAF? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>SMAF stands for Secure Memory Allocation Framework, which is a part of the OP-TEE project. SMAF is designed to provide secure memory allocation and management in a Trusted Execution Environment (TEE). It allows OP-TEE to allocate, deallocate, and manage memory resources efficiently and securely within the secure world.</p>
<p>SMAF provides various features, including:</p>
<ol>
<li>
<p>Secure memory allocation: SMAF enables the allocation of secure memory for Trusted Applications (TAs) and the OP-TEE OS within the secure world.</p>
</li>
<li>
<p>Memory isolation: SMAF ensures that memory allocated to a TA is isolated from other TAs and the OP-TEE OS, protecting sensitive data from unauthorized access or tampering.</p>
</li>
<li>
<p>Fine-grained access control: SMAF provides fine-grained access control over memory regions, allowing TAs and the OP-TEE OS to specify access permissions for different memory areas.</p>
</li>
<li>
<p>Efficient memory management: SMAF includes mechanisms for efficient memory management, such as memory pooling and caching, to optimize resource utilization and reduce memory fragmentation.</p>
</li>
</ol>
<p>Overall, SMAF plays a critical role in maintaining the security and integrity of data within the OP-TEE environment. By providing secure memory allocation and management features, SMAF helps ensure that sensitive information remains protected from potential threats in the normal world and other trusted applications running in the secure world.</p>
<hr>
<p><strong>Question:</strong> Is SMAF of OP-TEE? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, SMAF is a part of the OP-TEE (Open Portable Trusted Execution Environment) framework. OP-TEE is an open-source implementation of the TEE (Trusted Execution Environment) for ARM processors, which provides a secure environment for running trusted applications.</p>
<p>SMAF, or Secure Memory Allocator Framework, is a component within the OP-TEE framework that enables the secure allocation and management of memory for trusted applications. It helps protect sensitive data, such as encryption keys and decrypted content, from unauthorized access in the normal world or by untrusted applications.</p>
<p>By integrating SMAF into OP-TEE, the framework can provide a higher level of security for applications, such as DRM systems, that require secure memory management for their sensitive data.</p>
<hr>
<p><strong>Question:</strong> Who can allocate SMAF memory? TA or CA <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the context of OP-TEE (Open Portable Trusted Execution Environment), the SMAF (Secure Memory Allocation Framework) is used to allocate memory for TAs (Trusted Applications).</p>
<p>Typically, the allocation of SMAF memory is managed by the OP-TEE OS (Trusted OS) and is not directly accessible by the CAs (Client Applications) running in the normal world. The reason for this is to maintain a strict separation between the secure and normal worlds, which is essential for the security and isolation of the trusted applications.</p>
<p>When a CA wants to communicate with a TA, it does so using the OP-TEE client API, which allows the CA to send messages and data to the TA. The OP-TEE OS then handles the secure allocation of memory for the TA, ensuring that the sensitive data and code execution remain protected within the secure environment.</p>
<p>In summary, the SMAF memory allocation is typically managed by the OP-TEE OS and is intended for use by TAs, while CAs interact with TAs through the OP-TEE client API.</p>
<hr>
<p><strong>Question:</strong> What is CMA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>CMA stands for Contiguous Memory Allocator, a feature in the Linux kernel that helps to allocate large contiguous blocks of memory. In systems where memory fragmentation is an issue, CMA can be particularly useful for devices and drivers that require large contiguous memory regions for their operation, such as multimedia hardware or devices using Direct Memory Access (DMA).</p>
<p>CMA works by reserving a portion of memory during the system boot process. This reserved memory region, known as the CMA pool, is kept separate from the general-purpose system memory. When a device or driver needs a large contiguous block of memory, it can request the allocation from the CMA pool. This approach reduces the likelihood of memory fragmentation and ensures that large contiguous memory regions are available when required.</p>
<p>CMA is not specific to OP-TEE but can be used in conjunction with OP-TEE in some cases. For example, OP-TEE may use CMA to allocate a large block of memory for a Trusted Application (TA) that requires a significant amount of contiguous memory. Additionally, CMA can be used to manage memory shared between the normal world and the secure world, ensuring that the shared memory regions are allocated contiguously and can be efficiently accessed by both worlds.</p>
<p>It is important to note that CMA should be used with caution, as reserving a large portion of memory for the CMA pool can impact overall system performance and memory utilization. Careful consideration of the trade-offs and system requirements is necessary when using CMA in a specific implementation.</p>
<hr>
<h2 id="user-content-network"><a class="heading-link" href="#network">Network<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Does OP-TEE support network communication in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE does not provide built-in support for direct network communication from within the secure world. The main reason for this is to maintain the security and isolation of the secure environment, as exposing networking capabilities directly to the secure world could introduce potential vulnerabilities or attack surfaces.</p>
<p>In most use cases, network communication is handled by normal world applications. If there is a need for secure communication involving trusted applications in the secure world, it is usually done indirectly:</p>
<ol>
<li>
<p>Normal world applications handle network communication and exchange data with trusted applications in the secure world using the GlobalPlatform TEE Client API and shared memory.</p>
</li>
<li>
<p>Secure operations, such as encryption, decryption, or authentication, can be performed by trusted applications in the secure world. The normal world application can then send or receive the processed data over the network.</p>
</li>
<li>
<p>If end-to-end security is required, the normal world application can use additional encryption or authentication protocols, in conjunction with secure operations performed by trusted applications.</p>
</li>
</ol>
<p>By handling network communication in the normal world and only exchanging data with the secure world as needed, OP-TEE maintains the isolation and security of the secure environment while still enabling secure network communication indirectly.</p>
<p>In summary, OP-TEE does not support direct network communication within the secure world. Instead, network communication is typically handled by normal world applications, which can securely exchange data with trusted applications in the secure world using the GlobalPlatform TEE Client API and shared memory.</p>
<hr>
<h2 id="user-content-signature"><a class="heading-link" href="#signature">Signature<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Is signature required when a normal world application request a service in secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. The communication between the normal world application and the trusted application is facilitated using the GlobalPlatform TEE Client API, which ensures proper access control and isolation for shared memory buffers used for data exchange.</p>
<p>However, a signature may be used in certain scenarios to enhance security. For example, if the normal world application sends sensitive data or a critical command to the trusted application, it might be useful to sign the data or command to ensure integrity and authenticity. This would help prevent tampering or replay attacks, especially in cases where the normal world might be compromised.</p>
<p>In such cases, the normal world application can sign the data or command using a private key, and the trusted application in the secure world can verify the signature using the corresponding public key. This ensures that the data or command has not been altered and that it originates from a trusted source.</p>
<p>In summary, a signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. However, signatures can be used in certain scenarios to enhance security by ensuring the integrity and authenticity of data or commands sent to the secure world.</p>
<hr>
<p><strong>Question:</strong> Does OP-TEE support to verify a signature of a TA in X.509 certificate? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE supports verifying the signature of a Trusted Application (TA) using X.509 certificates. This verification process is essential to ensure the authenticity and integrity of the TA before loading it into the secure world.</p>
<p>By default, OP-TEE uses a custom file format for TA binaries, which includes a signature generated with a private key. The signature is verified using the corresponding public key during the TA loading process. This public key is typically embedded into the OP-TEE core during the build process.</p>
<p>If you want to use X.509 certificates for verifying TA signatures, you can follow these steps:</p>
<ol>
<li>Build the OP-TEE project with the <code>CFG_TA_ASN1_DER_FORMAT</code> configuration option enabled. This option tells OP-TEE to expect TAs to be signed with X.509 certificates instead of the default custom format.</li>
</ol>
<pre><code>make CFG_TA_ASN1_DER_FORMAT=y
</code></pre>
<ol start="2">
<li>
<p>Sign your TA using an X.509 certificate. You can use tools like OpenSSL to create a certificate and sign the TA binary.</p>
</li>
<li>
<p>Embed the root certificate (or a certificate chain) used to sign the TA into the OP-TEE core during the build process. This certificate is used to verify the TA signature at runtime.</p>
</li>
<li>
<p>When loading a TA, OP-TEE will use the embedded certificate(s) to verify the TA's signature in the X.509 certificate format.</p>
</li>
</ol>
<p>Please note that you'll need to modify your build process and potentially some OP-TEE components to support this feature. Make sure to consult the OP-TEE documentation and source code for more information on how to enable and use X.509 certificates for TA signature verification.</p>
<hr>
<h2 id="user-content-development"><a class="heading-link" href="#development">Development<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Which languages do I use to develop apps in OP-TEE or to customize OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>To develop trusted applications for OP-TEE or to customize the OP-TEE framework, you primarily work with the C programming language. Both the OP-TEE OS (the secure kernel) and trusted applications are typically written in C to ensure low-level control, performance, and compatibility with the Arm TrustZone architecture.</p>
<ol>
<li>
<p>Trusted Applications: To develop a trusted application (TA) for OP-TEE, you write your application code in C, using the TEE Internal Core API as specified by GlobalPlatform. This API provides functions and types for managing memory, cryptography, secure storage, and other operations within the trusted application.</p>
</li>
<li>
<p>Customizing OP-TEE: If you want to modify or extend the OP-TEE OS itself, you will also work with C. The OP-TEE OS codebase is written in C and can be customized to meet specific requirements or to add new features. However, customizing the OP-TEE OS requires a deeper understanding of the secure kernel's internals and the Arm TrustZone technology.</p>
</li>
</ol>
<p>For normal world applications that communicate with the trusted applications, you can use various programming languages, as long as they can interface with the TEE Client API, which is usually provided as a C library. This means that you can use C, C++, or other languages that support C-compatible FFI (Foreign Function Interface) to interact with the secure world.</p>
<p>To summarize, you primarily use the C programming language to develop trusted applications and customize the OP-TEE framework, while normal world applications can be developed using various programming languages, as long as they can interface with the TEE Client API.</p>
<hr>
<p><strong>Question:</strong> Can I use other langauges? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>While the primary language for developing trusted applications (TAs) and customizing OP-TEE is C, it is possible to use other languages in some scenarios. However, this usually involves additional steps, and you may need to consider the limitations and compatibility of the chosen language with the TEE environment.</p>
<p>For normal world applications, you have more flexibility in choosing a programming language, as long as it can interface with the TEE Client API. Many popular programming languages have Foreign Function Interface (FFI) capabilities, which allow them to call C functions from native libraries. Some examples of such languages include:</p>
<ul>
<li>C++</li>
<li>Python (using <code>ctypes</code> or <code>cffi</code>)</li>
<li>Rust (using <code>bindgen</code> or <code>ctypes</code>)</li>
<li>Go (using <code>cgo</code>)</li>
<li>Node.js (using <code>ffi-napi</code> or <code>node-ffi</code>)</li>
</ul>
<p>For trusted applications, using a language other than C is more challenging, as it must meet certain requirements, such as being compatible with the TEE environment, the TEE Internal Core API, and the constraints of the secure world. Some potential options include:</p>
<ol>
<li>
<p>C++: You may be able to use a subset of C++ to develop trusted applications, as long as you handle low-level details and ensure compatibility with the TEE environment. However, you would need to be cautious about using certain C++ features, such as exceptions and the standard library, which may not be supported or might introduce security risks.</p>
</li>
<li>
<p>Rust: Rust is a systems programming language with strong safety guarantees, which could be suitable for developing trusted applications. There has been some work on using Rust for OP-TEE trusted applications, such as the <code>rust-optee-trustzone-sdk</code> project (<a href="https://github.com/apache/incubator-teaclave-trustzone-sdk">https://github.com/apache/incubator-teaclave-trustzone-sdk</a>). This project provides a Rust SDK for creating TAs and a set of bindings to the TEE Internal Core API.</p>
</li>
</ol>
<p>Using other high-level languages like Python, Java, or JavaScript for trusted applications is generally not feasible due to their runtime environments, memory management, and performance characteristics, which may not be compatible with the constraints of the secure world.</p>
<p>In summary, while it is possible to use other languages for normal world applications and, to some extent, for trusted applications, the primary language for OP-TEE development remains C. When considering an alternative language, be sure to evaluate its compatibility with the TEE environment, the API, and the specific requirements of your application.</p>
<hr>
<p><strong>Question:</strong> Does OP-TEE have a shell? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE does not have a traditional shell like those found in Unix-like operating systems. However, OP-TEE provides a feature called the "Secure Shell" (S-Shell), which allows developers and users to interact with the secure world using a command-line interface. The S-Shell is primarily used for debugging purposes and is not intended for production use.</p>
<p>The S-Shell can be accessed using a UART (Universal Asynchronous Receiver/Transmitter) connection to the device running OP-TEE. This connection allows you to view log messages, interact with the secure world, and execute basic commands to manage trusted applications, memory, and other secure resources.</p>
<p>It is important to note that the S-Shell feature should be used carefully and only in controlled environments, as it could potentially expose sensitive information or allow unauthorized access to secure resources if misused.</p>
<p>In summary, while OP-TEE does not have a traditional shell, it does provide an S-Shell feature for debugging purposes. This feature should be used with caution, as it can potentially expose sensitive information or allow unauthorized access to secure resources if not properly managed.</p>
<hr>
<p><strong>Question:</strong> What is about size of tee.bin? <code>(2023-04-12)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The size of the <code>tee.bin</code> file, which is the OP-TEE OS binary, can vary depending on various factors such as the target platform, configuration options, and enabled features. It's difficult to give an exact size for a specific <code>tee.bin</code> file without knowing the specific build configuration.</p>
<p>However, generally speaking, the size of the <code>tee.bin</code> file is relatively small, usually ranging from a few hundred kilobytes to a couple of megabytes. This small footprint is one of the reasons why OP-TEE is suitable for use in constrained environments, such as embedded systems and IoT devices.</p>
<p>Keep in mind that the actual size of the <code>tee.bin</code> file in your specific case can be different depending on the factors mentioned earlier.</p>
<hr>
<p><strong>Question:</strong> What is libteec.so? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>libteec.so</code> is a shared library in the OP-TEE (Open Portable Trusted Execution Environment) system, which is part of the client-side implementation of the GlobalPlatform TEE Client API. This library allows client applications (CAs) in the normal world to communicate with trusted applications (TAs) running in the secure world, i.e., inside the TEE.</p>
<p>The TEE Client API specifies a set of functions that client applications can use to open and close sessions with trusted applications, to send commands and data to the TAs, and to manage shared memory between the normal world and the secure world. <code>libteec.so</code> provides the implementation of these functions, handling the low-level communication with the OP-TEE OS, usually through a dedicated driver.</p>
<p>In summary, <code>libteec.so</code> is a crucial component that enables applications running in the normal world to utilize the secure services provided by trusted applications within the OP-TEE environment.</p>
<hr>
<p><strong>Question:</strong> Does libteec.so run in EL0 or EL1? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>libteec.so</code> runs in EL0 (Exception Level 0) since it is a user-space library that is part of client applications (CAs) in the normal world. EL0 is the lowest privilege level and is where applications run on ARM-based systems.</p>
<p>EL1 (Exception Level 1) is the level at which operating system kernel code runs, and it has a higher privilege level than EL0. The OP-TEE OS, which manages trusted applications (TAs) in the secure world, runs at a higher exception level (EL1 in AArch64 or S-EL1 in AArch32) to ensure isolation between the normal and secure worlds. However, <code>libteec.so</code> is not part of the OP-TEE OS; it is a user-space library for communicating with the TEE from the normal world.</p>
<hr>
<p><strong>Question:</strong> Does optee.ko run in EL1? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p><code>optee.ko</code> is a Linux kernel module that runs in the normal world. Since it is part of the kernel, it runs at EL1 (Exception Level 1) on AArch64 systems. EL1 is the level at which operating system kernel code runs, and it has a higher privilege level than EL0, where user-space applications run.</p>
<p>However, it is important to note that <code>optee.ko</code> runs in the normal world, not in the secure world. It serves as a driver to facilitate communication between client applications (CAs) in the normal world and the OP-TEE OS in the secure world. The actual OP-TEE OS runs at a higher exception level (EL1 in AArch64 or S-EL1 in AArch32) in the secure world to ensure isolation between the normal and secure worlds.</p>
<hr>
<p><strong>Question:</strong> What is TEE supplicant? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The TEE (Trusted Execution Environment) supplicant is a user-space daemon in the normal world that works alongside the OP-TEE environment. It serves as an intermediary between the TEE OS and the normal world's user-space applications, facilitating communication and providing additional services for TEE operations.</p>
<p>Some of the primary responsibilities of the TEE supplicant include:</p>
<ol>
<li>Loading and managing shared libraries for Trusted Applications (TAs).</li>
<li>Handling communication with storage services, such as file access and data persistence, for TAs.</li>
<li>Assisting with inter-process communication (IPC) between client applications (CAs) and TAs.</li>
<li>Managing cryptographic operations that require access to the normal world.</li>
</ol>
<p>The TEE supplicant is an essential component of the OP-TEE ecosystem, working in tandem with the kernel-side driver (e.g., optee.ko) and user-space TEE client libraries (e.g., libteec.so) to enable a seamless, secure execution environment for sensitive applications.</p>
<hr>
<h2 id="user-content-static-ta-and-dynamic-ta"><a class="heading-link" href="#static-ta-and-dynamic-ta">Static TA and Dynamic TA<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> What are Static TA and Dynamic TA? Please also summarize them in a table. <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Static TA (Trusted Application) and Dynamic TA are two types of Trusted Applications used within the OP-TEE framework. Here's a summary of their differences in a table:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Static TA</th>
<th>Dynamic TA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loading mechanism</td>
<td>Built into the OP-TEE core</td>
<td>Loaded at runtime as separate binaries</td>
</tr>
<tr>
<td>Memory management</td>
<td>Pre-allocated memory within the TEE core</td>
<td>Allocated dynamically when the TA is loaded</td>
</tr>
<tr>
<td>Lifespan</td>
<td>Lives for the entire duration of the TEE core</td>
<td>Loaded and unloaded on-demand, based on the client's request</td>
</tr>
<tr>
<td>Flexibility</td>
<td>Limited, as changes require recompiling the TEE core</td>
<td>Highly flexible, can be updated or replaced independently of the TEE core</td>
</tr>
<tr>
<td>Initialization process</td>
<td>Initializes during TEE core startup</td>
<td>Initializes when first invoked by a client</td>
</tr>
<tr>
<td>Performance</td>
<td>Faster, as no additional loading is needed</td>
<td>Slower, due to the need to load and initialize the TA at runtime</td>
</tr>
<tr>
<td>Storage</td>
<td>No separate storage required, as it's part of the TEE core</td>
<td>Requires storage for the separate TA binary</td>
</tr>
</tbody>
</table>
<p>Static TAs are built directly into the OP-TEE core binary, which means they are always available when the TEE is running. They have pre-allocated memory within the TEE core and are initialized during the TEE core startup. This makes them faster in terms of performance but less flexible since any changes to a Static TA require recompiling the entire OP-TEE core.</p>
<p>Dynamic TAs, on the other hand, are loaded at runtime as separate binaries. They are more flexible and can be updated or replaced independently of the OP-TEE core. However, they may have a slightly slower performance due to the need to load and initialize the TA at runtime. Dynamic TAs are loaded and unloaded on-demand based on the client's request and have memory allocated dynamically when the TA is loaded.</p>
<hr>
<p><strong>Question:</strong> Does TEE define Static TA and Dynamic TA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The terms "Static TA" and "Dynamic TA" are specific to the OP-TEE implementation and are not part of the GlobalPlatform TEE (Trusted Execution Environment) specifications. The GlobalPlatform TEE specifications define the APIs and security requirements for trusted applications, but they do not dictate how TAs should be loaded, stored, or managed within a TEE implementation.</p>
<p>The concepts of static and dynamic TAs are unique to the OP-TEE project and serve as a way to distinguish between different loading and linking mechanisms for trusted applications within the OP-TEE framework. Other TEE implementations might use different terminology or approaches to manage trusted applications.</p>
<p>In summary, the terms "Static TA" and "Dynamic TA" are specific to OP-TEE and are not part of the GlobalPlatform TEE specifications.</p>
<hr>
<p><strong>Question:</strong> Can I create a TA at run-time? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Creating a Trusted Application (TA) at runtime is not a typical use case for OP-TEE. TAs are usually developed, compiled, and signed offline before being deployed to the target device. In the normal process, TAs are loaded by the secure kernel (in the secure world) when requested by a client application (in the normal world).</p>
<p>However, if you have a specific use case that requires creating a TA at runtime, you could theoretically implement a custom mechanism for loading and running code in the secure world dynamically. This would involve significant modifications to the OP-TEE framework and would need to be done with extreme caution to ensure security is maintained.</p>
<p>Such a dynamic TA loading mechanism would likely require the following steps:</p>
<ol>
<li>Develop and compile the TA code in a suitable format that can be loaded into the secure world at runtime.</li>
<li>Transfer the compiled TA code to the target device securely.</li>
<li>Modify the secure kernel to support loading and executing the TA code dynamically, including verifying its authenticity and integrity.</li>
<li>Implement proper access control and isolation mechanisms to ensure the newly loaded TA does not compromise the security of the existing TAs and the secure world.</li>
</ol>
<p>It is crucial to emphasize that implementing a runtime TA creation mechanism is a complex and potentially risky endeavor, and it may introduce security vulnerabilities if not done correctly. You should carefully consider the security implications and whether the benefits of such a feature outweigh the risks before attempting to implement it.</p>
<hr>
<p><strong>Question:</strong> But what is TEECI_LoadSecureModule() <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>My apologies for any confusion earlier. <code>TEECI_LoadSecureModule()</code> is not a part of the standard OP-TEE or GlobalPlatform TEE APIs. It seems to be a custom function name that might have been used in a specific implementation or context.</p>
<p>It's important to reiterate that the standard OP-TEE and GlobalPlatform TEE APIs do not provide a built-in function for loading or creating Trusted Applications (TAs) at runtime. TAs are generally pre-built, signed, and deployed to the device as binaries. The secure kernel then loads the TA when requested by a client application.</p>
<p>If you have encountered <code>TEECI_LoadSecureModule()</code> in some source code or documentation, it might be a custom function that has been implemented for a specific use case or project. To understand its purpose and how it works, you would need to refer to the documentation or source code of that particular implementation.</p>
<hr>
<p><strong>Question:</strong> How to recover a crashed static TA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Recovering a crashed static TA in OP-TEE may not be a straightforward process, as static TAs are linked with the OP-TEE OS binary and run in the same context as the OS. However, you can try the following steps to recover from a crashed static TA:</p>
<ol>
<li>
<p>Detect the crash: Set up a monitoring mechanism to detect when a static TA crashes or becomes unresponsive. This can be done by monitoring the return values of the TA's entry points, observing timeouts or abnormal behavior, and checking for signs of memory corruption.</p>
</li>
<li>
<p>Terminate the TA session: In case of a detected crash, terminate the session with the affected static TA. Inform the client application (CA) in the normal world about the issue, and potentially return an error code to signify the crash.</p>
</li>
<li>
<p>Clean up resources: Release any resources held by the crashed static TA, such as memory allocations, file handles, or cryptographic keys.</p>
</li>
<li>
<p>Reinitialize the TA: As static TAs are linked with the OP-TEE OS binary, the only way to reinitialize the TA is by resetting the entire secure world. This can be done by rebooting the system or triggering a system reset. Note that this approach may also affect other TAs and the OP-TEE OS itself, so it should be used with caution.</p>
</li>
<li>
<p>Restore the state (optional): If the static TA maintains a persistent state in secure storage, you might need to restore the state after reinitialization. This can be done by reading the state from secure storage and passing it back to the TA when it starts.</p>
</li>
<li>
<p>Resume operation: Once the static TA is reinitialized and its state is restored (if applicable), you can resume the normal operation by relaunching the client application and re-establishing the session with the TA.</p>
</li>
</ol>
<p>Please note that the recovery process for a crashed static TA is not ideal, as it may involve resetting the entire secure world. It is essential to design and implement the static TA with robust error handling and recovery mechanisms to minimize the risk of crashes. Additionally, you might consider using dynamic TAs instead of static TAs, as dynamic TAs offer better isolation and can be loaded and unloaded independently, making recovery easier in case of crashes.</p>
<hr>
<p><strong>Question:</strong> How to recover a crashed dynamic TA? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Recovering a crashed dynamic TA in OP-TEE is generally more manageable than recovering a static TA since dynamic TAs run in separate contexts and can be loaded and unloaded independently. Here's a suggested process to recover a crashed dynamic TA:</p>
<ol>
<li>
<p>Detect the crash: Set up a monitoring mechanism to detect when a dynamic TA crashes or becomes unresponsive. This can be done by monitoring the return values of the TA's entry points, observing timeouts, or abnormal behavior.</p>
</li>
<li>
<p>Terminate the TA session: In case of a detected crash, terminate the session with the affected dynamic TA. Inform the client application (CA) in the normal world about the issue, and potentially return an error code to signify the crash.</p>
</li>
<li>
<p>Clean up resources: Release any resources held by the crashed dynamic TA, such as memory allocations, file handles, or cryptographic keys.</p>
</li>
<li>
<p>Unload the TA: Unload the crashed dynamic TA from the OP-TEE OS by closing the session associated with the TA. This should release the resources held by the TA and remove it from memory.</p>
</li>
<li>
<p>Reload the TA: Load a new instance of the dynamic TA using the same TA UUID. This can be done by requesting a new session with the TA from the client application.</p>
</li>
<li>
<p>Restore the state (optional): If the dynamic TA maintains a persistent state in secure storage, you might need to restore the state after reloading the TA. This can be done by reading the state from secure storage and passing it back to the TA when it starts.</p>
</li>
<li>
<p>Resume operation: Once the dynamic TA is reloaded and its state is restored (if applicable), you can resume normal operation by relaunching the client application and re-establishing the session with the TA.</p>
</li>
</ol>
<p>Please note that it's essential to design and implement the dynamic TA with robust error handling and recovery mechanisms to minimize the risk of crashes. Be sure to thoroughly test and validate the TA to ensure its stability and reliability.</p>
<hr>
<p><strong>Question:</strong> Which privilege levels do static TA and dynamic TA run in? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In the context of ARM TrustZone and OP-TEE, there are two types of Trusted Applications (TAs): static and dynamic.</p>
<p>Static TAs are part of the OP-TEE OS itself, meaning they are compiled and linked together with the OP-TEE OS, and run at the same privilege level as the OP-TEE OS, which is Secure EL1 (Secure Exception Level 1) in the ARMv8 architecture.</p>
<p>Dynamic TAs, on the other hand, are standalone binaries that are loaded and executed by the OP-TEE OS on-demand. They run at a lower privilege level compared to the OP-TEE OS. In the ARMv8 architecture, dynamic TAs run at Secure EL0 (Secure Exception Level 0).</p>
<p>By running dynamic TAs at a lower privilege level, the system can provide better isolation between the TAs themselves and the OP-TEE OS, thereby improving security.</p>
<hr>
<h2 id="user-content-qualcomm"><a class="heading-link" href="#qualcomm">Qualcomm<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Does Qualcomm support OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>As of my knowledge cutoff in September 2021, Qualcomm does not officially support OP-TEE for their platforms. Instead, they provide their own Trusted Execution Environment (TEE) solution, known as Qualcomm Trusted Execution Environment (QTEE). QTEE is based on ARM TrustZone technology and is designed to provide a secure environment for running trusted applications on Qualcomm Snapdragon processors.</p>
<p>QTEE offers similar functionality to OP-TEE, providing a secure environment for running sensitive code and protecting sensitive data from unauthorized access or tampering. It includes features such as secure boot, secure storage, cryptographic services, and key management.</p>
<p>While Qualcomm officially supports QTEE on their platforms, it is possible that some developers or third-party companies have attempted to port OP-TEE to Qualcomm devices. However, such ports may not be officially supported by Qualcomm and may not offer the same level of integration, performance, or security as the QTEE solution.</p>
<hr>
<p><strong>Question:</strong> Is QTEE open source? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Qualcomm Trusted Execution Environment (QTEE) is not fully open-source. While some components and tools related to QTEE are available as open-source projects, the core implementation of QTEE is proprietary and closed-source.</p>
<p>Qualcomm provides certain tools, libraries, and APIs to facilitate the development of trusted applications (TAs) for QTEE, and some of these resources may be available as open-source projects. However, the QTEE OS and other critical components are closed-source and maintained by Qualcomm.</p>
<p>This is in contrast to OP-TEE, which is an open-source TEE solution maintained by Linaro and supported by various industry partners. With OP-TEE, developers have access to the full source code, enabling them to examine, modify, and contribute to the project as needed.</p>
<hr>
<h2 id="user-content-drm"><a class="heading-link" href="#drm">DRM<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> How do I implement DRM of content decryption with OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Implementing DRM content decryption with OP-TEE requires the development of a Trusted Application (TA) that handles the decryption process securely within the TEE environment. Here is a step-by-step guide to help you implement DRM content decryption using OP-TEE:</p>
<ol>
<li>
<p>Define decryption requirements: Identify the specific encryption schemes and formats used for the protected content, such as AES-CTR, AES-CBC, or others.</p>
</li>
<li>
<p>Develop a Trusted Application: Create a TA that handles the decryption process. The TA should receive encrypted content and any necessary decryption keys or metadata from the normal world and perform the decryption securely within the TEE environment. It should also return the decrypted content to the normal world application for playback.</p>
</li>
</ol>
<div class="highlight highlight-source-c"><pre><span class="pl-smi">TEE_Result</span> <span class="pl-en">TA_InvokeCommandEntryPoint</span>(<span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-s1">session_context</span>, <span class="pl-smi">uint32_t</span> <span class="pl-s1">command_id</span>,
                                      <span class="pl-smi">uint32_t</span> <span class="pl-s1">param_types</span>, <span class="pl-smi">TEE_Param</span> <span class="pl-s1">params</span>[<span class="pl-c1">TEE_NUM_PARAMS</span>]) {
    <span class="pl-k">switch</span> (<span class="pl-s1">command_id</span>) {
        <span class="pl-k">case</span> <span class="pl-c1">TA_DRM_DECRYPT_CMD</span>:
            <span class="pl-k">return</span> <span class="pl-en">ta_drm_decrypt</span>(<span class="pl-s1">param_types</span>, <span class="pl-s1">params</span>);
        ...
    }
}</pre></div>
<ol start="3">
<li>Implement decryption functionality: Within the TA, implement the necessary decryption algorithms and functionality. You can use the cryptographic operations provided by the TEE Internal API to perform the decryption.</li>
</ol>
<div class="highlight highlight-source-c"><pre><span class="pl-k">static</span> <span class="pl-smi">TEE_Result</span> <span class="pl-en">ta_drm_decrypt</span>(<span class="pl-smi">uint32_t</span> <span class="pl-s1">param_types</span>, <span class="pl-smi">TEE_Param</span> <span class="pl-s1">params</span>[<span class="pl-c1">TEE_NUM_PARAMS</span>]) {
    <span class="pl-smi">TEE_Result</span> <span class="pl-s1">res</span>;
    <span class="pl-smi">TEE_OperationHandle</span> <span class="pl-s1">op</span> <span class="pl-c1">=</span> <span class="pl-c1">TEE_HANDLE_NULL</span>;
    <span class="pl-smi">TEE_ObjectHandle</span> <span class="pl-s1">key_handle</span> <span class="pl-c1">=</span> <span class="pl-c1">TEE_HANDLE_NULL</span>;
    ...
    <span class="pl-c">// Create a transient key object and set the decryption key</span>
    <span class="pl-s1">res</span> <span class="pl-c1">=</span> <span class="pl-en">TEE_AllocateTransientObject</span>(<span class="pl-c1">TEE_TYPE_AES</span>, <span class="pl-s1">key_size</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">key_handle</span>);
    <span class="pl-s1">res</span> <span class="pl-c1">=</span> <span class="pl-en">TEE_PopulateTransientObject</span>(<span class="pl-s1">key_handle</span>, <span class="pl-s1">key_attr</span>, <span class="pl-c1">1</span>);

    <span class="pl-c">// Allocate a new operation and set the key for decryption</span>
    <span class="pl-s1">res</span> <span class="pl-c1">=</span> <span class="pl-en">TEE_AllocateOperation</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">op</span>, <span class="pl-c1">TEE_ALG_AES_CBC_NOPAD</span>, <span class="pl-c1">TEE_MODE_DECRYPT</span>, <span class="pl-s1">key_size</span>);
    <span class="pl-s1">res</span> <span class="pl-c1">=</span> <span class="pl-en">TEE_SetOperationKey</span>(<span class="pl-s1">op</span>, <span class="pl-s1">key_handle</span>);

    <span class="pl-c">// Perform the decryption</span>
    <span class="pl-s1">res</span> <span class="pl-c1">=</span> <span class="pl-en">TEE_CipherDoFinal</span>(<span class="pl-s1">op</span>, <span class="pl-s1">encrypted_data</span>, <span class="pl-s1">encrypted_data_size</span>, <span class="pl-s1">decrypted_data</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">decrypted_data_size</span>);
    ...
}</pre></div>
<ol start="4">
<li>Integrate with the normal world application: Develop a normal world application that communicates with the TA using OP-TEE's GlobalPlatform TEE Client API. The normal world application should be responsible for obtaining encrypted content, the decryption key, and any necessary metadata from the DRM system, and then passing this information to the TA for decryption.</li>
</ol>
<div class="highlight highlight-source-c"><pre><span class="pl-smi">TEEC_Result</span> <span class="pl-s1">res</span>;
<span class="pl-smi">TEEC_Session</span> <span class="pl-s1">session</span>;
<span class="pl-smi">TEEC_Operation</span> <span class="pl-s1">op</span>;
...
<span class="pl-c">// Prepare the operation parameters</span>
<span class="pl-s1">op</span>.<span class="pl-c1">paramTypes</span> <span class="pl-c1">=</span> <span class="pl-en">TEEC_PARAM_TYPES</span>(<span class="pl-c1">TEEC_MEMREF_TEMP_INPUT</span>, <span class="pl-c1">TEEC_MEMREF_TEMP_INPUT</span>, <span class="pl-c1">TEEC_MEMREF_TEMP_OUTPUT</span>, <span class="pl-c1">TEEC_NONE</span>);
<span class="pl-s1">op</span>.<span class="pl-c1">params</span>[<span class="pl-c1">0</span>].<span class="pl-c1">tmpref</span>.<span class="pl-c1">buffer</span> <span class="pl-c1">=</span> <span class="pl-s1">encrypted_data</span>;
<span class="pl-s1">op</span>.<span class="pl-c1">params</span>[<span class="pl-c1">0</span>].<span class="pl-c1">tmpref</span>.<span class="pl-c1">size</span> <span class="pl-c1">=</span> <span class="pl-s1">encrypted_data_size</span>;
<span class="pl-s1">op</span>.<span class="pl-c1">params</span>[<span class="pl-c1">1</span>].<span class="pl-c1">tmpref</span>.<span class="pl-c1">buffer</span> <span class="pl-c1">=</span> <span class="pl-s1">decryption_key</span>;
<span class="pl-s1">op</span>.<span class="pl-c1">params</span>[<span class="pl-c1">1</span>].<span class="pl-c1">tmpref</span>.<span class="pl-c1">size</span> <span class="pl-c1">=</span> <span class="pl-s1">decryption_key_size</span>;
<span class="pl-s1">op</span>.<span class="pl-c1">params</span>[<span class="pl-c1">2</span>].<span class="pl-c1">tmpref</span>.<span class="pl-c1">buffer</span> <span class="pl-c1">=</span> <span class="pl-s1">decrypted_data</span>;
<span class="pl-s1">op</span>.<span class="pl-c1">params</span>[<span class="pl-c1">2</span>].<span class="pl-c1">tmpref</span>.<span class="pl-c1">size</span> <span class="pl-c1">=</span> <span class="pl-s1">decrypted_data_size</span>;

<span class="pl-c">// Invoke the TA command for decryption</span>
<span class="pl-s1">res</span> <span class="pl-c1">=</span> <span class="pl-en">TEEC_InvokeCommand</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">session</span>, <span class="pl-c1">TA_DRM_DECRYPT_CMD</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">op</span>, <span class="pl-c1">NULL</span>);</pre></div>
<ol start="5">
<li>Test and validate: Test your TA and normal world application to ensure proper decryption and playback of the protected content. Verify that the content is decrypted securely within the TEE environment and is protected from unauthorized access or tampering.</li>
</ol>
<p>By following these steps, you can implement DRM content decryption with OP-TEE, ensuring that the decryption process is secure and protected within</p>
<hr>
<p><strong>Question:</strong> So the content is decrypted in TA in secure world. Right? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, that's correct. In the described DRM implementation, the content is decrypted within the Trusted Application (TA) running in the secure world of OP-TEE. The TA receives encrypted content and decryption keys from the normal world application and performs the decryption securely within the TEE environment. The decrypted content is then returned to the normal world application for playback. This approach ensures that sensitive information, such as decryption keys and decrypted content, is protected within the secure world, preventing unauthorized access or tampering.</p>
<hr>
<p><strong>Question:</strong> But does it slow down the playback speed because of switching between normal world and secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Switching between the normal world and the secure world does introduce some overhead, as the system needs to perform context switching and maintain the isolation between the two environments. However, this overhead is generally small compared to the overall processing time required for content decryption and playback.</p>
<p>The exact performance impact will depend on various factors, such as the hardware platform, the complexity of the decryption algorithm, and the size of the content being processed. In most cases, the benefits of secure content decryption within the TEE outweigh the slight performance overhead introduced by the world-switching.</p>
<p>To minimize the performance impact, you can optimize the design of your Trusted Application and normal world application. For example, you can:</p>
<ol>
<li>Minimize the number of world switches by processing larger chunks of encrypted content in a single invocation of the Trusted Application.</li>
<li>Optimize the cryptographic operations within the Trusted Application by leveraging hardware-accelerated cryptographic functions, if available on your platform.</li>
<li>Optimize data handling and buffering between the normal world application and the Trusted Application to reduce data copying and memory allocation overhead.</li>
</ol>
<p>By carefully designing and optimizing your implementation, you can ensure that the performance impact of secure content decryption in the TEE is minimized while still providing robust security for your DRM system.</p>
<hr>
<p><strong>Question:</strong> Can I use multi cores to solve the problem? For example, one core decrypts content and another core play content at the same time. <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, using multi-core processing can help improve the performance of your DRM implementation by parallelizing the decryption and playback processes. If your platform supports multiple cores, you can assign different tasks to different cores to minimize the overhead introduced by secure world and normal world switching. Here's a general approach to achieve this:</p>
<ol>
<li>
<p>Assign content decryption to one core: Designate one core to handle the decryption process within the Trusted Application in the secure world. This core will be responsible for processing encrypted content and performing the decryption using the provided keys.</p>
</li>
<li>
<p>Assign content playback to another core: Designate a different core to handle the playback process in the normal world. This core will be responsible for receiving the decrypted content from the Trusted Application and managing the playback process, including rendering, audio synchronization, and user interaction.</p>
</li>
<li>
<p>Implement inter-core communication: Develop a mechanism for inter-core communication to allow the decryption core and the playback core to exchange data efficiently. This can be achieved using shared memory buffers, message queues, or other communication techniques suitable for your platform.</p>
</li>
<li>
<p>Manage synchronization and buffering: Implement synchronization and buffering mechanisms to ensure smooth playback while maintaining the parallelism between decryption and playback processes. This may involve using semaphores, mutexes, or other synchronization primitives to coordinate data exchange between the cores and prevent buffer overflows or underflows.</p>
</li>
</ol>
<p>By using multi-core processing, you can offload the decryption process to a separate core, reducing the impact of secure world and normal world switching on playback performance. However, keep in mind that implementing a multi-core DRM solution can be more complex, as it requires careful design and synchronization to ensure smooth operation and proper security. Be sure to thoroughly test and validate your implementation to ensure it meets the performance and security requirements of your DRM system.</p>
<hr>
<p><strong>Question:</strong> How do I implement a DRM solution using ClearKey in OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>To implement a DRM solution using ClearKey in OP-TEE, you'll need to develop a Trusted Application (TA) that handles the decryption process within the secure world of OP-TEE, and a normal world application (e.g., a browser or media player) that communicates with the TA for decrypting media content. Here are the general steps:</p>
<ol>
<li>
<p><strong>Develop a Trusted Application (TA):</strong> Create a TA that securely handles decryption keys and content decryption within the TEE environment. The TA will receive encrypted content and decryption keys from the normal world application and perform the decryption securely within the TEE.</p>
</li>
<li>
<p><strong>Implement the ClearKey decryption algorithm:</strong> Since ClearKey is a simple and open-source key system, you can readily find implementations or libraries that can be integrated into your TA. You will need to implement the decryption algorithm (usually AES-128-CBC or AES-128-CTR) within the TA to decrypt the content.</p>
</li>
<li>
<p><strong>Develop a normal world application:</strong> Create a browser or media player application that uses the Encrypted Media Extensions (EME) API with the ClearKey key system. This application will be responsible for handling media playback, parsing the encrypted content, and extracting the necessary metadata (e.g., content encryption keys, initialization vectors) to pass to the TA for decryption.</p>
</li>
<li>
<p><strong>Communication between normal world application and TA:</strong> Establish a secure communication channel between your normal world application and the TA. Your normal world application will send encrypted media content, keys, and other required metadata to the TA, which will then decrypt the content and return it to the normal world application for playback.</p>
</li>
<li>
<p><strong>Test and validate your implementation:</strong> Ensure that your DRM solution works correctly by testing it with various encrypted media content and key configurations. Make sure the implementation provides the necessary security features to protect the content and keys from unauthorized access or tampering.</p>
</li>
</ol>
<p>Keep in mind that ClearKey is a basic key system primarily intended for testing and development purposes. In a production environment, you may want to use a more robust and secure DRM system, such as Widevine or PlayReady, depending on your requirements and platform support. Additionally, be aware that implementing a DRM solution in OP-TEE can be complex, and you'll need to consider the hardware and platform limitations, performance, and security requirements for your specific use case.</p>
<hr>
<p><strong>Question:</strong> Below text comes from "BKK16-201 - PlayReady OPTEE Integration with Secure Video Path" <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>This text appears to be an excerpt from a presentation, "BKK16-201 - PlayReady OPTEE Integration with Secure Video Path." The presenter is Zoltan Kuscsik, PhD, and the presentation took place on March 8, 2016, during the Linaro Connect BKK16 event. The presentation deals with the integration of key components such as the W3C EME Working Draft, Microsoft PlayReady DRM Porting Kit v3.0, OP-TEE OS, OpenCDM/OpenCDMI, and Chromium v45.</p>
<p>The talk provides updates since SFO15, such as the progress on the proof of concept for Secure Data Path with OP-TEE/Playready on STM B2120, the integration of the Secure Memory Allocator Framework (SMAF), and the implementation of Playready TA with support for the Playready Interface For TEE (PRiTEE).</p>
<p>Supported boards mentioned in the presentation include STM B2120 and 96boards - HiKey. The presentation also discusses various aspects related to EME, secure memory allocation, Playready integration, Open CDM, and the implementation overview for Chromium.</p>
<p>There are several links provided at the end of the presentation for further information on Playready, OP-TEE, and Linaro OpenCDM.</p>
<hr>
<p><strong>Question:</strong> What is secure data path? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>A Secure Data Path (SDP) is a mechanism that ensures the confidentiality, integrity, and protection of sensitive data while it is being processed, transmitted, or stored. In the context of multimedia applications and Digital Rights Management (DRM) systems, a secure data path ensures that the content is protected from unauthorized access or tampering at all stages of its life cycle, from decoding to rendering on the display.</p>
<p>The SDP is designed to prevent unauthorized access and data leaks by isolating the sensitive data and processing it within a secure environment, such as a Trusted Execution Environment (TEE) or hardware-protected memory regions. This isolation ensures that even if the rest of the system is compromised, the sensitive data remains protected.</p>
<p>In the case of multimedia applications, the secure data path provides end-to-end protection for encrypted content. It ensures that decrypted data (e.g., video or audio frames) is not exposed to the untrusted parts of the system, such as the general-purpose operating system, applications, or untrusted hardware components. This protection is critical for DRM systems to prevent content piracy and maintain the trust of content providers.</p>
<hr>
<p><strong>Question:</strong> So the video is played in secure world. Right? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Not exactly. The video is not played entirely within the secure world. Instead, the sensitive parts of the video processing, such as decryption and decoding, are performed within the secure world, using technologies like Trusted Execution Environment (TEE) or hardware-protected memory regions. Once the video data is processed securely, it is then passed to the normal world for rendering and display.</p>
<p>The purpose of this approach is to protect sensitive data and operations from unauthorized access or tampering while minimizing the performance overhead of the secure world. By only processing the critical parts of the video pipeline securely, the system can maintain a balance between security and performance.</p>
<hr>
<p><strong>Question:</strong> How do we protect the video that displays in normal world? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Protecting the video data when it is displayed in the normal world is a crucial aspect of maintaining the security of the content. Here are some techniques and technologies used to achieve this protection:</p>
<ol>
<li>
<p>Secure Data Path (SDP): SDP is a technique that ensures the secure handling of sensitive data throughout the entire video pipeline. In SDP, the decrypted and decoded video data is transferred from the secure world to the normal world through a protected memory path. This prevents unauthorized access or tampering during the data transfer.</p>
</li>
<li>
<p>Hardware-based content protection: Certain hardware components, such as display controllers and graphics processors, can offer built-in content protection features. These features ensure that the video data remains secure when it is passed to the display device.</p>
</li>
<li>
<p>High-bandwidth Digital Content Protection (HDCP): HDCP is a widely used technology for protecting video content transmitted over digital interfaces like HDMI, DisplayPort, or DVI. HDCP encrypts the video data during transmission, preventing unauthorized access or copying.</p>
</li>
<li>
<p>Output Protection Management (OPM): OPM is a system that enforces the use of HDCP or other content protection mechanisms when video data is transmitted from a source device to a display device. OPM ensures that the video data is protected throughout the entire transmission process.</p>
</li>
<li>
<p>Frame buffer encryption: Some systems support the encryption of frame buffers, which store the video data before it is rendered on the display. This feature provides an additional layer of protection for the video data as it is stored in the memory.</p>
</li>
</ol>
<p>By employing a combination of these techniques and technologies, the video data can be adequately protected even when it is displayed in the normal world.</p>
<hr>
<p><strong>Question:</strong> What is "EME with OP-TEE on Hikey"? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>"EME with OP-TEE on Hikey" refers to the implementation of the Encrypted Media Extensions (EME) using the OP-TEE (Open Portable Trusted Execution Environment) on the HiKey development board.</p>
<p>EME is a W3C (World Wide Web Consortium) specification that provides a standard interface for content protection in web browsers. It allows web applications to communicate with Content Decryption Modules (CDMs) to enable the playback of encrypted multimedia content.</p>
<p>OP-TEE is an open-source Trusted Execution Environment (TEE) that provides a secure environment for the execution of sensitive code and data protection. OP-TEE leverages ARM TrustZone technology to isolate the secure world from the normal world.</p>
<p>HiKey is a development board built around a 64-bit ARM-based SoC (System on Chip) and is part of the 96Boards family of development platforms. It is widely used for prototyping and development purposes, including the implementation of secure solutions.</p>
<p>In summary, "EME with OP-TEE on Hikey" refers to a solution that integrates EME and OP-TEE on the HiKey development board to provide secure playback of encrypted multimedia content within web applications. This implementation ensures the protection of sensitive data and operations related to content decryption and key management within the secure world of the TEE.</p>
<hr>
<p><strong>Question:</strong> What is AES OCDMI? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>AES OCDMI refers to an implementation of the Open Content Decryption Module Interface (OCDMI) that uses the Advanced Encryption Standard (AES) algorithm for content decryption.</p>
<p>OCDMI is a part of the OpenCDM project, which aims to provide an open-source and modular Content Decryption Module (CDM) solution for various DRM systems. CDMs are used in conjunction with the Encrypted Media Extensions (EME) to enable the playback of encrypted multimedia content in web browsers.</p>
<p>AES (Advanced Encryption Standard) is a widely used symmetric encryption algorithm that provides strong security for data encryption and decryption. In the context of AES OCDMI, the AES algorithm is used to decrypt the protected multimedia content within the secure environment provided by the OpenCDM framework.</p>
<p>To sum up, AES OCDMI is an open-source solution for securely decrypting protected multimedia content using the AES encryption algorithm within the OpenCDM framework.</p>
<hr>
<p><strong>Question:</strong> How is SMAF used in DRM? <code>(2023-04-11)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The Secure Memory Allocator Framework (SMAF) is a framework that can be used in conjunction with Digital Rights Management (DRM) systems to provide an additional layer of security for handling sensitive data. In a DRM context, sensitive data can include encryption keys, decrypted content, or any other data that must be protected from unauthorized access.</p>
<p>SMAF is designed to provide secure memory allocation and management in a system. It allocates memory from a secure memory pool that is reserved for trusted applications, such as DRM systems, and is inaccessible to the normal world or untrusted applications. This helps prevent unauthorized access, tampering, or copying of the sensitive data, ensuring that the content remains protected.</p>
<p>In a typical DRM implementation using SMAF:</p>
<ol>
<li>A trusted application, such as a DRM module, requests secure memory allocation from the SMAF.</li>
<li>The SMAF allocates memory from the secure memory pool and provides a handle or reference to the trusted application.</li>
<li>The trusted application uses the allocated secure memory to store sensitive data, such as decryption keys or decrypted content.</li>
<li>The sensitive data remains protected within the secure memory, preventing unauthorized access from the normal world or untrusted applications.</li>
</ol>
<p>By using SMAF, DRM systems can ensure that sensitive data is securely stored and managed, reducing the risk of unauthorized access, tampering, or copying of protected content.</p>
<hr>
<p><strong>Question:</strong> What is OCDM? <code>(2023-04-10)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OCDM stands for Open Content Decryption Module. It is an open-source implementation of a Content Decryption Module (CDM) designed to work with the Encrypted Media Extensions (EME) standard, which is part of the HTML5 specification. EME provides a framework for playing encrypted multimedia content in web browsers without the need for third-party plugins such as Adobe Flash or Microsoft Silverlight.</p>
<p>The primary purpose of OCDM is to enable the decryption and playback of protected multimedia content in web browsers, while still maintaining the necessary security and Digital Rights Management (DRM) requirements set by content providers. OCDM aims to provide a standard, cross-platform interface for integrating various DRM systems into web browsers, making it easier for developers to create and deploy secure media solutions.</p>
<p>OCDM is designed to work with various DRM systems and can be extended to support new DRM technologies as they emerge. This allows content providers to use a single, unified solution for delivering protected content to multiple platforms and devices, reducing the complexity of managing multiple DRM systems.</p>
<hr>
<p><strong>Question:</strong> What is Clear Key? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Clear Key is a simple, non-proprietary DRM (Digital Rights Management) system defined by the W3C (World Wide Web Consortium) as part of the Encrypted Media Extensions (EME) specification. EME is a standard interface for using DRM within web browsers to protect copyrighted content during streaming.</p>
<p>Clear Key is essentially a key management system that allows for the decryption of media content using clear-text (unencrypted) cryptographic keys. The primary purpose of Clear Key is to serve as a reference implementation for testing and development purposes. It is not meant to be a robust DRM solution for commercial use, as it lacks the sophisticated security features offered by other DRM systems, such as Google's Widevine or Microsoft's PlayReady.</p>
<p>In summary, Clear Key is a simple and open DRM system used mainly for testing and development of EME-supported web browsers and applications.</p>
<hr>
<h2 id="user-content-secure-storage"><a class="heading-link" href="#secure-storage">Secure Storage<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Does OP-TEE support file system? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE itself does not provide a full-fledged file system like those found in traditional operating systems. However, it does offer secure storage functionality that allows trusted applications to store and manage persistent data securely. The secure storage feature in OP-TEE is designed to protect sensitive data from unauthorized access and tampering.</p>
<p>The secure storage is implemented using a key-value store model, where each object (file) is associated with a unique identifier. Trusted applications can use the TEE Internal Core API to read, write, and delete objects in the secure storage. This API provides functions like <code>TEE_CreatePersistentObject</code>, <code>TEE_OpenPersistentObject</code>, <code>TEE_ReadObjectData</code>, <code>TEE_WriteObjectData</code>, and <code>TEE_CloseAndDeletePersistentObject</code>.</p>
<p>Under the hood, the secure storage in OP-TEE uses encryption and authentication techniques to protect the stored data. The actual storage is typically located in the normal world file system, but the data is encrypted and protected in such a way that it can only be accessed and manipulated by the intended trusted applications in the secure world.</p>
<p>In summary, OP-TEE does not have a traditional file system, but it does provide secure storage functionality for trusted applications to store and manage sensitive data securely.</p>
<hr>
<p><strong>Question:</strong> How does OP-TEE generate SSK from HUK in tee_fs_init_key_manager()? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE, the <code>tee_fs_init_key_manager()</code> function is responsible for generating the Secure Storage Key (SSK) from the Hardware Unique Key (HUK). This process takes place during the initialization of the secure file system. The function can be found in the <code>core/tee/tee_fs_key_manager.c</code> file in the OP-TEE source code.</p>
<p>Here's an overview of the steps involved in generating the SSK from the HUK in <code>tee_fs_init_key_manager()</code>:</p>
<ol>
<li>Retrieve the HUK: The HUK is obtained by calling <code>tee_otp_get_hw_unique_key()</code>. This function retrieves the device-specific hardware unique key and stores it in a <code>tee_hw_unique_key</code> structure.</li>
</ol>
<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> <span class="pl-smi">tee_hw_unique_key</span> <span class="pl-s1">huk</span> <span class="pl-c1">=</span> {<span class="pl-c1">0</span>};
<span class="pl-k">if</span> (<span class="pl-en">tee_otp_get_hw_unique_key</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">huk</span>) <span class="pl-c1">!=</span> <span class="pl-c1">TEE_SUCCESS</span>)
    <span class="pl-k">return</span> <span class="pl-c1">TEE_ERROR_SECURITY</span>;</pre></div>
<ol start="2">
<li>Create a message containing a static string and the device's chip ID: The message is created by concatenating a static string (e.g., "ONLY_FOR_tee_fs_ssk") and the device's chip ID, which can be obtained using <code>tee_otp_get_die_id()</code>.</li>
</ol>
<div class="highlight highlight-source-c"><pre><span class="pl-smi">uint8_t</span> <span class="pl-s1">message</span>[<span class="pl-k">sizeof</span>(<span class="pl-s1">ssk_gen_message</span>) <span class="pl-c1">+</span> <span class="pl-c1">TEE_FS_KM_CHIP_ID_LENGTH</span>] <span class="pl-c1">=</span> {<span class="pl-c1">0</span>};
<span class="pl-en">memcpy</span>(<span class="pl-s1">message</span>, <span class="pl-s1">ssk_gen_message</span>, <span class="pl-k">sizeof</span>(<span class="pl-s1">ssk_gen_message</span>));
<span class="pl-k">if</span> (<span class="pl-en">tee_otp_get_die_id</span>(<span class="pl-s1">message</span> <span class="pl-c1">+</span> <span class="pl-k">sizeof</span>(<span class="pl-s1">ssk_gen_message</span>), <span class="pl-c1">TEE_FS_KM_CHIP_ID_LENGTH</span>) <span class="pl-c1">!=</span>
    <span class="pl-c1">TEE_SUCCESS</span>)
    <span class="pl-k">return</span> <span class="pl-c1">TEE_ERROR_SECURITY</span>;</pre></div>
<ol start="3">
<li>Derive the SSK: The SSK is derived from the HUK using the HMAC-SHA-256 function. The HMAC function takes the HUK as the key and the message created in the previous step as input data. The result is a 256-bit output, which is used as the SSK.</li>
</ol>
<div class="highlight highlight-source-c"><pre><span class="pl-smi">uint8_t</span> <span class="pl-s1">digest</span>[<span class="pl-c1">TEE_FS_KM_HMAC_SHA256_DIGEST_SIZE</span>] <span class="pl-c1">=</span> {<span class="pl-c1">0</span>};
<span class="pl-smi">TEE_Result</span> <span class="pl-s1">res</span> <span class="pl-c1">=</span> <span class="pl-en">tee_do_hmac_sha256</span>(<span class="pl-s1">huk</span>.<span class="pl-c1">data</span>, <span class="pl-k">sizeof</span>(<span class="pl-s1">huk</span>.<span class="pl-c1">data</span>), <span class="pl-s1">message</span>,
                                    <span class="pl-k">sizeof</span>(<span class="pl-s1">message</span>), <span class="pl-s1">digest</span>);
<span class="pl-k">if</span> (<span class="pl-s1">res</span> <span class="pl-c1">!=</span> <span class="pl-c1">TEE_SUCCESS</span>)
    <span class="pl-k">return</span> <span class="pl-s1">res</span>;

<span class="pl-en">memcpy</span>(<span class="pl-s1">tee_fs_ssk</span>.<span class="pl-c1">key</span>, <span class="pl-s1">digest</span>, <span class="pl-k">sizeof</span>(<span class="pl-s1">tee_fs_ssk</span>.<span class="pl-c1">key</span>));</pre></div>
<p>After these steps, the SSK is generated and stored in the <code>tee_fs_ssk</code> global variable, which is used by the secure file system for encryption and decryption.</p>
<p>In summary, the <code>tee_fs_init_key_manager()</code> function in OP-TEE generates the SSK from the HUK by first retrieving the HUK and then using the HMAC-SHA-256 function with a message consisting of a static string and the device's chip ID. The derived SSK is then used for encryption and decryption in the secure file system.</p>
<hr>
<p><strong>Question:</strong> In the function, can I read the content of the HUK? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>In OP-TEE's <code>tee_fs_init_key_manager()</code> function, the Hardware Unique Key (HUK) is retrieved and stored in a local variable. While it is technically possible to read the content of the HUK within this function, doing so would pose a security risk. The HUK is intended to be a secret key, unique to each device, and should not be exposed to unauthorized parties.</p>
<p>If you want to inspect the HUK for debugging or development purposes, you can use debug logging functions (such as <code>DMSG()</code> or <code>EMSG()</code>) to print the content of the HUK within the <code>tee_fs_init_key_manager()</code> function. However, you should remove or disable such logging statements before deploying your OP-TEE build in a production environment, to ensure the security of the HUK.</p>
<p>Keep in mind that exposing the HUK can lead to potential security vulnerabilities, as it serves as the basis for deriving various other keys (such as the Secure Storage Key) used in OP-TEE's secure services. It is crucial to handle the HUK and other sensitive data carefully to maintain the overall security of the system.</p>
<hr>
<p><strong>Question:</strong> How do I protect HUK from reading in OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Protecting the Hardware Unique Key (HUK) is essential for ensuring the security of an OP-TEE-based system. Since the HUK is used as the basis for deriving other keys and securing various sensitive operations, it is crucial to keep it confidential. Here are some best practices for protecting the HUK in OP-TEE:</p>
<ol>
<li>
<p>Limit access to the HUK: Ensure that the HUK is only accessed by the necessary parts of the OP-TEE core and limit its exposure to other components. This can be achieved by using the HUK only within trusted functions and avoiding passing it as a parameter to other functions or storing it in global variables.</p>
</li>
<li>
<p>Avoid logging the HUK: When developing or debugging OP-TEE, avoid logging the HUK or any derived keys. If you need to debug HUK-related issues, make sure to remove or disable any logging statements before deploying your build in a production environment.</p>
</li>
<li>
<p>Protect HUK storage in hardware: The HUK is usually stored in a secure, tamper-resistant location within the device hardware, such as a one-time programmable (OTP) memory or a secure element. Ensure that the hardware implementation adequately protects the HUK from unauthorized access or tampering.</p>
</li>
<li>
<p>Protect the HUK during retrieval: When the HUK is retrieved from hardware, use platform-specific secure functions to access it, and make sure that the retrieval process is implemented securely to prevent unauthorized access to the HUK.</p>
</li>
<li>
<p>Secure software implementation: Follow secure coding practices to minimize the risk of software vulnerabilities that could lead to unauthorized access to the HUK or other sensitive data. Regularly review and update the OP-TEE implementation to incorporate the latest security patches and enhancements.</p>
</li>
<li>
<p>Secure boot process: Implement a secure boot process to ensure that only authorized and trusted code can execute on the device. This will help prevent potential attacks that could compromise the HUK or other sensitive information.</p>
</li>
</ol>
<p>By following these best practices, you can help protect the HUK from unauthorized access and maintain the security of your OP-TEE-based system. Remember that safeguarding the HUK is crucial, as it serves as the foundation for various other keys and secure operations within the system.</p>
<hr>
<p><strong>Question:</strong> Is SSK defined in GlobalPlatform? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The Secure Storage Key (SSK) concept, as implemented in OP-TEE, is not directly defined by the GlobalPlatform TEE specifications. The GlobalPlatform TEE specifications define a set of APIs and security requirements for Trusted Applications and the TEE itself but do not specifically address the implementation details of secure storage.</p>
<p>In OP-TEE, the SSK is used for encrypting and decrypting data stored in the secure storage. It is derived from the Hardware Unique Key (HUK) using a Key Derivation Function (KDF). While this implementation choice is specific to OP-TEE, it aligns with the broader security goals outlined by the GlobalPlatform TEE specifications, such as ensuring the confidentiality and integrity of data in secure storage.</p>
<p>The GlobalPlatform TEE specifications provide guidance on general security requirements, but individual TEE implementations, such as OP-TEE, can choose how to implement specific features like secure storage and key management, as long as they meet the overall security objectives of the specifications.</p>
<hr>
<h2 id="user-content-recover-op-tee"><a class="heading-link" href="#recover-op-tee">Recover OP-TEE<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> How to detect OP-TEE dead? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Detecting if OP-TEE is dead or non-responsive can be done through various mechanisms. Here are some approaches:</p>
<ol>
<li>
<p>Timeouts: Set a timeout for the normal world when waiting for a response from OP-TEE. If the timeout expires and no response has been received, consider OP-TEE non-responsive or dead.</p>
</li>
<li>
<p>Heartbeat mechanism: Implement a periodic "heartbeat" or "ping" mechanism between the normal world and OP-TEE. If the normal world does not receive a response within a predefined time interval, consider OP-TEE non-responsive or dead.</p>
</li>
<li>
<p>Error checking: Monitor the normal world's interactions with OP-TEE for unexpected errors or responses. If such errors occur, it may indicate a problem with OP-TEE's operation.</p>
</li>
<li>
<p>System logs: Analyze system logs and debug messages to identify any unexpected behaviors or error messages from OP-TEE.</p>
</li>
<li>
<p>External monitoring: Use an external hardware or software monitoring solution to detect any anomalies in the operation of the device or the secure world.</p>
</li>
</ol>
<p>In case OP-TEE is determined to be non-responsive or dead, a proper recovery or debugging mechanism should be in place to handle such situations. This might include resetting the device, collecting debug information, or triggering a fail-safe mechanism.</p>
<hr>
<p><strong>Question:</strong> How to automatically recovery the crashed OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Automatically recovering a crashed OP-TEE can be challenging, as the recovery process depends on the root cause of the crash and the available recovery mechanisms. However, you can implement a watchdog mechanism to detect and attempt to recover from a crash automatically. Here are some general steps to consider:</p>
<ol>
<li>
<p>Implement a watchdog timer: Utilize a hardware or software watchdog timer to monitor OP-TEE's operation. The timer should be periodically reset by the OP-TEE under normal operation. If OP-TEE crashes, the timer will not be reset, and the watchdog mechanism will trigger a recovery action after a predefined timeout.</p>
</li>
<li>
<p>Monitor normal world and secure world communication: Regularly check the communication between the normal world and the secure world. If the communication stalls or encounters unexpected errors, trigger a recovery action.</p>
</li>
<li>
<p>Define recovery actions: Design recovery actions to take when a crash is detected. Possible actions include:
a. Reset the device.
b. Reset the secure world or restart OP-TEE without affecting the normal world.
c. Switch to a failsafe mechanism or an alternative trusted execution environment.</p>
</li>
<li>
<p>Test and validate: Thoroughly test and validate the automatic recovery mechanism to ensure it works as intended and does not introduce additional security risks or undesired side effects.</p>
</li>
<li>
<p>Implement error reporting: After a crash and recovery, collect and report relevant logs, error messages, or diagnostic information to aid in future debugging and analysis.</p>
</li>
</ol>
<p>Please note that the specific implementation of an automatic recovery mechanism will depend on your device, its hardware and software stack, and the nature of the crash. Implementing such a mechanism can be complex and requires careful consideration of security implications and system behavior. It is essential to have a well-defined recovery plan and debugging mechanism in place for such situations.</p>
<hr>
<p><strong>Question:</strong> Can I develop a dual OP-TEE so that if one is crashed, run another. <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Developing a dual OP-TEE setup to provide redundancy in case one crashes is an interesting idea. Although it might not be straightforward, you can consider the following approach:</p>
<ol>
<li>
<p>Run two instances of OP-TEE: Modify the bootloader and memory layout to accommodate two separate OP-TEE instances running on different cores or partitions of the device. Each OP-TEE instance should have its own secure memory space, and they should not interfere with each other.</p>
</li>
<li>
<p>Synchronize states: Implement a mechanism to synchronize the state and configuration between the two OP-TEE instances. This will ensure that if one instance crashes, the other can take over seamlessly.</p>
</li>
<li>
<p>Monitor OP-TEE health: Develop a health monitoring system that continuously checks the status of both OP-TEE instances. If an issue is detected with one instance, the monitoring system should automatically switch to the other instance.</p>
</li>
<li>
<p>Coordinate normal world communication: Modify the normal world OS and the secure world communication layer to support communicating with multiple OP-TEE instances. This may involve load balancing and failover mechanisms to distribute requests and handle failures.</p>
</li>
<li>
<p>Handle failover: Implement a failover mechanism that quickly switches between OP-TEE instances in case of a crash. This could include redirecting pending requests to the other instance, transferring the state, and ensuring secure storage continuity.</p>
</li>
</ol>
<p>Please note that implementing a dual OP-TEE setup can be complex and may introduce additional security risks and performance overhead. It is essential to carefully analyze the system design, security implications, and potential trade-offs before implementing such a solution. Additionally, thorough testing and validation will be required to ensure the dual OP-TEE setup functions as intended without introducing new vulnerabilities or unexpected side effects.</p>
<hr>
<p><strong>Question:</strong> How to detect if OP-TEE is tamperred at run-time? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Detecting if OP-TEE has been tampered with at runtime is a challenging task, as an attacker who successfully infiltrates the TEE environment could attempt to hide their activities. However, you can implement some techniques to help identify potential tampering:</p>
<ol>
<li>
<p>Runtime integrity checks: Perform periodic integrity checks of the OP-TEE code and data segments while the system is running. This can be achieved by calculating a hash or checksum of these memory regions and comparing them with their expected values.</p>
</li>
<li>
<p>Hardware-based security features: Leverage hardware security features like ARM TrustZone's secure memory, which can prevent unauthorized access to sensitive memory regions. Secure memory can protect critical OP-TEE data structures and code from being tampered with by external entities.</p>
</li>
<li>
<p>Secure boot: Ensure that the system uses secure boot, which verifies the integrity of the bootloader, kernel, and OP-TEE components during the boot process. A secure boot chain can minimize the chances of tampering with OP-TEE before it starts running.</p>
</li>
<li>
<p>Hardware security modules (HSMs): HSMs can provide additional protection against tampering by securely storing cryptographic keys and performing sensitive operations within the secure hardware environment.</p>
</li>
<li>
<p>Monitor system behavior: Keep an eye on the system's behavior and resource utilization. Unusual patterns or unexpected resource usage may be indicative of tampering or an ongoing attack.</p>
</li>
<li>
<p>Logging and auditing: Maintain detailed logs of activities within the OP-TEE environment and perform regular audits to identify potential anomalies or unauthorized actions.</p>
</li>
<li>
<p>Use of external monitoring tools: Employ external runtime monitoring tools that can analyze the runtime behavior of the system to detect anomalies or signs of tampering.</p>
</li>
</ol>
<p>Keep in mind that no single technique can provide complete protection against tampering. It is crucial to use a combination of methods and maintain a strong security posture through continuous monitoring, testing, and updating of your system's security mechanisms.</p>
<hr>
<h2 id="user-content-attack"><a class="heading-link" href="#attack">Attack<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> Whare are kinds of methods to attack OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>There are various methods an attacker might use to target OP-TEE. Some of the common attack vectors include:</p>
<ol>
<li>
<p>Exploiting software vulnerabilities: Attackers can exploit bugs or vulnerabilities in the OP-TEE code, such as buffer overflows, use-after-free, or format string vulnerabilities, to gain unauthorized access or escalate privileges within the TEE.</p>
</li>
<li>
<p>Side-channel attacks: These attacks focus on extracting sensitive information by observing the physical characteristics of the system, such as power consumption, electromagnetic emissions, or timing information. Examples include cache-timing attacks, power analysis attacks, and differential fault analysis.</p>
</li>
<li>
<p>Reverse engineering: Attackers can reverse-engineer the OP-TEE firmware to discover vulnerabilities, understand internal structures, or extract sensitive information such as cryptographic keys.</p>
</li>
<li>
<p>Bypassing secure boot: If an attacker can compromise the secure boot process, they can potentially tamper with or replace the OP-TEE components before they are loaded into memory, undermining the entire TEE's security.</p>
</li>
<li>
<p>Physical attacks: Sophisticated attackers may attempt to directly manipulate the hardware, for example, by probing the memory bus or tampering with the hardware security modules (HSMs).</p>
</li>
<li>
<p>Social engineering: Attackers can use social engineering techniques to trick developers or users into disclosing sensitive information or installing malicious software that compromises the TEE environment.</p>
</li>
<li>
<p>Compromising the rich execution environment (REE): If an attacker gains control over the REE, they might attempt to exploit the communication channel between the REE and the TEE to manipulate or intercept sensitive data.</p>
</li>
<li>
<p>Fault injection attacks: By inducing faults in the hardware, an attacker can cause the system to behave unexpectedly, potentially revealing sensitive information or bypassing security mechanisms. Examples include voltage glitching, clock glitching, and laser fault injection.</p>
</li>
<li>
<p>Rollback attacks: An attacker might attempt to revert the TEE to a previous, vulnerable state, allowing them to exploit known vulnerabilities or bypass security patches.</p>
</li>
</ol>
<p>To mitigate these risks, it's essential to maintain a strong security posture, implement secure coding practices, and regularly update OP-TEE to the latest version. Additionally, employ hardware-based security features and perform regular security audits to identify potential vulnerabilities.</p>
<hr>
<h2 id="user-content-virtualization"><a class="heading-link" href="#virtualization">Virtualization<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> The following article are from the website <a href="https://optee.readthedocs.io/en/latest/architecture/virtualization.html" rel="nofollow">https://optee.readthedocs.io/en/latest/architecture/virtualization.html</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The following is a summary of OP-TEE's experimental virtualization support, as described in the article:</p>
<ul>
<li>One OP-TEE instance can run TAs from multiple virtual machines, isolating all VM-related states to prevent one VM from affecting another.</li>
<li>OP-TEE relies on a hypervisor (e.g., Xen) to determine which VM is calling it, and the hypervisor must inform OP-TEE about the creation and destruction of VMs.</li>
<li>OP-TEE cannot translate intermediate physical addresses (IPAs) to physical addresses (PAs), so the hypervisor is responsible for this translation.</li>
<li>Virtualization support is enabled with the CFG_VIRTUALIZATION configuration option, and the maximum number of supported VMs is controlled by CFG_VIRT_GUEST_COUNT.</li>
<li>Hypervisors must be aware of OP-TEE, handle SMCs from virtual guests, perform IPA&lt;-&gt;PA address translation, and manage memory pages shared between VMs and OP-TEE.</li>
<li>Limitations of the experimental virtualization support include platform support (only Armv8 is supported and tested on QEMU-V8), static VM guest count and memory allocation, sharing hardware resources and PTAs, compatibility with "normal" mode, and the experimental state of the technology.</li>
<li>The implementation details of OP-TEE virtualization support involve splitting OP-TEE into "nexus" (core part) and TEE (handles requests and runs TAs). There is one nexus instance and multiple TEE instances, one for each registered VM. Banked memory sections are used for TEE/VM instances, and the nexus and TEE have separate heaps.</li>
</ul>
<p>This summary provides an overview of OP-TEE's experimental virtualization support, but it is essential to refer to the original documentation for a complete understanding of the technology, its requirements, and its limitations.</p>
<hr>
<p><strong>Question:</strong> Does the hypervisor relied on OP-TEE run in normal world or secure world? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The hypervisor that OP-TEE relies on runs in the normal world. It is responsible for managing multiple virtual machines and handling the communication between the normal world and OP-TEE in the secure world. The hypervisor must be aware of OP-TEE, handle SMCs from virtual guests, perform IPA &lt;-&gt; PA address translation, and manage memory pages shared between VMs and OP-TEE.</p>
<hr>
<p><strong>Question:</strong> Does OP-TEE support VMs? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Yes, OP-TEE supports working with virtual machines (VMs) in the sense that it can operate in a virtualized environment managed by a hypervisor. The hypervisor is responsible for managing VMs running in the normal world, while OP-TEE provides secure services in the secure world.</p>
<p>In a virtualized environment, OP-TEE works in conjunction with a hypervisor, like Xen or KVM on ARM, to provide secure services to multiple VMs running on the same hardware platform. The hypervisor ensures the secure world's isolation from the normal world and enforces proper access control policies to prevent unauthorized access to sensitive resources.</p>
<p>However, it is important to note that OP-TEE itself does not directly manage the VMs; it works with a hypervisor that is responsible for managing the VMs in the normal world.</p>
<hr>
<p><strong>Question:</strong> Is the technology of OP-TEE supporting VMs mature? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>The technology of OP-TEE supporting VMs is maturing but may not be considered fully mature yet. There have been significant efforts put into enabling OP-TEE to work with virtual machines and hypervisors. OP-TEE does provide support for virtualization, as described in its documentation, and some projects, such as XEN Project, have been working on integrating OP-TEE with their hypervisors.</p>
<p>However, the maturity of this technology can vary depending on the specific use cases, hardware platforms, and hypervisors in question. It is advisable to assess the maturity of the technology on a case-by-case basis and consult with experts or the community to ensure that the chosen solution meets the required security and performance needs.</p>
<hr>
<p><strong>Question:</strong> Does a TA run in a VM described in the article? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>No, a Trusted Application (TA) does not run inside a Virtual Machine (VM) as described in the article. Instead, the TA runs in the secure world within the OP-TEE environment. The hypervisor manages the VMs in the normal world and is responsible for handling the communication between the normal world and OP-TEE in the secure world. When OP-TEE has virtualization support enabled, it allows multiple VMs to utilize a single OP-TEE instance for running TAs while maintaining isolation between the VM-related states.</p>
<hr>
<h2 id="user-content-pkcs11"><a class="heading-link" href="#pkcs11">PKCS#11<span aria-hidden="true" class="octicon octicon-link"></span></a></h2>
<p><strong>Question:</strong> The following text are from <a href="https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html" rel="nofollow">https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> The following continued text are from <a href="https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html" rel="nofollow">https://optee.readthedocs.io/en/latest/architecture/porting_guidelines.html</a> <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong> ... ...</p>
<hr>
<p><strong>Question:</strong> What is HUK? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>HUK stands for Hardware Unique Key. It is a unique, device-specific key that is generated and stored within a device's hardware during manufacturing. HUKs are used to provide a root of trust and ensure secure device identification and authentication. In the context of OP-TEE, the Hardware Unique Key can be used to derive other cryptographic keys to secure various aspects of the system, such as secure storage or secure communication.</p>
<hr>
<p><strong>Question:</strong> How does OP-TEE work with HUK? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>OP-TEE (Open Portable Trusted Execution Environment) is designed to provide a secure environment for the execution of trusted applications on a device. One of the critical components for providing security within OP-TEE is the use of a Hardware Unique Key (HUK).</p>
<p>A Hardware Unique Key is a device-specific secret key that is usually derived from or securely stored in hardware. HUKs are essential for providing a secure root of trust, as they can be used to derive other cryptographic keys and establish secure communication channels between different components of a system.</p>
<p>Here's how OP-TEE works with HUK:</p>
<ol>
<li>
<p>In OP-TEE, the HUK is used to derive other keys for various purposes, such as secure storage or cryptographic operations. The derived keys are typically used in combination with other keys or cryptographic primitives to ensure the confidentiality, integrity, and authenticity of the data being processed.</p>
</li>
<li>
<p>The function tee_otp_get_hw_unique_key(...) in core/include/kernel/tee_common_otp.h is responsible for retrieving the HUK from the hardware. In a real secure product, this function must be replaced with an implementation that retrieves the HUK from the device's hardware. This ensures that the HUK remains protected and cannot be accessed directly from software, even on the secure side.</p>
</li>
<li>
<p>If the device does not have hardware support for a HUK, it is crucial to change the implementation of the tee_otp_get_hw_unique_key(...) function to use something other than zeroes. Storing a key in software is not a secure practice, especially for a key that serves as the root for all other keys. As such, it is not recommended, but it may be necessary if hardware support is lacking.</p>
</li>
<li>
<p>Once the HUK is securely retrieved, it can be used by OP-TEE to derive other keys or perform cryptographic operations necessary for securing trusted applications and their data. The HUK helps establish a root of trust that can be extended to other parts of the system.</p>
</li>
</ol>
<p>In summary, OP-TEE works with HUKs by leveraging them to derive other cryptographic keys and establish a root of trust for secure operations. The HUK is typically retrieved from the hardware using a secure function, and it is essential for providing a strong foundation for the security of the entire system.</p>
<hr>
<p><strong>Question:</strong> What are common device that store HUK in ARM platform with OP-TEE? <code>(2023/4/1)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>Many devices in the ARM platform, especially those utilizing TrustZone technology, store Hardware Unique Keys (HUKs) for providing a secure root of trust. Some common devices that store HUKs and are compatible with OP-TEE include:</p>
<ol>
<li>
<p>NXP i.MX family: Devices in the i.MX family, like i.MX6, i.MX7, and i.MX8, use ARM TrustZone and secure boot capabilities. They have integrated security features, such as cryptographic accelerators and secure storage, where the HUK can be stored.</p>
</li>
<li>
<p>Xilinx Zynq UltraScale+ MPSoC: The Zynq UltraScale+ MPSoC has ARM Cortex-A53 and Cortex-R5 cores with TrustZone technology. It provides secure boot and supports storage of HUK in the on-chip eFUSE memory.</p>
</li>
<li>
<p>STMicroelectronics STM32MP1: The STM32MP1 series, with its ARM Cortex-A7 and Cortex-M4 cores, supports OP-TEE and TrustZone. It provides secure storage for HUKs using its OTP (One-Time Programmable) memory or other secure storage mechanisms.</p>
</li>
<li>
<p>HiSilicon HiKey and HiKey 960: These development boards, based on HiSilicon's Kirin SoCs, feature ARM Cortex-A cores with TrustZone technology. They can be used with OP-TEE and support secure storage for HUKs.</p>
</li>
<li>
<p>Raspberry Pi 3 (unofficially): While not officially supported by OP-TEE, Raspberry Pi 3, featuring a Broadcom SoC with ARM Cortex-A53 cores, has been known to run OP-TEE. However, the secure storage of HUKs on Raspberry Pi 3 may not be as robust as in other devices designed with hardware security features in mind.</p>
</li>
</ol>
<p>These are just a few examples of devices that store HUKs and can work with OP-TEE on the ARM platform. It's important to note that the secure storage and management of HUKs may vary depending on the specific device, its hardware features, and the implementation of OP-TEE. Always consult the device's documentation and follow the manufacturer's guidelines to ensure proper security measures are in place.</p>
<hr>
<p><strong>Question:</strong> So what is TSK? <code>(2023-04-13)</code> <code>(OP-TEE.0327.md)</code></p>
<p><strong>Answer:</strong></p>
<p>TSK stands for Trusted Storage Key. In the context of OP-TEE, it is a key used to encrypt and authenticate the data stored in the secure storage. The TSK is derived from the Hardware Unique Key (HUK) and other device-specific information, which ensures that the encrypted data can only be accessed and decrypted by the same device. This provides a secure way to store sensitive data, such as cryptographic keys or user credentials, on the device.</p>
<hr>
</article></body></html>