
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    @font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
    color:#333;
    background:#fff;
}

body .markdown-body {
    padding: 45px;
    word-wrap: break-word;
}

.markdown-body .octicon-link:before {
  font: normal normal normal 16px/1 octicons-link;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  content: '\f05c';
  vertical-align: middle;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
    </style>
    <title>2023-03-29</title>    
  </head>
  <body>
    <article class="markdown-body">
        <!-- Markdown-generated HTML content here -->
        <h1>2023-03-29</h1>
<p>Created: 2023-04-19 22:35:18</p>
<h1>Questions</h1>
<ul>
<li>Normal World &amp; Secure World @ TrustZone.0329.md<ul>
<li><code>[08:51]</code> Can Normal world and Secure World run at the same time in ARM?</li>
<li><code>[08:52]</code> But can Normal world and Secure World run at the same time in multi processors of ARM?</li>
</ul>
</li>
<li>Memory @ TrustZone.0329.md<ul>
<li><code>[08:53]</code> How to define memory size of secure world?</li>
<li><code>[08:53]</code> Can memory size of secure world be changed?</li>
</ul>
</li>
<li>SM &amp; SPM &amp; SPD @ TrustZone.0329.md<ul>
<li><code>[08:55]</code> What is SMC?</li>
<li><code>[08:57]</code> Can secure world request a service in normal world via SMC?</li>
<li><code>[09:00]</code> What is SPD?</li>
<li><code>[09:03]</code> Can SPD handle the request from the secure world?</li>
<li><code>[09:05]</code> What is SPM?</li>
<li><code>[09:41]</code> Why are SPD and SPM mutually exclusive?</li>
</ul>
</li>
<li>Secure Partition @ TrustZone.0329.md<ul>
<li><code>[09:04]</code> What is SP?</li>
<li><code>[09:05]</code> Can different SPs communicate together?</li>
<li><code>[09:06]</code> How to create a SP and when?</li>
<li><code>[09:08]</code> Can I create a SP in run-time?</li>
<li><code>[09:08]</code> What is TA?</li>
<li><code>[09:24]</code> How do TAs and SPs communicate each other?</li>
<li><code>[09:43]</code> Can a SP host many TAs?</li>
<li><code>[09:44]</code> Can a TA communicate different SP?</li>
</ul>
</li>
<li>Privilege Levels @ TrustZone.0329.md<ul>
<li><code>[09:44]</code> What are EL0, EL1, EL2, S-EL0, S-EL1, S-EL2, S-EL3?</li>
</ul>
</li>
<li>Basic Concepts @ TEE.0328.md<ul>
<li><code>[10:04]</code> https://en.wikipedia.org/wiki/Trusted_execution_environment</li>
<li><code>[13:55]</code> Please summarize Intel SGX and ARM TrustZone in tables.</li>
<li><code>[13:58]</code> What are different between ARM SMC and Intel SMI? Please also summarize in a table.</li>
<li><code>[13:59]</code> Please describe TEE in Intel.</li>
<li><code>[14:00]</code> What are APIs of TEE? Please classify them.</li>
<li><code>[14:02]</code> Can I add a myself TEE API?</li>
</ul>
</li>
<li>Memory @ OP-TEE.0327.md<ul>
<li><code>[16:19]</code> How does OP-TEE manage memory?</li>
<li><code>[16:27]</code> Are data in memory in secure world encrypted?</li>
</ul>
</li>
<li>Signature @ OP-TEE.0327.md<ul>
<li><code>[16:44]</code> Is signature required when a normal world application request a service in secure world?</li>
</ul>
</li>
<li>CA &amp; TA @ TEE.0328.md<ul>
<li><code>[16:56]</code> How does an  application in normal world request a service with shared memory of a trusted application in a secure world? Please describe the process with APIs.</li>
<li><code>[17:10]</code> Which functions are used by TA (trusted application) in the above process?</li>
<li><code>[17:16]</code> Could you please draw a sequence diagram of TEEC_InitializeContext, TEEC_OpenSession, TEEC_RegisterSharedMemory, TEEC_InvokeCommand, TEEC_ReleaseSharedMemory, TEEC_CloseSession, TEEC_FinalizeContext, TA_CreateEntryPoint, TA_DestroyEntryPoint, TA_OpenSessionEntryPoint, TA_CloseSessionEntryPoint, TA_InvokeCommandEntryPoint</li>
<li><code>[17:25]</code> Is the above sequence described in GlobalPlatform?</li>
<li><code>[17:27]</code> Which document describe it?</li>
<li><code>[17:36]</code> Please give me two sample codes of the above sequence. One is for CA and another is for TA.</li>
<li><code>[17:40]</code> Please write sample code of TA again. The code should be complete.</li>
</ul>
</li>
</ul>
<hr />
<h1>Q &amp; A</h1>
<h2>Normal World &amp; Secure World @ TrustZone.0329.md</h2>
<p><strong>Question:</strong> <code>[08:51]</code> Can Normal world and Secure World run at the same time in ARM?</p>
<p><strong>Answer:</strong></p>
<p>In ARM TrustZone, the Normal world and Secure world cannot run concurrently. The processor can only execute code in either the Normal world or the Secure world at any given time. The two worlds are isolated from each other, and the processor switches between them based on events such as interrupts or requests for secure services. TrustZone uses a secure monitor mode to facilitate the transition between the two worlds, ensuring that the secure and non-secure states remain separate and protected.</p>
<hr />
<p><strong>Question:</strong> <code>[08:52]</code> But can Normal world and Secure World run at the same time in multi processors of ARM?</p>
<p><strong>Answer:</strong></p>
<p>Yes, in a multi-processor ARM system, it is possible for the Normal world and Secure world to run concurrently on separate cores. Each core in the system can be executing in either the Normal world or the Secure world independently. This allows for parallel processing of tasks in both worlds. However, it is important to note that the isolation between the two worlds is still maintained, and each core must follow the same TrustZone mechanisms to transition between the worlds when required.</p>
<hr />
<h2>Memory @ TrustZone.0329.md</h2>
<p><strong>Question:</strong> <code>[08:53]</code> How to define memory size of secure world?</p>
<p><strong>Answer:</strong></p>
<p>Defining the memory size for the secure world in an ARM TrustZone-enabled system is highly dependent on the specific System-on-Chip (SoC) being used. Each SoC has different characteristics and mechanisms for allocating and partitioning memory resources between the secure and non-secure worlds.</p>
<p>Typically, the memory size for the secure world is defined during the system&rsquo;s initialization or configuration phase. The process involves configuring TrustZone-specific hardware components such as TrustZone Protection Controller (TZPC) and TrustZone Address Space Controller (TZASC) to set access permissions and memory partitions.</p>
<p>To define the memory size of the secure world, follow these general steps:</p>
<ol>
<li>
<p>Determine the available memory resources: Consult your SoC&rsquo;s technical reference manual or datasheet to identify the available memory resources and their respective addresses.</p>
</li>
<li>
<p>Configure TZPC and TZASC: Based on the desired memory size for the secure world, configure the TZPC and TZASC registers to partition the memory accordingly. This may involve setting up specific regions and access permissions for secure and non-secure worlds. Some SoCs might provide alternative or additional mechanisms for memory partitioning.</p>
</li>
<li>
<p>Verify and update your secure world software: Ensure your secure world software is aware of the allocated memory size and adapts its memory management accordingly.</p>
</li>
</ol>
<p>Please note that these steps are generalized, and you should refer to the documentation of your specific SoC for exact procedures and register configurations.</p>
<hr />
<p><strong>Question:</strong> <code>[08:53]</code> Can memory size of secure world be changed?</p>
<p><strong>Answer:</strong></p>
<p>In most ARM TrustZone-enabled systems, the memory size of the secure world is typically defined during the system&rsquo;s initialization or configuration phase. However, whether the memory size of the secure world can be changed at runtime depends on the specific System-on-Chip (SoC) being used and its support for dynamic memory partitioning.</p>
<p>Some SoCs may allow for dynamic reconfiguration of TrustZone components like the TrustZone Protection Controller (TZPC) and TrustZone Address Space Controller (TZASC) during runtime, enabling changes to memory partitioning between the secure and non-secure worlds. In such cases, the secure world software would also need to support and be aware of such changes to adapt its memory management accordingly.</p>
<p>To determine if your specific SoC supports changing the memory size of the secure world at runtime, consult the technical reference manual or datasheet provided by the manufacturer. It&rsquo;s important to consider the potential security implications and any restrictions when dynamically changing memory partitioning, as it could introduce new attack surfaces or vulnerabilities.</p>
<hr />
<h2>SM &amp; SPM &amp; SPD @ TrustZone.0329.md</h2>
<p><strong>Question:</strong> <code>[08:55]</code> What is SMC?</p>
<p><strong>Answer:</strong></p>
<p>SMC stands for Secure Monitor Call, which is an ARM instruction used in TrustZone-enabled systems. The SMC instruction is used to transfer control between the non-secure (Normal) world and the secure world. When the non-secure world needs to access a secure resource or service, it uses the SMC instruction to trigger a switch to the secure world. The secure world then handles the request, performs the necessary operations, and returns control back to the non-secure world using the ERET (Exception Return) instruction.</p>
<p>The SMC instruction ensures that transitions between the two worlds are securely managed and controlled, allowing the secure world to maintain its isolation and integrity. Secure Monitor Calls are essential for implementing security services and trusted applications that require isolation from the non-secure world while still providing a controlled interface for communication between the two worlds.</p>
<hr />
<p><strong>Question:</strong> <code>[08:57]</code> Can secure world request a service in normal world via SMC?</p>
<p><strong>Answer:</strong></p>
<p>Yes, the secure world can request a service in the normal world via SMC. Although it&rsquo;s more common for the normal world to request services from the secure world, the secure world may still need to access certain resources or services in the normal world. In such cases, the secure world can use SMC to make a request to the normal world.</p>
<p>However, it&rsquo;s important to note that the secure world should carefully manage any interactions with the normal world to avoid compromising its own security. When the secure world needs to access services or resources in the normal world, it should do so with the understanding that the normal world is potentially untrusted and might attempt to exploit any vulnerabilities in the communication process. Therefore, the implementation of such communication should be done cautiously, with a focus on maintaining the isolation and integrity of the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[09:00]</code> What is SPD?</p>
<p><strong>Answer:</strong></p>
<p>In the context of ARM TrustZone, SPD (Secure Payload Dispatcher) is a component responsible for managing and dispatching Secure Partition (SP) requests. An SPD serves as an intermediary layer between the normal world and secure world, allowing for the secure processing of service requests from the normal world.</p>
<p>When a normal world application requires services provided by the secure world, it issues a request via SMC (Secure Monitor Call). The SPD receives this request, identifies the appropriate secure partition to handle the request, and dispatches the service execution to the corresponding partition. After the secure partition has processed the request, the SPD returns the result to the normal world.</p>
<p>By using an SPD, the secure world can maintain better isolation and security, as the SPD ensures that the normal world does not have direct access to secure partitions or their resources.</p>
<hr />
<p><strong>Question:</strong> <code>[09:03]</code> Can SPD handle the request from the secure world?</p>
<p><strong>Answer:</strong></p>
<p>Yes, the Secure Payload Dispatcher (SPD) can handle requests from both the normal world and the secure world. Although it is more common for the normal world to make service requests to the secure world, there might be cases where the secure world needs to access resources or services available in the normal world.</p>
<p>In such scenarios, the SPD plays a similar role in managing and dispatching these requests. It serves as an intermediary between the two worlds, ensuring that the communication is secure and that the appropriate services are invoked to handle the requests. This way, the secure world can access resources in the normal world without compromising its security and isolation.</p>
<hr />
<p><strong>Question:</strong> <code>[09:05]</code> What is SPM?</p>
<p><strong>Answer:</strong></p>
<p>SPM stands for Secure Partition Manager. In the context of ARM TrustZone or systems with secure partitions, the SPM is a component responsible for managing and orchestrating the execution of Secure Partitions (SPs). The SPM&rsquo;s role includes controlling access to resources, managing communication between SPs, ensuring the isolation of different secure partitions, and enforcing security policies.</p>
<p>In a nutshell, the Secure Partition Manager provides a framework for the secure world to manage the lifecycle and interactions of multiple secure partitions, ensuring that the security and isolation properties of each partition are maintained.</p>
<hr />
<p><strong>Question:</strong> <code>[09:41]</code> Why are SPD and SPM mutually exclusive?</p>
<p><strong>Answer:</strong></p>
<p>The Secure Partition Manager (SPM) and the Secure Partition Dispatcher (SPD) are two different approaches to managing secure partitions in the ARMv8.4-A architecture, and they are mutually exclusive because they serve different purposes and are intended for different use cases.</p>
<ol>
<li>
<p>Secure Partition Manager (SPM): SPM is designed for the ARMv8.4-A architecture and is responsible for managing Secure Partitions (SPs). SPs are isolated execution environments running inside the secure world, which can host multiple security services or Trusted Applications (TAs). The SPM is responsible for creating, initializing, scheduling, and managing communication between SPs. It enables fine-grained partitioning of resources and services within the secure world.</p>
</li>
<li>
<p>Secure Partition Dispatcher (SPD): SPD is a part of ARM Trusted Firmware (ATF) and is used to manage secure services in ARMv8-A architecture. SPD provides an interface between the Normal World (NW) and the Secure World (SW). It is responsible for dispatching secure service requests from the NW to the appropriate secure execution environment, such as an SP or a TA, and returning the results back to the NW.</p>
</li>
</ol>
<p>The reason they are mutually exclusive is that they cater to different architectural versions and use cases. SPM is designed specifically for ARMv8.4-A and provides advanced features for managing SPs, while SPD is used in ARMv8-A to manage secure services.</p>
<p>Using both SPM and SPD simultaneously would lead to conflicts in terms of resource allocation, scheduling, and communication between the secure world and the normal world. To avoid confusion and ensure proper secure partition management, either SPM or SPD is used, depending on the target ARM architecture and the specific use case.</p>
<hr />
<h2>Secure Partition @ TrustZone.0329.md</h2>
<p><strong>Question:</strong> <code>[09:04]</code> What is SP?</p>
<p><strong>Answer:</strong></p>
<p>SP stands for Secure Partition, which is a software component or execution environment running within the secure world of ARM TrustZone. Secure Partitions are designed to provide isolation and protection for sensitive code and data, such as cryptographic operations, key management, or secure storage. The secure world hosts these SPs, which can communicate with the normal world through a well-defined interface, typically via SMC (Secure Monitor Call) instructions.</p>
<p>SPs help to ensure that critical operations and information remain protected from potentially malicious or insecure code running in the normal world. By isolating these components, TrustZone enhances the overall security of a system.</p>
<hr />
<p><strong>Question:</strong> <code>[09:05]</code> Can different SPs communicate together?</p>
<p><strong>Answer:</strong></p>
<p>Yes, different Secure Partitions (SPs) can communicate with each other within the secure world. However, this communication should be carefully designed and managed to maintain the isolation and security properties of each SP. Typically, an intermediary component like a secure partition manager or the secure monitor itself is responsible for facilitating communication between different SPs, ensuring that information sharing adheres to the security policies and requirements of each partition.</p>
<p>To enable secure communication between different SPs, developers should implement well-defined interfaces and access control policies to prevent unauthorized access or information leaks between partitions, maintaining the overall security goals of the system.</p>
<hr />
<p><strong>Question:</strong> <code>[09:06]</code> How to create a SP and when?</p>
<p><strong>Answer:</strong></p>
<p>Creating a Secure Partition (SP) typically involves a few steps and is usually done during the system initialization or when a secure application needs to be launched. Here are the steps to create an SP:</p>
<ol>
<li>
<p>Design: Begin by identifying the secure functionality or application you want to isolate in a separate SP. Determine the security requirements, resource access, and communication interfaces needed for the secure partition.</p>
</li>
<li>
<p>Implementation: Implement the secure functionality or application, adhering to the security requirements and following best practices for secure programming. This may involve writing code and creating any necessary data structures, as well as implementing communication interfaces to interact with other SPs or the normal world.</p>
</li>
<li>
<p>Configuration: Configure the system to support the SP. This might involve configuring memory regions, peripherals, and access controls to meet the security requirements of the SP. This is typically done in the system&rsquo;s bootloader, firmware, or Secure Partition Manager (SPM), depending on the platform.</p>
</li>
<li>
<p>Initialization: Load and initialize the SP during system startup or when required. This process includes loading the secure partition&rsquo;s code and data into the protected memory regions and initializing the partition&rsquo;s state. The SPM or another trusted component may handle this initialization process.</p>
</li>
<li>
<p>Execution: Once initialized, the SP can be executed, providing its secure functionality to other components or applications in the system. The SPM or a trusted scheduler will manage the execution of the SP, ensuring proper isolation and adherence to security policies.</p>
</li>
</ol>
<p>Creating an SP depends on the specific platform or system you are working with, as well as the requirements of your secure application. Ensure that you consult the relevant documentation and guidelines for your platform to create and manage secure partitions effectively.</p>
<hr />
<p><strong>Question:</strong> <code>[09:08]</code> Can I create a SP in run-time?</p>
<p><strong>Answer:</strong></p>
<p>Creating a Secure Partition (SP) during runtime is generally not recommended, as it could introduce security risks and may not be supported by some platforms. Secure Partitions are typically initialized during system startup or secure application launch to ensure proper isolation and security.</p>
<p>However, if your platform supports creating an SP during runtime and you have a valid use case, it might be possible. You would need to ensure that you take the necessary precautions to maintain the security of the system and the SPs, including:</p>
<ol>
<li>Ensuring proper isolation between the newly created SP and the rest of the system, including other SPs.</li>
<li>Configuring memory regions, peripherals, and access controls correctly.</li>
<li>Verifying the integrity and authenticity of the code and data being loaded into the new SP.</li>
</ol>
<p>Keep in mind that creating an SP during runtime may be more complex and error-prone than creating one during system startup or secure application launch. You should carefully consider the security implications and consult your platform&rsquo;s documentation to determine if this approach is supported and appropriate for your use case.</p>
<hr />
<p><strong>Question:</strong> <code>[09:08]</code> What is TA?</p>
<p><strong>Answer:</strong></p>
<p>TA stands for Trusted Application. In the context of ARM TrustZone or Trusted Execution Environments (TEEs), a Trusted Application is a secure piece of software running in the secure world. These applications are designed to handle sensitive data or perform security-critical operations, isolated from the normal world or non-secure applications.</p>
<p>Trusted Applications typically run on top of a TEE Operating System (TEE OS), which provides services like secure storage, cryptographic operations, and secure communication with the normal world. The TEE OS is responsible for managing and isolating multiple Trusted Applications, ensuring that they don&rsquo;t interfere with each other or leak sensitive data. Examples of TEE OSs include OP-TEE and Trustonic Kinibi.</p>
<p>Trusted Applications are usually loaded and instantiated by the TEE OS based on requests from the normal world or other secure world components. They can be used to perform a wide range of tasks, such as digital rights management, secure payment processing, biometric authentication, and more.</p>
<hr />
<p><strong>Question:</strong> <code>[09:24]</code> How do TAs and SPs communicate each other?</p>
<p><strong>Answer:</strong></p>
<p>TAs (Trusted Applications) and SPs (Secure Partitions) can communicate with each other using Inter-Partition Communication (IPC) mechanisms, which are platform-specific and depend on the underlying TEE (Trusted Execution Environment) OS or ARMv8.4-A architecture implementation.</p>
<p>When TAs and SPs need to communicate, they typically follow these steps:</p>
<ol>
<li>
<p>Establish a communication channel: Both TAs and SPs should have a well-defined communication interface, such as shared memory or message passing. The implementation details depend on the TEE OS for TAs and the platform&rsquo;s support for SPs.</p>
</li>
<li>
<p>Secure the communication channel: To ensure the confidentiality and integrity of data exchanged between TAs and SPs, use cryptographic techniques, such as encryption and authentication.</p>
</li>
<li>
<p>Exchange messages: TAs and SPs can exchange messages through the established communication channel. These messages may include requests for services, data to be processed, or responses.</p>
</li>
<li>
<p>Synchronize communication: Depending on the IPC mechanism used, it may be necessary to implement synchronization primitives, such as semaphores or mutexes, to coordinate communication between TAs and SPs.</p>
</li>
<li>
<p>Handle errors and exceptions: Implement error handling and exception mechanisms to manage communication failures, timeouts, or other unexpected events.</p>
</li>
</ol>
<p>It is essential to note that the communication between TAs and SPs requires careful implementation to ensure security and prevent potential attacks. Therefore, following best practices and guidelines for secure IPC is critical when developing communication between TAs and SPs.</p>
<hr />
<p><strong>Question:</strong> <code>[09:43]</code> Can a SP host many TAs?</p>
<p><strong>Answer:</strong></p>
<p>A Secure Partition (SP) can host multiple Trusted Applications (TAs) in a single isolated execution environment within the secure world. The Secure Partition Manager (SPM) is responsible for managing and scheduling these TAs. Each TA can provide a specific security service, and they can all run within the same SP. By hosting multiple TAs within an SP, you can share resources among TAs, such as memory or peripherals, which can improve overall efficiency and reduce the overhead of managing individual TAs in separate SPs.</p>
<hr />
<p><strong>Question:</strong> <code>[09:44]</code> Can a TA communicate different SP?</p>
<p><strong>Answer:</strong></p>
<p>A Trusted Application (TA) can communicate with different Secure Partitions (SPs) through a secure communication channel, which is typically established by the Secure Partition Manager (SPM) or another trusted component in the secure world. The communication between TAs and different SPs is usually facilitated by a well-defined interface using messages or function calls. This allows TAs to request services or share data with other SPs in a controlled and secure manner, without directly accessing each other&rsquo;s memory or resources. However, it is important to note that the level of isolation between TAs and SPs may vary depending on the specific implementation and platform.</p>
<hr />
<h2>Privilege Levels @ TrustZone.0329.md</h2>
<p><strong>Question:</strong> <code>[09:44]</code> What are EL0, EL1, EL2, S-EL0, S-EL1, S-EL2, S-EL3?</p>
<p><strong>Answer:</strong></p>
<p>In the ARMv8-A architecture, the privilege levels (EL) define different modes of operation for the processor, with each level having different access rights and capabilities. There are four Exception Levels (EL0, EL1, EL2, and EL3), and each level can operate in both Secure and Non-Secure states. Here&rsquo;s a brief explanation of each:</p>
<ol>
<li>
<p>EL0: This is the least privileged level, where user-space applications run. It has limited access to system resources and cannot execute privileged instructions.</p>
</li>
<li>
<p>EL1: This level is where the operating system kernel runs. It has more privileges than EL0, enabling it to manage system resources, configure the hardware, and isolate user-space applications from each other.</p>
</li>
<li>
<p>EL2: This level is intended for hypervisors, which manage multiple virtual machines or operating systems. It provides the necessary isolation and control to manage virtualization.</p>
</li>
<li>
<p>EL3: This is the most privileged level, typically used for low-level firmware, such as a bootloader or a Trusted Execution Environment (TEE). It is responsible for setting up the system and ensuring a secure boot process.</p>
</li>
</ol>
<p>The &ldquo;S-&rdquo; prefix indicates that the exception level is operating in the Secure state, which is part of ARM&rsquo;s TrustZone technology. TrustZone creates a separate, isolated environment for secure applications and data, ensuring that sensitive information remains protected from potential attacks or unauthorized access:</p>
<ol>
<li>S-EL0: Secure User mode, where secure user-space applications run.</li>
<li>S-EL1: Secure Kernel mode, where the secure operating system kernel runs.</li>
<li>S-EL2: Secure Hypervisor mode, where a secure hypervisor can manage secure virtual machines.</li>
<li>S-EL3: Secure Monitor mode, where low-level firmware like a secure bootloader or a TEE operates.</li>
</ol>
<p>In summary, the ARMv8-A architecture organizes the privilege levels (EL0, EL1, EL2, and EL3) and the Secure (S-EL0, S-EL1, S-EL2, and S-EL3) and Non-Secure states to create a robust and flexible environment for running a mix of secure and non-secure applications, operating systems, and hypervisors.</p>
<hr />
<h2>Basic Concepts @ TEE.0328.md</h2>
<p><strong>Question:</strong> <code>[10:04]</code> https://en.wikipedia.org/wiki/Trusted_execution_environment</p>
<p><strong>Answer:</strong></p>
<p>A Trusted Execution Environment (TEE) is a secure area within the main processor of a device that ensures the confidentiality and integrity of code and data loaded within it. TEEs are designed to provide a higher level of security compared to traditional software execution environments by protecting sensitive information and functionality from external software attacks, hardware attacks, and physical tampering.</p>
<p>The main concept behind a TEE is to provide an isolated environment for executing security-sensitive tasks that cannot be accessed by other processes running on the same device. This isolation is achieved using hardware and software mechanisms that create a secure boundary around the TEE.</p>
<p>Some of the key features of TEEs include:</p>
<ol>
<li>Isolation: TEEs provide a separate execution environment that isolates sensitive operations from the rest of the system.</li>
<li>Secure storage: TEEs provide a secure storage area for sensitive data, keys, and credentials that can only be accessed by the trusted applications running within the TEE.</li>
<li>Integrity: TEEs ensure the integrity of the code and data being executed by verifying the digital signatures of the applications before they are allowed to run within the TEE.</li>
<li>Confidentiality: TEEs protect the confidentiality of the data being processed within the environment by encrypting it.</li>
</ol>
<p>TEEs have various applications, such as secure boot, digital rights management (DRM), and mobile payments. Some examples of TEE implementations include ARM TrustZone, Intel Software Guard Extensions (SGX), and AMD Secure Encrypted Virtualization (SEV).</p>
<p>It is important to note that while TEEs offer a higher level of security, they are not immune to attacks. Researchers have discovered vulnerabilities in various TEE implementations, emphasizing the need for ongoing research and development to enhance the security of these environments.</p>
<hr />
<p><strong>Question:</strong> <code>[13:55]</code> Please summarize Intel SGX and ARM TrustZone in tables.</p>
<p><strong>Answer:</strong></p>
<p>Here&rsquo;s a summary of Intel SGX and ARM TrustZone in table format:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Intel SGX</th>
<th>ARM TrustZone</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Name</td>
<td>Intel Software Guard Extensions</td>
<td>ARM TrustZone</td>
</tr>
<tr>
<td>Type</td>
<td>Hardware-based security feature</td>
<td>Hardware-based security feature</td>
</tr>
<tr>
<td>Purpose</td>
<td>Create secure enclaves for running trusted code &amp; data</td>
<td>Create a secure environment for running trusted code &amp; data</td>
</tr>
<tr>
<td>Architecture</td>
<td>x86-based processors</td>
<td>ARM-based processors</td>
</tr>
<tr>
<td>Isolation Method</td>
<td>Enclaves</td>
<td>Two worlds (Secure and Non-secure)</td>
</tr>
<tr>
<td>Memory Protection</td>
<td>Hardware-based encryption of enclave memory</td>
<td>Secure memory is isolated from the non-secure world</td>
</tr>
<tr>
<td>Remote Attestation</td>
<td>Supported, enables remote verification of enclave integrity</td>
<td>Supported, enables remote verification of secure world integrity</td>
</tr>
<tr>
<td>Applications</td>
<td>Secure computation, data protection, key management, etc.</td>
<td>Secure boot, DRM, mobile payments, key management, etc.</td>
</tr>
<tr>
<td>Vulnerabilities</td>
<td>Side-channel attacks, Spectre, Meltdown, etc.</td>
<td>Side-channel attacks, information leakage, etc.</td>
</tr>
</tbody>
</table>
<p>Both Intel SGX and ARM TrustZone are hardware-based security features designed to provide isolated execution environments for trusted code and data. They offer different mechanisms for isolation (enclaves vs. two worlds) and have unique implementations in their respective processor architectures (x86-based for SGX and ARM-based for TrustZone). While these technologies enhance the security of sensitive operations, they are not immune to various attacks, and ongoing research and development is required to improve their security.</p>
<hr />
<p><strong>Question:</strong> <code>[13:58]</code> What are different between ARM SMC and Intel SMI? Please also summarize in a table.</p>
<p><strong>Answer:</strong></p>
<p>ARM SMC (Secure Monitor Call) and Intel SMI (System Management Interrupt) are both mechanisms used in their respective processor architectures for managing secure or privileged operations. Here&rsquo;s a summary of their differences in table format:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>ARM SMC</th>
<th>Intel SMI</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Name</td>
<td>Secure Monitor Call</td>
<td>System Management Interrupt</td>
</tr>
<tr>
<td>Type</td>
<td>Instruction for switching between secure &amp; non-secure worlds</td>
<td>Interrupt for managing system-level functions</td>
</tr>
<tr>
<td>Architecture</td>
<td>ARM-based processors</td>
<td>x86-based processors</td>
</tr>
<tr>
<td>Purpose</td>
<td>Transition between secure and non-secure worlds in ARM TrustZone</td>
<td>Execute system management functions in System Management Mode (SMM)</td>
</tr>
<tr>
<td>Invocation</td>
<td>Issued by software to request a switch between worlds</td>
<td>Triggered by hardware events or software requests</td>
</tr>
<tr>
<td>Execution Context</td>
<td>Secure world in ARM TrustZone</td>
<td>System Management Mode on x86 processors</td>
</tr>
<tr>
<td>Privilege Level</td>
<td>Highest privilege level in ARM TrustZone</td>
<td>Highest privilege level in x86 processors</td>
</tr>
<tr>
<td>Applications</td>
<td>Secure boot, DRM, mobile payments, key management, etc.</td>
<td>Power management, hardware configuration, firmware updates, etc.</td>
</tr>
</tbody>
</table>
<p>ARM SMC is an instruction used in ARM-based processors to switch between the secure and non-secure worlds of ARM TrustZone, enabling the processor to execute secure operations. In contrast, Intel SMI is an interrupt mechanism used in x86-based processors to manage system-level functions, such as power management and hardware configuration, in the System Management Mode (SMM). While both mechanisms operate at the highest privilege levels of their respective architectures, they serve different purposes and are invoked under different circumstances.</p>
<hr />
<p><strong>Question:</strong> <code>[13:59]</code> Please describe TEE in Intel.</p>
<p><strong>Answer:</strong></p>
<p>In Intel processors, the primary Trusted Execution Environment (TEE) technology is Intel Software Guard Extensions (SGX). Intel SGX provides a hardware-based TEE to securely execute sensitive code and protect data within isolated regions, known as enclaves.</p>
<p>Here&rsquo;s an overview of Intel SGX:</p>
<ol>
<li>
<p>Enclaves: Enclaves are secure, isolated regions in the processor&rsquo;s memory that cannot be accessed by other processes or privileged software, such as the operating system, hypervisors, or other system software. They provide confidentiality and integrity for the data and code being executed within the enclave.</p>
</li>
<li>
<p>Memory encryption: Intel SGX encrypts the enclave memory using hardware-based encryption, which ensures that the data within the enclave remains confidential even if the physical memory is compromised.</p>
</li>
<li>
<p>Remote attestation: Intel SGX supports remote attestation, which enables a remote party to verify the integrity and authenticity of the enclave. This process ensures that the enclave is running the expected code and has not been tampered with.</p>
</li>
<li>
<p>Sealing: Intel SGX provides sealing functionality, which allows data to be encrypted and stored outside the enclave using a key that is bound to the enclave&rsquo;s identity. This ensures that the data can only be decrypted by the same enclave or an enclave with the same identity, providing confidentiality for data at rest.</p>
</li>
<li>
<p>Application development: Developers can create applications that use Intel SGX by partitioning their code and data into trusted and untrusted components. The trusted components, which contain sensitive operations and data, are executed within enclaves, while the untrusted components are executed outside the enclave.</p>
</li>
</ol>
<p>Intel SGX is a powerful TEE solution that provides an additional layer of security for sensitive code and data execution. However, it is important to note that Intel SGX is not immune to attacks, and researchers have discovered vulnerabilities in the technology, emphasizing the need for ongoing research and development to enhance its security.</p>
<hr />
<p><strong>Question:</strong> <code>[14:00]</code> What are APIs of TEE? Please classify them.</p>
<p><strong>Answer:</strong></p>
<p>Trusted Execution Environment (TEE) APIs are interfaces that enable developers to create applications that leverage the features of a TEE. They allow developers to interact with the secure environment and manage its resources, such as enclaves, secure storage, and cryptographic operations.</p>
<p>These APIs can be classified into several categories:</p>
<ol>
<li>
<p>TEE Management APIs:
   - Enclave or secure world creation and destruction
   - Resource management, such as memory allocation and deallocation
   - Context switching between the secure and non-secure worlds</p>
</li>
<li>
<p>Cryptographic APIs:
   - Key management, including key generation, import, export, and storage
   - Cryptographic operations, such as encryption, decryption, signing, and verification
   - Secure random number generation
   - Cryptographic hash functions and message authentication codes (MACs)</p>
</li>
<li>
<p>Secure Storage APIs:
   - Secure storage of sensitive data, keys, and credentials
   - Data integrity and confidentiality protection
   - Access control and permission management</p>
</li>
<li>
<p>Attestation APIs:
   - Enclave or secure world measurement and reporting
   - Remote attestation to verify the integrity and authenticity of a TEE
   - Sealing and unsealing of data bound to the enclave or secure world identity</p>
</li>
<li>
<p>Communication APIs:
   - Secure communication channels between the TEE and external entities
   - Secure communication between enclaves or secure worlds</p>
</li>
</ol>
<p>Examples of TEE API implementations include the GlobalPlatform TEE APIs, which provide a standardized set of APIs for TEEs, and platform-specific APIs like Intel SGX SDK for Intel Software Guard Extensions and ARM TrustZone APIs for ARM TrustZone-based TEEs.</p>
<p>It is important to note that the specific APIs available and their implementation may vary depending on the TEE technology used. However, the general categories mentioned above should apply to most TEE implementations.</p>
<hr />
<p><strong>Question:</strong> <code>[14:02]</code> Can I add a myself TEE API?</p>
<p><strong>Answer:</strong></p>
<p>Adding your own TEE API is possible but depends on the specific TEE implementation you are working with and the level of access and customization it allows. Some TEEs offer more flexibility for developers to extend and create their own APIs, while others may have more restrictive environments.</p>
<p>Here are a few steps to consider when adding your own TEE API:</p>
<ol>
<li>
<p>Understand the TEE platform: Gain a deep understanding of the TEE platform you are working with, its architecture, and the existing APIs it provides. Familiarize yourself with the development environment, tools, and documentation.</p>
</li>
<li>
<p>Identify the use case: Determine the specific functionality or use case you want to address with your custom TEE API. Ensure that it is not already covered by existing APIs and that it aligns with the security objectives of the TEE.</p>
</li>
<li>
<p>Design the API: Design the API interface, considering factors such as function signatures, input and output parameters, and error handling. Keep security best practices in mind during the design process.</p>
</li>
<li>
<p>Implement the API: Write the code for your custom TEE API, following the platform&rsquo;s guidelines and using the development tools provided by the TEE vendor. Be sure to adhere to secure coding practices to avoid introducing vulnerabilities in your implementation.</p>
</li>
<li>
<p>Test and validate: Thoroughly test your custom TEE API, including edge cases and potential error conditions. Validate its functionality and security in the context of the TEE platform.</p>
</li>
<li>
<p>Integrate and document: Integrate your custom TEE API with your application or system, and create documentation to help other developers understand how to use your API.</p>
</li>
</ol>
<p>Keep in mind that adding your own TEE API may introduce security risks if not done properly. It is crucial to ensure that your implementation adheres to security best practices and does not compromise the integrity and confidentiality of the TEE.</p>
<p>Before attempting to add your own TEE API, it is recommended to explore existing APIs and functionality provided by the TEE platform, as they are designed to address common use cases and have undergone extensive testing and validation.</p>
<hr />
<h2>Memory @ OP-TEE.0327.md</h2>
<p><strong>Question:</strong> <code>[16:19]</code> How does OP-TEE manage memory?</p>
<p><strong>Answer:</strong></p>
<p>OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. Memory management in OP-TEE involves several aspects:</p>
<ol>
<li>
<p>Secure memory allocation: OP-TEE uses secure memory for storing sensitive data and code related to the secure kernel and trusted applications (TAs). It ensures that secure memory is not accessible by the normal world to maintain confidentiality and integrity. OP-TEE provides APIs for trusted applications to allocate and deallocate secure memory dynamically.</p>
</li>
<li>
<p>Trusted Application memory isolation: OP-TEE maintains memory isolation between different trusted applications, preventing them from accessing each other&rsquo;s memory regions. This ensures the confidentiality and integrity of data and code in each trusted application.</p>
</li>
<li>
<p>Shared memory management: OP-TEE manages shared memory to facilitate secure data exchange between the normal world and the secure world. The GlobalPlatform TEE Client API provides functions to allocate, register, and release shared memory. OP-TEE ensures proper access control and isolation for shared memory buffers.</p>
</li>
<li>
<p>Memory mapping: OP-TEE manages the memory mapping for the secure world, ensuring that the memory regions for the secure kernel, trusted applications, and shared memory are correctly mapped to physical memory addresses.</p>
</li>
<li>
<p>Memory protection: OP-TEE enforces memory protection policies for the secure world, including access controls, permissions, and execution restrictions. This helps prevent unauthorized access, tampering, or execution of secure memory regions.</p>
</li>
<li>
<p>Memory management for trusted applications: Trusted applications in OP-TEE can request memory from the TEE Core, which is the secure kernel, through TEE Internal API functions like TEE_Malloc, TEE_Realloc, and TEE_Free. These functions allow trusted applications to allocate and manage memory dynamically within their secure environment.</p>
</li>
</ol>
<p>In summary, OP-TEE manages memory within the secure world to ensure isolation, security, and efficient use of resources. This includes secure memory allocation, isolation between trusted applications, shared memory management, memory mapping, memory protection, and dynamic memory management for trusted applications.</p>
<hr />
<p><strong>Question:</strong> <code>[16:27]</code> Are data in memory in secure world encrypted?</p>
<p><strong>Answer:</strong></p>
<p>Data stored in the memory of the secure world in OP-TEE is not encrypted by default. However, the secure world memory is protected by the hardware-based isolation provided by Arm TrustZone technology. TrustZone ensures that the normal world cannot directly access or tamper with the secure world&rsquo;s memory, which includes the secure kernel, trusted applications, and their associated data.</p>
<p>Although the data in the secure world memory is not encrypted, the isolation and access controls provided by TrustZone offer a strong level of protection. If an application or use case demands an even higher level of security, it is possible for trusted applications to implement additional encryption or other security measures for sensitive data stored in memory. This would depend on the specific requirements and threat model of the application or system.</p>
<p>In summary, data in the secure world memory is not encrypted by default in OP-TEE, but it is protected by the hardware-based isolation provided by Arm TrustZone technology. Additional encryption or security measures can be implemented by trusted applications if required.</p>
<hr />
<h2>Signature @ OP-TEE.0327.md</h2>
<p><strong>Question:</strong> <code>[16:44]</code> Is signature required when a normal world application request a service in secure world?</p>
<p><strong>Answer:</strong></p>
<p>A signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. The communication between the normal world application and the trusted application is facilitated using the GlobalPlatform TEE Client API, which ensures proper access control and isolation for shared memory buffers used for data exchange.</p>
<p>However, a signature may be used in certain scenarios to enhance security. For example, if the normal world application sends sensitive data or a critical command to the trusted application, it might be useful to sign the data or command to ensure integrity and authenticity. This would help prevent tampering or replay attacks, especially in cases where the normal world might be compromised.</p>
<p>In such cases, the normal world application can sign the data or command using a private key, and the trusted application in the secure world can verify the signature using the corresponding public key. This ensures that the data or command has not been altered and that it originates from a trusted source.</p>
<p>In summary, a signature is not strictly required when a normal world application requests a service from a trusted application in the secure world. However, signatures can be used in certain scenarios to enhance security by ensuring the integrity and authenticity of data or commands sent to the secure world.</p>
<hr />
<h2>CA &amp; TA @ TEE.0328.md</h2>
<p><strong>Question:</strong> <code>[16:56]</code> How does an  application in normal world request a service with shared memory of a trusted application in a secure world? Please describe the process with APIs.</p>
<p><strong>Answer:</strong></p>
<p>In a Trusted Execution Environment (TEE), a normal world application can request a service from a trusted application in the secure world using shared memory for data exchange. The process involves allocating a memory buffer that can be accessed by both the normal world and the secure world, allowing for efficient and secure communication between the two. Here&rsquo;s an outline of the process using the GlobalPlatform TEE APIs as an example:</p>
<ol>
<li>
<p>Initialize context: The normal world application initializes a TEE context, which represents a connection to the TEE. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_InitializeContext</code> function.</p>
</li>
<li>
<p>Open session: The normal world application opens a session with the trusted application in the secure world. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_OpenSession</code> function.</p>
</li>
<li>
<p>Allocate shared memory: The normal world application allocates a shared memory buffer that can be accessed by both the normal world and the secure world. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_RegisterSharedMemory</code> function.</p>
</li>
<li>
<p>Prepare data: The normal world application writes the input data and any necessary parameters into the shared memory buffer.</p>
</li>
<li>
<p>Issue the call: The normal world application issues a call to the trusted application in the secure world to request the service, providing a reference to the shared memory buffer as part of the call. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_InvokeCommand</code> function.</p>
</li>
<li>
<p>Process the request: The trusted application in the secure world processes the request, reads the input data from the shared memory buffer, performs the required operations, and writes the response back into the shared memory buffer.</p>
</li>
<li>
<p>Return to the normal world: Once the trusted application in the secure world has completed processing the request, control is returned to the normal world application.</p>
</li>
<li>
<p>Process the response: The normal world application reads the response from the shared memory buffer and processes it accordingly.</p>
</li>
<li>
<p>Release shared memory: After the response has been processed, the normal world application releases the shared memory buffer. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_ReleaseSharedMemory</code> function.</p>
</li>
<li>
<p>Close session: The normal world application closes the session with the trusted application in the secure world. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_CloseSession</code> function.</p>
</li>
<li>
<p>Finalize context: The normal world application finalizes the TEE context, releasing any resources associated with it. In the GlobalPlatform TEE APIs, this is done using the <code>TEEC_FinalizeContext</code> function.</p>
</li>
</ol>
<p>Please note that the specific APIs and mechanisms for requesting a service using shared memory in the secure world may vary depending on the TEE implementation being used. The example provided above is based on the GlobalPlatform TEE APIs, which are widely used in the industry for TEE development. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different APIs and mechanisms for managing shared memory communication between the normal world and the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[17:10]</code> Which functions are used by TA (trusted application) in the above process?</p>
<p><strong>Answer:</strong></p>
<p>In the process described above, the Trusted Application (TA) in the secure world is responsible for handling requests from the normal world application and performing the requested operations. To do this, the TA needs to implement certain functions to interact with the TEE and the normal world application. The specific functions depend on the TEE implementation being used. Here, we&rsquo;ll use the GlobalPlatform TEE Internal APIs as an example:</p>
<ol>
<li>
<p>TA_CreateEntryPoint: This function is called when the TA is first loaded by the TEE. It can be used to perform initial setup or resource allocation. The function is optional and may be left empty if no specific actions are required at this stage.</p>
</li>
<li>
<p>TA_DestroyEntryPoint: This function is called when the TA is unloaded by the TEE. It can be used to perform cleanup or resource deallocation. The function is optional and may be left empty if no specific actions are required at this stage.</p>
</li>
<li>
<p>TA_OpenSessionEntryPoint: This function is called when the normal world application opens a session with the TA. It can be used to perform session-specific setup, such as allocating session-specific resources or initializing session context. The function should return TEE_SUCCESS on success or an appropriate error code on failure.</p>
</li>
<li>
<p>TA_CloseSessionEntryPoint: This function is called when the normal world application closes a session with the TA. It can be used to perform session-specific cleanup, such as deallocating session-specific resources or clearing session context. The function is optional and may be left empty if no specific actions are required at this stage.</p>
</li>
<li>
<p>TA_InvokeCommandEntryPoint: This function is called when the normal world application issues a call to the TA to request a service. The function is responsible for processing the request, reading the input data from the shared memory buffer (if used), performing the required operations, and writing the response back into the shared memory buffer (if used). The function should return TEE_SUCCESS on success or an appropriate error code on failure.</p>
</li>
</ol>
<p>The specific functions and APIs used by a Trusted Application (TA) may vary depending on the TEE implementation being used. The example provided above is based on the GlobalPlatform TEE Internal APIs, which are widely used in the industry for developing TAs in a TEE. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different functions and APIs for implementing TAs in the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[17:16]</code> Could you please draw a sequence diagram of TEEC_InitializeContext, TEEC_OpenSession, TEEC_RegisterSharedMemory, TEEC_InvokeCommand, TEEC_ReleaseSharedMemory, TEEC_CloseSession, TEEC_FinalizeContext, TA_CreateEntryPoint, TA_DestroyEntryPoint, TA_OpenSessionEntryPoint, TA_CloseSessionEntryPoint, TA_InvokeCommandEntryPoint</p>
<p><strong>Answer:</strong></p>
<p>As a text-based AI language model, I cannot directly draw diagrams. However, I can describe the sequence of events and interactions between the normal world application and the trusted application in the secure world using the APIs mentioned in your question. You can use this description to create your own sequence diagram.</p>
<ol>
<li>
<p>The normal world application calls <code>TEEC_InitializeContext</code> to initialize a TEE context.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_OpenSession</code> to open a session with the trusted application.
   a. The TEE loads the trusted application if not already loaded.
   b. The TEE calls <code>TA_CreateEntryPoint</code> in the trusted application for initialization.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_RegisterSharedMemory</code> to allocate a shared memory buffer.</p>
</li>
<li>
<p>The normal world application writes input data to the shared memory buffer.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_InvokeCommand</code>, passing a reference to the shared memory buffer.
   a. The TEE calls <code>TA_OpenSessionEntryPoint</code> in the trusted application to indicate a new session is opened.
   b. The TEE calls <code>TA_InvokeCommandEntryPoint</code> in the trusted application to process the request.
      i. The trusted application reads input data from the shared memory buffer.
      ii. The trusted application performs the requested operations.
      iii. The trusted application writes the response back to the shared memory buffer.</p>
</li>
<li>
<p>The normal world application reads the response from the shared memory buffer.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_ReleaseSharedMemory</code> to release the shared memory buffer.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_CloseSession</code> to close the session with the trusted application.
   a. The TEE calls <code>TA_CloseSessionEntryPoint</code> in the trusted application to indicate the session is closed.</p>
</li>
<li>
<p>The normal world application calls <code>TEEC_FinalizeContext</code> to finalize the TEE context.
   a. The TEE unloads the trusted application if no other sessions are open.
   b. The TEE calls <code>TA_DestroyEntryPoint</code> in the trusted application for cleanup.</p>
</li>
</ol>
<p>You can use this sequence of events to create a diagram illustrating the interactions between the normal world application, the TEE system, and the trusted application in the secure world using the specified APIs.</p>
<hr />
<p><strong>Question:</strong> <code>[17:25]</code> Is the above sequence described in GlobalPlatform?</p>
<p><strong>Answer:</strong></p>
<p>Yes, the sequence of events and interactions between the normal world application and the trusted application in the secure world, as described in the previous response, is based on the GlobalPlatform TEE specifications. GlobalPlatform provides a set of standard APIs, including the TEE Client API (used by the normal world application) and the TEE Internal API (used by the trusted application), to facilitate secure communication and service invocation in a Trusted Execution Environment (TEE).</p>
<p>The GlobalPlatform TEE specifications can be found on the GlobalPlatform website, which provides detailed documentation on the APIs and their usage: https://www.globalplatform.org/specs-library/?search=tee</p>
<p>It&rsquo;s important to note that the specific APIs and mechanisms for requesting a service using shared memory in the secure world may vary depending on the TEE implementation being used. The example provided in the previous response is based on the GlobalPlatform TEE APIs, which are widely used in the industry for TEE development. Other TEE implementations, such as Intel SGX or ARM TrustZone, may have different APIs and mechanisms for managing shared memory communication between the normal world and the secure world.</p>
<hr />
<p><strong>Question:</strong> <code>[17:27]</code> Which document describe it?</p>
<p><strong>Answer:</strong></p>
<p>The sequence described in the previous responses is based on the GlobalPlatform TEE specifications, which are divided into two main documents:</p>
<ol>
<li>GlobalPlatform TEE Client API Specification: This document describes the APIs used by the normal world application to interact with the TEE, such as <code>TEEC_InitializeContext</code>, <code>TEEC_OpenSession</code>, <code>TEEC_RegisterSharedMemory</code>, <code>TEEC_InvokeCommand</code>, <code>TEEC_ReleaseSharedMemory</code>, <code>TEEC_CloseSession</code>, and <code>TEEC_FinalizeContext</code>. The latest version of this document can be found at:</li>
</ol>
<p>https://globalplatform.org/specs-library/tee-client-api-specification/</p>
<ol start="2">
<li>GlobalPlatform TEE Internal Core API Specification: This document describes the APIs used by the trusted application in the secure world, such as <code>TA_CreateEntryPoint</code>, <code>TA_DestroyEntryPoint</code>, <code>TA_OpenSessionEntryPoint</code>, <code>TA_CloseSessionEntryPoint</code>, and <code>TA_InvokeCommandEntryPoint</code>. The latest version of this document can be found at:</li>
</ol>
<p>https://globalplatform.org/specs-library/tee-internal-core-api-specification/</p>
<p>Both documents provide detailed information on the APIs and their usage, including the sequence of interactions between the normal world application and the trusted application in the secure world. By studying these documents, you can gain a deep understanding of the TEE development process based on the GlobalPlatform specifications.</p>
<hr />
<p><strong>Question:</strong> <code>[17:36]</code> Please give me two sample codes of the above sequence. One is for CA and another is for TA.</p>
<p><strong>Answer:</strong></p>
<p>Here are two sample codes for the normal world application (Client Application, CA) and the secure world application (Trusted Application, TA) based on the GlobalPlatform TEE APIs:</p>
<p>Client Application (CA) - Normal World:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_client_api.h&gt;</span><span class="cp"></span>

<span class="cp">#define TA_UUID {0x12345678, 0x1234, 0x1234, {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF}}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Result</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Context</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Session</span><span class="w"> </span><span class="n">session</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_SharedMemory</span><span class="w"> </span><span class="n">sharedMem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_Operation</span><span class="w"> </span><span class="n">operation</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">returnOrigin</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize context</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_InitializeContext</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to initialize context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Open session</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_OpenSession</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">session</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">TA_UUID</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_LOGIN_PUBLIC</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">returnOrigin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to open session</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">TEEC_FinalizeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate shared memory</span>
<span class="w">    </span><span class="n">sharedMem</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">sharedMem</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_MEM_INPUT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TEEC_MEM_OUTPUT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_RegisterSharedMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to allocate shared memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">TEEC_CloseSession</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">TEEC_FinalizeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prepare operation</span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">paramTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_PARAM_TYPES</span><span class="p">(</span><span class="n">TEEC_MEMREF_PARTIAL_INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_MEMREF_PARTIAL_OUTPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_NONE</span><span class="p">,</span><span class="w"> </span><span class="n">TEEC_NONE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">operation</span><span class="p">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">outputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">sharedMem</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Invoke command</span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEEC_InvokeCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0000</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">operation</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">returnOrigin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEEC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to invoke command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outputData</span><span class="p">,</span><span class="w"> </span><span class="n">sharedMem</span><span class="p">.</span><span class="n">buffer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Input: %d, Output: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">outputData</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Release shared memory</span>
<span class="w">    </span><span class="n">TEEC_ReleaseSharedMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sharedMem</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Close session and finalize context</span>
<span class="w">    </span><span class="n">TEEC_CloseSession</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">TEEC_FinalizeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Trusted Application (TA) - Secure World:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api_extensions.h&gt;</span><span class="cp"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_CreateEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_DestroyEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_OpenSessionEntryPoint</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">paramTypes</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">sessionContext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_CloseSessionEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="w"></span>

<span class="o">---</span><span class="w"></span>

<span class="o">**</span><span class="nl">Question</span><span class="p">:</span><span class="o">**</span><span class="w"> </span><span class="err">`</span><span class="p">[</span><span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="p">]</span><span class="err">`</span><span class="w"> </span><span class="n">Please</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">TA</span><span class="w"> </span><span class="n">again</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">complete</span><span class="p">.</span><span class="w"></span>

<span class="o">**</span><span class="nl">Answer</span><span class="p">:</span><span class="o">**</span><span class="w"></span>

<span class="n">Apologies</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">incomplete</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">earlier</span><span class="p">.</span><span class="w"> </span><span class="n">Here</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">complete</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Trusted</span><span class="w"> </span><span class="n">Application</span><span class="w"> </span><span class="p">(</span><span class="n">TA</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">secure</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="n">based</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GlobalPlatform</span><span class="w"> </span><span class="n">TEE</span><span class="w"> </span><span class="n">Internal</span><span class="w"> </span><span class="nl">API</span><span class="p">:</span><span class="w"></span>

<span class="err">```</span><span class="n">c</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tee_internal_api_extensions.h&gt;</span><span class="cp"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="n">TA_CreateEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform initialization tasks, if needed</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_DestroyEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform cleanup tasks, if needed</span>
<span class="p">}</span><span class="w"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_OpenSessionEntryPoint</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">paramTypes</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">sessionContext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform session-specific initialization tasks, if needed</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TA_CloseSessionEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Perform session-specific cleanup tasks, if needed</span>
<span class="p">}</span><span class="w"></span>

<span class="n">TEE_Result</span><span class="w"> </span><span class="nf">TA_InvokeCommandEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sessionContext</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">commandID</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">paramTypes</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_Param</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TEE_Result</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_ERROR_NOT_SUPPORTED</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">commandID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x0000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Sample command</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">paramTypes</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TEE_PARAM_TYPES</span><span class="p">(</span><span class="n">TEE_PARAM_TYPE_MEMREF_INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_PARAM_TYPE_MEMREF_OUTPUT</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_PARAM_TYPE_NONE</span><span class="p">,</span><span class="w"> </span><span class="n">TEE_PARAM_TYPE_NONE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_ERROR_BAD_PARAMETERS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">TEE_MemBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">inputBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">TEE_MemBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">outputBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">memref</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">TEE_ERROR_BAD_PARAMETERS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">TEE_MemMove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inputData</span><span class="p">,</span><span class="w"> </span><span class="n">inputBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">outputData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputData</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">TEE_MemMove</span><span class="p">(</span><span class="n">outputBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">outputData</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEE_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>This sample Trusted Application code defines the required entry points for creating, destroying, opening, and closing a session. The <code>TA_InvokeCommandEntryPoint</code> function implements a simple command that reads an integer from the input buffer, multiplies it by 2, and writes the result back to the output buffer.</p>
<hr />
    </article>
  </body>
</html>
